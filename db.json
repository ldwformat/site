{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/browserconfig.xml","path":"browserconfig.xml","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/header.ejs","path":"header.ejs","modified":1,"renderable":0},{"_id":"source/footer.ejs","path":"footer.ejs","modified":1,"renderable":0},{"_id":"source/icon.png","path":"icon.png","modified":1,"renderable":0},{"_id":"source/logo.png","path":"logo.png","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/logo.svg","path":"logo.svg","modified":1,"renderable":0},{"_id":"source/tile-wide.png","path":"tile-wide.png","modified":1,"renderable":0},{"_id":"source/tile.png","path":"tile.png","modified":1,"renderable":0},{"_id":"source/docs/images/rust_playground.png","path":"docs/images/rust_playground.png","modified":1,"renderable":0},{"_id":"themes/navy/source/css/navy.styl","path":"css/navy.styl","modified":1,"renderable":1},{"_id":"themes/navy/source/js/lang_select.js","path":"js/lang_select.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/mobile_nav.js","path":"js/mobile_nav.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/docs/images/learning_rust_medium.jpg","path":"docs/images/learning_rust_medium.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/browserconfig.xml","hash":"fbbe41933e15560e7852d721804f026586ee912f","modified":1537969649328},{"_id":"source/favicon.ico","hash":"63e4879d10467b4bc481a208c3a64649242a1420","modified":1537969649341},{"_id":"source/header.ejs","hash":"f11e05683613fadbe26d60c0e4caa17446a3f753","modified":1537969649342},{"_id":"source/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1537969649341},{"_id":"source/icon.png","hash":"2e2866bf9acc59972ff373313a4a55d63a99d5fa","modified":1537969649342},{"_id":"source/index.jade","hash":"304cabec2bb77a92146581114b5db83477307c06","modified":1545053139152},{"_id":"source/logo.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649342},{"_id":"source/robots.txt","hash":"99982b66ad7cd8004bc97a41ee92a7fb05c986ab","modified":1537969649343},{"_id":"source/logo.svg","hash":"5e0c7d1865879f49f310bd47a09b97963c48b301","modified":1537969649343},{"_id":"source/tile-wide.png","hash":"24120ca25a08d3dce34608fd99dcfda0955fc6b9","modified":1537969649344},{"_id":"source/tile.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649344},{"_id":"source/_data/languages.yml","hash":"f6ca069b95ecc899c54143606db156542cb65431","modified":1545049659802},{"_id":"source/_data/sidebar.yml","hash":"8f610024a31e18d66b24a09e726a7e8dc10f2d7f","modified":1537969649328},{"_id":"source/docs/a1.why_rust.md","hash":"b5a759597d80e81f3c2a5bd18a0c087827bcbb34","modified":1537969649328},{"_id":"source/_data/menu.yml","hash":"4d92fec119c237b2c0d0ad45e66f5dac7bd50c59","modified":1537969649328},{"_id":"source/docs/a10.control_flows.md","hash":"01d70eb768bcb3aa3ce826ed4ceccad2f1993f35","modified":1537969649328},{"_id":"source/docs/a2.installation.md","hash":"24f7bf57b6517154ff868da9da14c4add98cf8a9","modified":1537969649329},{"_id":"source/docs/a4.cargo,crates_and_basic_project_structure.md","hash":"30fdd7440b2e3bc5aec757afd4fc3a7e020fa63c","modified":1537969649329},{"_id":"source/docs/a3.hello_world.md","hash":"ba4829313b5431d0ab7066a581d9f3794805dd5e","modified":1537969649329},{"_id":"source/docs/a5.comments_and_documenting_the_code.md","hash":"10f8749d3a8f6c7f02fa9c96e90f91debfbf08eb","modified":1537969649329},{"_id":"source/docs/a6.variable_bindings,constants_and_statics.md","hash":"9b8c24ff7b7802393ff6261c0e646e8f6a1710b9","modified":1537969649329},{"_id":"source/docs/a7.functions.md","hash":"ccf6381f015ece607907261b8aed8198edf106f6","modified":1537969649330},{"_id":"source/docs/a8.primitive_data_types.md","hash":"30305ebe7287398654305451db20f230cf52ea45","modified":1537969649330},{"_id":"source/docs/a9.operators.md","hash":"12522be27f4d522ee96cfda556900ca02e6b98ad","modified":1537969649330},{"_id":"source/docs/b1.vectors.md","hash":"501b1a01586ec2832730d851f3712a2f2c644fff","modified":1537969649331},{"_id":"source/docs/b2.structs.md","hash":"cf526b9c92b58916f8bb9402bb3e09a2f027ded6","modified":1537969649331},{"_id":"source/docs/b3.enums.md","hash":"1fbb49355b7efdaf29140e3fbf178592eae60362","modified":1537969649331},{"_id":"source/docs/b4.generics.md","hash":"169ff9b1a0d44b9a53e7435163d4e5a41aeb5378","modified":1537969649332},{"_id":"source/docs/b5.impls_and_traits.md","hash":"ca56634d1900c7acf0cb95547c99620594fe7dd2","modified":1537969649332},{"_id":"source/docs/c1.ownership.md","hash":"d07cd45fb444b328287c31f52e77a44894d43167","modified":1537969649332},{"_id":"source/docs/c2.borrowing.md","hash":"0e9c6ef9b0dbbc0ec7b21bf48857ec719748680a","modified":1537969649332},{"_id":"source/docs/c3.lifetimes.md","hash":"201c598dd8a745bd7ec70080401eab323a730f83","modified":1537969649333},{"_id":"source/docs/d1.code_organization.md","hash":"244e1e3c0e860b9f37f6e5816811ffaf54efb33e","modified":1537969649333},{"_id":"source/docs/d2.functions.md","hash":"f7980784d321a7c82e5c439ff4b637c15841886e","modified":1537969649333},{"_id":"source/docs/d3.modules.md","hash":"09cb368ddd985465950df006dba5625b3f8d1b21","modified":1537969649333},{"_id":"source/docs/d5.workspaces.md","hash":"8b6ea3fd7457ede0f13c61a098314fa2350399a0","modified":1537969649334},{"_id":"source/docs/d6.use.md","hash":"31a4e957de4a9b5536ec5d78d12f04edde6e386f","modified":1537969649334},{"_id":"source/docs/d4.crates.md","hash":"cec2915e8677b9eb9b848afb28d3742112ea72d7","modified":1537969649334},{"_id":"source/docs/d7.std_primitives_and_preludes.md","hash":"8c5ef8f5c191f518dfcd7de1ac4682b12d47c272","modified":1537969649335},{"_id":"source/docs/index.md","hash":"b69b14f0bdc74a4d29983d7c14d4f6baa80f41ca","modified":1537969649341},{"_id":"source/zh-cn/index.jade","hash":"a75a061d696d4c48814d07bc627d36ee51ce2e7c","modified":1545053142641},{"_id":"themes/navy/layout/index.swig","hash":"c52c941a231710700aeafd4866d964c069afb6a6","modified":1537969649345},{"_id":"themes/navy/languages/zh-cn.yml","hash":"940e0d9b2330d05f69f4f3f0d18632ada54ebcc7","modified":1545053347170},{"_id":"themes/navy/languages/en.yml","hash":"f7e66e7575c625a5ebdcbe760059931122736af0","modified":1537969649345},{"_id":"themes/navy/layout/layout.swig","hash":"ef28a5f5fc3258622e72ee3a836ff8cf415fb790","modified":1537969649345},{"_id":"themes/navy/layout/page.swig","hash":"85ac992e8fc5a6577f434c65f6f71fa021a36114","modified":1537969649346},{"_id":"source/docs/zh-cn/a10.control_flows.md","hash":"01d70eb768bcb3aa3ce826ed4ceccad2f1993f35","modified":1545049659803},{"_id":"source/docs/zh-cn/a1.why_rust.md","hash":"489a8635a05b59a3acce580a78f1f315cbafaf0c","modified":1545051215069},{"_id":"source/docs/images/rust_playground.png","hash":"c3b021fb45cb2ebdc7689ba7fe809841c9f4af03","modified":1537969649341},{"_id":"source/docs/zh-cn/a2.installation.md","hash":"24f7bf57b6517154ff868da9da14c4add98cf8a9","modified":1545049659803},{"_id":"source/docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","hash":"30fdd7440b2e3bc5aec757afd4fc3a7e020fa63c","modified":1545049659804},{"_id":"source/docs/zh-cn/a5.comments_and_documenting_the_code.md","hash":"10f8749d3a8f6c7f02fa9c96e90f91debfbf08eb","modified":1545049659804},{"_id":"source/docs/zh-cn/a3.hello_world.md","hash":"ba4829313b5431d0ab7066a581d9f3794805dd5e","modified":1545049659803},{"_id":"source/docs/zh-cn/a6.variable_bindings,constants_and_statics.md","hash":"9b8c24ff7b7802393ff6261c0e646e8f6a1710b9","modified":1545049659804},{"_id":"source/docs/zh-cn/a7.functions.md","hash":"ccf6381f015ece607907261b8aed8198edf106f6","modified":1545049659804},{"_id":"source/docs/zh-cn/a8.primitive_data_types.md","hash":"30305ebe7287398654305451db20f230cf52ea45","modified":1545049659805},{"_id":"source/docs/zh-cn/a9.operators.md","hash":"12522be27f4d522ee96cfda556900ca02e6b98ad","modified":1545049659805},{"_id":"source/docs/zh-cn/b2.structs.md","hash":"cf526b9c92b58916f8bb9402bb3e09a2f027ded6","modified":1545049659806},{"_id":"source/docs/zh-cn/b4.generics.md","hash":"169ff9b1a0d44b9a53e7435163d4e5a41aeb5378","modified":1545049659806},{"_id":"source/docs/zh-cn/b1.vectors.md","hash":"501b1a01586ec2832730d851f3712a2f2c644fff","modified":1545049659806},{"_id":"source/docs/zh-cn/b3.enums.md","hash":"1fbb49355b7efdaf29140e3fbf178592eae60362","modified":1545049659806},{"_id":"source/docs/zh-cn/c2.borrowing.md","hash":"0e9c6ef9b0dbbc0ec7b21bf48857ec719748680a","modified":1545049659807},{"_id":"source/docs/zh-cn/b5.impls_and_traits.md","hash":"ca56634d1900c7acf0cb95547c99620594fe7dd2","modified":1545049659806},{"_id":"source/docs/zh-cn/c1.ownership.md","hash":"d07cd45fb444b328287c31f52e77a44894d43167","modified":1545049659806},{"_id":"source/docs/zh-cn/c3.lifetimes.md","hash":"201c598dd8a745bd7ec70080401eab323a730f83","modified":1545049659807},{"_id":"source/docs/zh-cn/d1.code_organization.md","hash":"244e1e3c0e860b9f37f6e5816811ffaf54efb33e","modified":1545049659807},{"_id":"source/docs/zh-cn/d2.functions.md","hash":"f7980784d321a7c82e5c439ff4b637c15841886e","modified":1545049659807},{"_id":"source/docs/zh-cn/d3.modules.md","hash":"09cb368ddd985465950df006dba5625b3f8d1b21","modified":1545049659807},{"_id":"source/docs/zh-cn/d5.workspaces.md","hash":"8b6ea3fd7457ede0f13c61a098314fa2350399a0","modified":1545049659808},{"_id":"source/docs/zh-cn/d4.crates.md","hash":"cec2915e8677b9eb9b848afb28d3742112ea72d7","modified":1545049659808},{"_id":"source/docs/zh-cn/d6.use.md","hash":"31a4e957de4a9b5536ec5d78d12f04edde6e386f","modified":1545049659808},{"_id":"source/docs/zh-cn/d7.std_primitives_and_preludes.md","hash":"8c5ef8f5c191f518dfcd7de1ac4682b12d47c272","modified":1545049659808},{"_id":"source/docs/zh-cn/index.md","hash":"b69b14f0bdc74a4d29983d7c14d4f6baa80f41ca","modified":1545049659809},{"_id":"themes/navy/layout/partial/after_footer.swig","hash":"0cdfcc5b1be944b906a59d25e84f55a35a179c28","modified":1537969649346},{"_id":"themes/navy/layout/partial/footer.swig","hash":"cc1e1abf229423a8cbc80a25f4e20755923a8473","modified":1537969649346},{"_id":"themes/navy/layout/partial/header.swig","hash":"a4f0754c77c945ee29a38200d7e5df018c7f05d6","modified":1537969649347},{"_id":"themes/navy/layout/partial/google_analytics.swig","hash":"44869c53540e7dfc6dfde2550e3bb94e0693c8a6","modified":1537969649347},{"_id":"themes/navy/layout/partial/head.swig","hash":"77b996547192a7cfaa009e6a38c191d814f1e07e","modified":1537969649347},{"_id":"themes/navy/layout/partial/mobile_nav.swig","hash":"78b20fe48e8de9e1ecc07399c9278ed4e0c404f9","modified":1537969649347},{"_id":"themes/navy/layout/partial/post.swig","hash":"27b0b027a12215a4b05eec31a4868448a5c7d16e","modified":1537969649348},{"_id":"themes/navy/layout/partial/share.swig","hash":"43087d425d24eb2c59ad850a68d4528f43f9842d","modified":1537969649348},{"_id":"themes/navy/layout/partial/sidebar.swig","hash":"6bb7120a1ab8eadf5089d16f63100ce7f36d7343","modified":1537969649348},{"_id":"themes/navy/source/css/_variables.styl","hash":"70a2675653277dd86d178b25c7ad50de0902583a","modified":1537969649351},{"_id":"themes/navy/source/css/navy.styl","hash":"82192ed1cf748fa515751b52c6c6240e22f32439","modified":1537969649352},{"_id":"themes/navy/source/js/lang_select.js","hash":"f3d61d478e8f7e6d9d661e5e83fdc4450a012e67","modified":1537969649352},{"_id":"themes/navy/source/js/mobile_nav.js","hash":"f4976aef22eb1e5e06b20c7735f7d3ef29b8956e","modified":1537969649352},{"_id":"themes/navy/source/js/toc.js","hash":"d95c8db8caddf36cada66acf03a2377d28e9c107","modified":1537969649353},{"_id":"themes/navy/source/css/_partial/base.styl","hash":"c4f8602ab539480b5b3c6ebaa8c368432ca5ca7b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/footer.styl","hash":"ba0a2262f0d5cf982ad1149be8f05331f492aaff","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/header.styl","hash":"b84db68c0c3cc37a9bedb7f82cf563e676dd495b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/highlight.styl","hash":"f03294c7392e0c371a5f7150fe7c4e436fd361fe","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/index.styl","hash":"bae9cbbde385ba4303e60c1f5e69464059478ad2","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/mobile_nav.styl","hash":"7fd521d9f54865a17af453ac94dcd6b4ae420ccb","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/sidebar.styl","hash":"bd44876a668ec1337d7b39be3f47e99bd95b3e3e","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/page.styl","hash":"7da422e27ecc807b881b880202ae76656f2a39c3","modified":1537969649351},{"_id":"source/docs/images/learning_rust_medium.jpg","hash":"b0a4541e7ffdaaf8d265f99dcff6227b339dd4d0","modified":1537969649340}],"Category":[],"Data":[{"_id":"languages","data":{"en":"English","zh-cn":"Chinese"}},{"_id":"sidebar","data":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}}},{"_id":"menu","data":{"docs":"/docs/a1.why_rust.html"}}],"Page":[{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n","source":"index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n","date":"2018-12-17T13:25:39.152Z","updated":"2018-12-17T13:25:39.152Z","path":"index.html","title":"","comments":1,"_id":"cjpt525dn0000umzaw6mgyp3c","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li></ul>"},{"title":"Why Rust?","_content":"\n## History of Rust\nRust initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good language for creating highly concurrent and highly safe systems. Also, Rust is designed to provide speed and safety at the same time.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It's a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on its backend. Also Rust is a **multi-paradigm programming language**, it supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and meta programming, in both static and dynamic styles.\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model : **C**\n* Data types : **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings : **Swift**\n* Hygienic Macros : **Scheme**\n* Functional Programming : **Haskell, OCaml, F\\#**\n* Attributes : **ECMA**-335\n* Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* Type Classes : **Haskell**\n* Crate : Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure : **Erlang**  \n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compiler time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C++\n","source":"docs/a1.why_rust.md","raw":"title: Why Rust?\n---\n\n## History of Rust\nRust initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good language for creating highly concurrent and highly safe systems. Also, Rust is designed to provide speed and safety at the same time.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It's a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on its backend. Also Rust is a **multi-paradigm programming language**, it supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and meta programming, in both static and dynamic styles.\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model : **C**\n* Data types : **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings : **Swift**\n* Hygienic Macros : **Scheme**\n* Functional Programming : **Haskell, OCaml, F\\#**\n* Attributes : **ECMA**-335\n* Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* Type Classes : **Haskell**\n* Crate : Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure : **Erlang**  \n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compiler time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C++\n","date":"2018-09-26T13:47:29.328Z","updated":"2018-09-26T13:47:29.328Z","path":"docs/a1.why_rust.html","comments":1,"layout":"page","_id":"cjpt525dx0001umza98rumhv0","content":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good language for creating highly concurrent and highly safe systems. Also, Rust is designed to provide speed and safety at the same time.</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It’s a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on its backend. Also Rust is a <strong>multi-paradigm programming language</strong>, it supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and meta programming, in both static and dynamic styles.</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model : <strong>C</strong></li>\n<li>Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings : <strong>Swift</strong></li>\n<li>Hygienic Macros : <strong>Scheme</strong></li>\n<li>Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes : <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes : <strong>Haskell</strong></li>\n<li>Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn’t use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compiler time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C++</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good language for creating highly concurrent and highly safe systems. Also, Rust is designed to provide speed and safety at the same time.</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It’s a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on its backend. Also Rust is a <strong>multi-paradigm programming language</strong>, it supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and meta programming, in both static and dynamic styles.</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model : <strong>C</strong></li>\n<li>Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings : <strong>Swift</strong></li>\n<li>Hygienic Macros : <strong>Scheme</strong></li>\n<li>Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes : <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes : <strong>Haskell</strong></li>\n<li>Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn’t use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compiler time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C++</p>\n"},{"title":"Control Flows","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be same on each block, when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/a10.control_flows.md","raw":"title: Control Flows\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be same on each block, when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2018-09-26T13:47:29.328Z","updated":"2018-09-26T13:47:29.328Z","path":"docs/a10.control_flows.html","comments":1,"layout":"page","_id":"cjpt525dy0002umzau3z8bgt5","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be same on each block, when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be same on each block, when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"Installation","_content":"\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n> ⭐️ If you are on **Microsoft Windows**, you have to install **Visual C++ Build Tools** 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\nAfter installing Rust you can check the current version by typing `rustc --version` or`rustc -V` on your terminal to verify the success of the installation.\n","source":"docs/a2.installation.md","raw":"title: Installation\n---\n\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n> ⭐️ If you are on **Microsoft Windows**, you have to install **Visual C++ Build Tools** 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\nAfter installing Rust you can check the current version by typing `rustc --version` or`rustc -V` on your terminal to verify the success of the installation.\n","date":"2018-09-26T13:47:29.329Z","updated":"2018-09-26T13:47:29.329Z","path":"docs/a2.installation.html","comments":1,"layout":"page","_id":"cjpt525dy0003umzakhlduq4x","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<blockquote>\n<p>⭐️ If you are on <strong>Microsoft Windows</strong>, you have to install <strong>Visual C++ Build Tools</strong> 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.</p>\n</blockquote>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<p>After installing Rust you can check the current version by typing <code>rustc --version</code> or<code>rustc -V</code> on your terminal to verify the success of the installation.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<blockquote>\n<p>⭐️ If you are on <strong>Microsoft Windows</strong>, you have to install <strong>Visual C++ Build Tools</strong> 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.</p>\n</blockquote>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<p>After installing Rust you can check the current version by typing <code>rustc --version</code> or<code>rustc -V</code> on your terminal to verify the success of the installation.</p>\n"},{"title":"Cargo, Crates and Basic Project Structure","_content":"\n## Cargo\n\nCargo is Rust’s built-in Package Manager. But mainly it uses for,\n\n- Create new project : `cargo new`\n- Update dependencies : `cargo update`\n- Build project : `cargo build`\n- Analyze project to see it has any errors, without building : `cargo check`\n- Build and run a project : `cargo run`  \n- Run tests : `cargo test`  \n- Generate documentation via rustdoc : `cargo doc`\n\nOther than that there are some cargo commands, especially for publishing crates directly via cargo.\n\n- `cargo login` : acquiring an API token  \n- `cargo package` : make the local create uploadable to crates.io  \n- `cargo publish` : make the local create uploadable to crates.io and upload the crate\n\n## Crate\n\n⭐️ **A crate is a package. Crates can be shared via [Cargo](https://crates.io/).**\n\n\nA crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  \n01.  `cargo new crate_name --bin` OR `cargo new crate_name`: produces an **executable**  \n02.  `cargo new crate_name --lib` : produces a **library**\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when build it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout) about the recommended Project Layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- Source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","source":"docs/a4.cargo,crates_and_basic_project_structure.md","raw":"title: Cargo, Crates and Basic Project Structure\n---\n\n## Cargo\n\nCargo is Rust’s built-in Package Manager. But mainly it uses for,\n\n- Create new project : `cargo new`\n- Update dependencies : `cargo update`\n- Build project : `cargo build`\n- Analyze project to see it has any errors, without building : `cargo check`\n- Build and run a project : `cargo run`  \n- Run tests : `cargo test`  \n- Generate documentation via rustdoc : `cargo doc`\n\nOther than that there are some cargo commands, especially for publishing crates directly via cargo.\n\n- `cargo login` : acquiring an API token  \n- `cargo package` : make the local create uploadable to crates.io  \n- `cargo publish` : make the local create uploadable to crates.io and upload the crate\n\n## Crate\n\n⭐️ **A crate is a package. Crates can be shared via [Cargo](https://crates.io/).**\n\n\nA crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  \n01.  `cargo new crate_name --bin` OR `cargo new crate_name`: produces an **executable**  \n02.  `cargo new crate_name --lib` : produces a **library**\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when build it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout) about the recommended Project Layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- Source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","date":"2018-09-26T13:47:29.329Z","updated":"2018-09-26T13:47:29.329Z","path":"docs/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjpt525dz0004umzafh1j20ce","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in Package Manager. But mainly it uses for,</p>\n<ul>\n<li>Create new project : <code>cargo new</code></li>\n<li>Update dependencies : <code>cargo update</code></li>\n<li>Build project : <code>cargo build</code></li>\n<li>Analyze project to see it has any errors, without building : <code>cargo check</code></li>\n<li>Build and run a project : <code>cargo run</code>  </li>\n<li>Run tests : <code>cargo test</code>  </li>\n<li>Generate documentation via rustdoc : <code>cargo doc</code></li>\n</ul>\n<p>Other than that there are some cargo commands, especially for publishing crates directly via cargo.</p>\n<ul>\n<li><code>cargo login</code> : acquiring an API token  </li>\n<li><code>cargo package</code> : make the local create uploadable to crates.io  </li>\n<li><code>cargo publish</code> : make the local create uploadable to crates.io and upload the crate</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>A crate is a package. Crates can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>.</strong></p>\n<p>A crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  </p>\n<ol>\n<li><code>cargo new crate_name --bin</code> OR <code>cargo new crate_name</code>: produces an <strong>executable</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : produces a <strong>library</strong></li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when build it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended Project Layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>Source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in Package Manager. But mainly it uses for,</p>\n<ul>\n<li>Create new project : <code>cargo new</code></li>\n<li>Update dependencies : <code>cargo update</code></li>\n<li>Build project : <code>cargo build</code></li>\n<li>Analyze project to see it has any errors, without building : <code>cargo check</code></li>\n<li>Build and run a project : <code>cargo run</code>  </li>\n<li>Run tests : <code>cargo test</code>  </li>\n<li>Generate documentation via rustdoc : <code>cargo doc</code></li>\n</ul>\n<p>Other than that there are some cargo commands, especially for publishing crates directly via cargo.</p>\n<ul>\n<li><code>cargo login</code> : acquiring an API token  </li>\n<li><code>cargo package</code> : make the local create uploadable to crates.io  </li>\n<li><code>cargo publish</code> : make the local create uploadable to crates.io and upload the crate</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>A crate is a package. Crates can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>.</strong></p>\n<p>A crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  </p>\n<ol>\n<li><code>cargo new crate_name --bin</code> OR <code>cargo new crate_name</code>: produces an <strong>executable</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : produces a <strong>library</strong></li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when build it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended Project Layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>Source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. main function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicate that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) instead of a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compiling via `rustc file.rs`\n- Executing by `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of println! macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. main function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicate that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) instead of a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compiling via `rustc file.rs`\n- Executing by `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of println! macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2018-09-26T13:47:29.329Z","updated":"2018-09-26T13:47:29.329Z","path":"docs/a3.hello_world.html","comments":1,"layout":"page","_id":"cjpt525e00005umzav3fjl4ef","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. main function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicate that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> instead of a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compiling via <code>rustc file.rs</code></li>\n<li>Executing by <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of println! macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. main function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicate that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> instead of a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compiling via <code>rustc file.rs</code></li>\n<li>Executing by <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of println! macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"Comments and Documenting the code","_content":"\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **Always avoid block comments, Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nAlso we can use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.\n\nIn here each comments are equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/a5.comments_and_documenting_the_code.md","raw":"title: Comments and Documenting the code\n---\n\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **Always avoid block comments, Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nAlso we can use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.\n\nIn here each comments are equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2018-09-26T13:47:29.329Z","updated":"2018-09-26T13:47:29.329Z","path":"docs/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjpt525e00006umzag9e569k7","content":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>Always avoid block comments, Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>Also we can use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>In here each comments are equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>Always avoid block comments, Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>Also we can use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>In here each comments are equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"Variable bindings , Constants & Statics","_content":"\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; It checks data type at compile time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. **static** is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually statics are placed at top of the code file, outside the functions.\n","source":"docs/a6.variable_bindings,constants_and_statics.md","raw":"title: Variable bindings , Constants & Statics\n---\n\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; It checks data type at compile time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. **static** is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually statics are placed at top of the code file, outside the functions.\n","date":"2018-09-26T13:47:29.329Z","updated":"2018-09-26T13:47:29.329Z","path":"docs/a6.variable_bindings,constants_and_statics.html","comments":1,"layout":"page","_id":"cjpt525e10007umza9505vlrv","content":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; It checks data type at compile time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. <strong>static</strong> is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually statics are placed at top of the code file, outside the functions.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; It checks data type at compile time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. <strong>static</strong> is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually statics are placed at top of the code file, outside the functions.</p>\n"},{"title":"Functions","_content":"\n* Functions are declared with the keyword `fn`\n* When using **arguments**, you **must declare data types**.\n* By default functions **return empty tuple ()**. If you want to return a value, **return type must be specified** after **->**\n\n### Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### Returning Values\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it's last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n```\n","source":"docs/a7.functions.md","raw":"title: Functions\n---\n\n* Functions are declared with the keyword `fn`\n* When using **arguments**, you **must declare data types**.\n* By default functions **return empty tuple ()**. If you want to return a value, **return type must be specified** after **->**\n\n### Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### Returning Values\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it's last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n```\n","date":"2018-09-26T13:47:29.330Z","updated":"2018-09-26T13:47:29.330Z","path":"docs/a7.functions.html","comments":1,"layout":"page","_id":"cjpt525e20008umza2t1deyb1","content":"<ul>\n<li>Functions are declared with the keyword <code>fn</code></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default functions <strong>return empty tuple ()</strong>. If you want to return a value, <strong>return type must be specified</strong> after <strong>-&gt;</strong></li>\n</ul>\n<h3 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"Passing-arguments\"><a href=\"#Passing-arguments\" class=\"headerlink\" title=\"Passing arguments\"></a>Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"Returning-Values\"><a href=\"#Returning-Values\" class=\"headerlink\" title=\"Returning Values\"></a>Returning Values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it&#39;s last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul>\n<li>Functions are declared with the keyword <code>fn</code></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default functions <strong>return empty tuple ()</strong>. If you want to return a value, <strong>return type must be specified</strong> after <strong>-&gt;</strong></li>\n</ul>\n<h3 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"Passing-arguments\"><a href=\"#Passing-arguments\" class=\"headerlink\" title=\"Passing arguments\"></a>Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"Returning-Values\"><a href=\"#Returning-Values\" class=\"headerlink\" title=\"Returning Values\"></a>Returning Values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it&#39;s last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n//because of Unicode support, char is not a single byte, but four.\n```\n\n\n- ## i8, i16, i32, i64, i128\nFixed size(bit) signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **-2ⁿ⁻¹ to 2ⁿ⁻¹-1** . You can use **min_value()** and **max_value()** to find min and max of each integer type, ex. i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nFixed size(bit) unsigned(+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **0 to 2ⁿ-1** . Same way you can use **min_value()** and **max_value()** to find min and max of each integer type, ex. u8::max_value();\n\n\n- ## isize\nVariable sized signed(+/-) integer\n\nSimply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .\n\n\n- ## usize\nVariable sized unsigned(+) integer\n\nSimply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.\n\n\n- ## f32\n32-bit floating point\n\nSimilar to float in other languages, **Single precision**.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## f64\n64-bit floating point\n\nSimilar to double in other languages, **Double precision**.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and also **even with mut, its element count can not be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **&str** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, b is a function pointer, to plus_one function\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/a8.primitive_data_types.md","raw":"title: Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n//because of Unicode support, char is not a single byte, but four.\n```\n\n\n- ## i8, i16, i32, i64, i128\nFixed size(bit) signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **-2ⁿ⁻¹ to 2ⁿ⁻¹-1** . You can use **min_value()** and **max_value()** to find min and max of each integer type, ex. i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nFixed size(bit) unsigned(+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **0 to 2ⁿ-1** . Same way you can use **min_value()** and **max_value()** to find min and max of each integer type, ex. u8::max_value();\n\n\n- ## isize\nVariable sized signed(+/-) integer\n\nSimply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .\n\n\n- ## usize\nVariable sized unsigned(+) integer\n\nSimply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.\n\n\n- ## f32\n32-bit floating point\n\nSimilar to float in other languages, **Single precision**.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## f64\n64-bit floating point\n\nSimilar to double in other languages, **Double precision**.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and also **even with mut, its element count can not be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **&str** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, b is a function pointer, to plus_one function\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2018-09-26T13:47:29.330Z","updated":"2018-09-26T13:47:29.330Z","path":"docs/a8.primitive_data_types.html","comments":1,"layout":"page","_id":"cjpt525e20009umza6nep51ai","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n//because of Unicode support, char is not a single byte, but four.\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Fixed size(bit) signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>-2ⁿ⁻¹ to 2ⁿ⁻¹-1</strong> . You can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Fixed size(bit) unsigned(+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>0 to 2ⁿ-1</strong> . Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize\"><a href=\"#isize\" class=\"headerlink\" title=\"isize\"></a>isize</h2>Variable sized signed(+/-) integer</li>\n</ul>\n<p>Simply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .</p>\n<ul>\n<li><h2 id=\"usize\"><a href=\"#usize\" class=\"headerlink\" title=\"usize\"></a>usize</h2>Variable sized unsigned(+) integer</li>\n</ul>\n<p>Simply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.</p>\n<ul>\n<li><h2 id=\"f32\"><a href=\"#f32\" class=\"headerlink\" title=\"f32\"></a>f32</h2>32-bit floating point</li>\n</ul>\n<p>Similar to float in other languages, <strong>Single precision</strong>.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"f64\"><a href=\"#f64\" class=\"headerlink\" title=\"f64\"></a>f64</h2>64-bit floating point</li>\n</ul>\n<p>Similar to double in other languages, <strong>Double precision</strong>.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and also <strong>even with mut, its element count can not be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong>&amp;str</strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, b is a function pointer, to plus_one function</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n//because of Unicode support, char is not a single byte, but four.\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Fixed size(bit) signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>-2ⁿ⁻¹ to 2ⁿ⁻¹-1</strong> . You can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Fixed size(bit) unsigned(+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>0 to 2ⁿ-1</strong> . Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize\"><a href=\"#isize\" class=\"headerlink\" title=\"isize\"></a>isize</h2>Variable sized signed(+/-) integer</li>\n</ul>\n<p>Simply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .</p>\n<ul>\n<li><h2 id=\"usize\"><a href=\"#usize\" class=\"headerlink\" title=\"usize\"></a>usize</h2>Variable sized unsigned(+) integer</li>\n</ul>\n<p>Simply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.</p>\n<ul>\n<li><h2 id=\"f32\"><a href=\"#f32\" class=\"headerlink\" title=\"f32\"></a>f32</h2>32-bit floating point</li>\n</ul>\n<p>Similar to float in other languages, <strong>Single precision</strong>.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"f64\"><a href=\"#f64\" class=\"headerlink\" title=\"f64\"></a>f64</h2>64-bit floating point</li>\n</ul>\n<p>Similar to double in other languages, <strong>Double precision</strong>.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and also <strong>even with mut, its element count can not be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong>&amp;str</strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, b is a function pointer, to plus_one function</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Operators","_content":"\n## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**\n\n\n## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)\nlet g = a >> a; //0  (remove 2 positions from the end -> o̶1̶ -> 0)\n```\n\n\n## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","source":"docs/a9.operators.md","raw":"title: Operators\n---\n\n## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**\n\n\n## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)\nlet g = a >> a; //0  (remove 2 positions from the end -> o̶1̶ -> 0)\n```\n\n\n## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","date":"2018-09-26T13:47:29.330Z","updated":"2018-09-26T13:47:29.330Z","path":"docs/a9.operators.html","comments":1,"layout":"page","_id":"cjpt525e3000aumza7kqtbnju","content":"<h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong></p>\n</blockquote>\n<h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (add 2 positions to the end -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (remove 2 positions from the end -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2><p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2><p>&amp; &amp;mut *</p>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong></p>\n</blockquote>\n<h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (add 2 positions to the end -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (remove 2 positions from the end -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2><p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2><p>&amp; &amp;mut *</p>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n"},{"title":"Vectors","_content":"\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2018-09-26T13:47:29.331Z","updated":"2018-09-26T13:47:29.331Z","path":"docs/b1.vectors.html","comments":1,"layout":"page","_id":"cjpt525e4000bumzad0toz0p4","content":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Structs","_content":"\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/b2.structs.md","raw":"title: Structs\n---\n\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2018-09-26T13:47:29.331Z","updated":"2018-09-26T13:47:29.331Z","path":"docs/b2.structs.html","comments":1,"layout":"page","_id":"cjpt525e5000cumzaeyjwgd5y","content":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/b3.enums.md","raw":"title: Enums\n---\n\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2018-09-26T13:47:29.331Z","updated":"2018-09-26T13:47:29.331Z","path":"docs/b3.enums.html","comments":1,"layout":"page","_id":"cjpt525e6000dumzaciw7xxar","content":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/b4.generics.md","raw":"title: Generics\n---\n\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2018-09-26T13:47:29.332Z","updated":"2018-09-26T13:47:29.332Z","path":"docs/b4.generics.html","comments":1,"layout":"page","_id":"cjpt525e6000eumza1i64zxli","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Impls & Traits","_content":"\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2018-09-26T13:47:29.332Z","updated":"2018-09-26T13:47:29.332Z","path":"docs/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjpt525e7000fumzadz97hzvk","content":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","source":"docs/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","date":"2018-09-26T13:47:29.332Z","updated":"2018-09-26T13:47:29.332Z","path":"docs/c1.ownership.html","comments":1,"layout":"page","_id":"cjpt525e8000gumza77hb4g7y","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2018-09-26T13:47:29.332Z","updated":"2018-09-26T13:47:29.332Z","path":"docs/c2.borrowing.html","comments":1,"layout":"page","_id":"cjpt525e8000humza9wcbnr77","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2018-09-26T13:47:29.333Z","updated":"2018-09-26T13:47:29.333Z","path":"docs/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjpt525e9000iumzaqpdx41zy","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","source":"docs/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","date":"2018-09-26T13:47:29.333Z","updated":"2018-09-26T13:47:29.333Z","path":"docs/d1.code_organization.html","comments":1,"layout":"page","_id":"cjpt525e9000jumzacm9yc4db","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2018-09-26T13:47:29.333Z","updated":"2018-09-26T13:47:29.333Z","path":"docs/d2.functions.html","comments":1,"layout":"page","_id":"cjpt525ea000kumzaqdlks8nj","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2018-09-26T13:47:29.333Z","updated":"2018-09-26T13:47:29.333Z","path":"docs/d3.modules.html","comments":1,"layout":"page","_id":"cjpt525ea000lumzax3iuqt7p","content":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2018-09-26T13:47:29.334Z","updated":"2018-09-26T13:47:29.334Z","path":"docs/d5.workspaces.html","comments":1,"layout":"page","_id":"cjpt525eb000mumzahv7uhe6q","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Crate","_content":"\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/d4.crates.md","raw":"title: Crate\n---\n\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","date":"2018-09-26T13:47:29.334Z","updated":"2018-09-26T13:47:29.334Z","path":"docs/d4.crates.html","comments":1,"layout":"page","_id":"cjpt525ec000numzacsdsd450","content":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"},{"title":"Use","_content":"\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","source":"docs/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","date":"2018-09-26T13:47:29.334Z","updated":"2018-09-26T13:47:29.334Z","path":"docs/d6.use.html","comments":1,"layout":"page","_id":"cjpt525ec000oumzalulqtlck","content":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2018-09-26T13:47:29.335Z","updated":"2018-09-26T13:47:29.335Z","path":"docs/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjpt525ed000pumza84thcv8d","content":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2018-09-26T13:47:29.341Z","updated":"2018-09-26T13:47:29.341Z","path":"docs/index.html","comments":1,"layout":"page","_id":"cjpt525ee000qumzaa33pyhgl","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"},{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","lang":"zh-cn","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') 基础知识\n      p.intro-feature-desc 如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') 基础之上\n      p.intro-feature-desc Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') 难啃的部分\n      p.intro-feature-desc 所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') 开始你的项目\n      p.intro-feature-desc 模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。\n","source":"zh-cn/index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\nlang: zh-cn\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') 基础知识\n      p.intro-feature-desc 如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') 基础之上\n      p.intro-feature-desc Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') 难啃的部分\n      p.intro-feature-desc 所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') 开始你的项目\n      p.intro-feature-desc 模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。\n","date":"2018-12-17T13:25:42.641Z","updated":"2018-12-17T13:25:42.641Z","path":"zh-cn/index.html","title":"","comments":1,"_id":"cjpt525fq000rumzatlhjk5av","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">基础知识</a></h3><p class=\"intro-feature-desc\">如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">基础之上</a></h3><p class=\"intro-feature-desc\">Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">难啃的部分</a></h3><p class=\"intro-feature-desc\">所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">开始你的项目</a></h3><p class=\"intro-feature-desc\">模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">基础知识</a></h3><p class=\"intro-feature-desc\">如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">基础之上</a></h3><p class=\"intro-feature-desc\">Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">难啃的部分</a></h3><p class=\"intro-feature-desc\">所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">开始你的项目</a></h3><p class=\"intro-feature-desc\">模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。</p></div></li></ul>"},{"title":"Control Flows","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be same on each block, when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/zh-cn/a10.control_flows.md","raw":"title: Control Flows\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be same on each block, when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2018-12-17T12:27:39.803Z","updated":"2018-12-17T12:27:39.803Z","path":"docs/zh-cn/a10.control_flows.html","comments":1,"layout":"page","_id":"cjpt525fy000sumzaqtv3qc7y","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be same on each block, when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be same on each block, when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"为什么会有Rust?","_content":"\n## Rust的历史\nRust最初由Mozilla的员工**Graydon Hoare**作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。\n\n## Rust愿景\nRust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust是一个年轻又现代的编程语言。它是一种**预编译语言**并使用[LLVM](https://en.wikipedia.org/wiki/LLVM)作为后盾。同时，Rust是一个**多范式编程语言**， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## 灵感来源\nRust在设计的过程中，从很多语言汲取了诸多灵感：\n\n* 抽象机器模型 - Abstract Machine Model : **C**\n* 数据类型 - Data types : **C, SML, OCaml, Lisp, Limbo**\n* 可选绑定 - Optional Bindings : **Swift**\n* 洁净宏 - Hygienic Macros : **Scheme**\n* 函数式编程 - Functional Programming : **Haskell, OCaml, F\\#**\n* 属性标签 - Attributes : **ECMA**-335\n* 内存模型与内存管理 - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* 类型模板 - Type Classes : **Haskell**\n* 代码箱 - Crate : Assembly in the **ECMA**-335 CLI model\n* 通道与并发 - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* 消息传递与线程失败处理 - Message passing and Thread failure : **Erlang**  \n\n以及其他。\n\n\nRust默认情况下**并不使用自动垃圾回收机制（GC)**。\n\nRust编译器在**编译阶段**会对代码做大量检查以尽量防止在C++代码中较为常见的[**可能的类型错误**](https://doc.rust-lang.org/error-index.html) 。\n","source":"docs/zh-cn/a1.why_rust.md","raw":"title: 为什么会有Rust?\n---\n\n## Rust的历史\nRust最初由Mozilla的员工**Graydon Hoare**作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。\n\n## Rust愿景\nRust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust是一个年轻又现代的编程语言。它是一种**预编译语言**并使用[LLVM](https://en.wikipedia.org/wiki/LLVM)作为后盾。同时，Rust是一个**多范式编程语言**， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## 灵感来源\nRust在设计的过程中，从很多语言汲取了诸多灵感：\n\n* 抽象机器模型 - Abstract Machine Model : **C**\n* 数据类型 - Data types : **C, SML, OCaml, Lisp, Limbo**\n* 可选绑定 - Optional Bindings : **Swift**\n* 洁净宏 - Hygienic Macros : **Scheme**\n* 函数式编程 - Functional Programming : **Haskell, OCaml, F\\#**\n* 属性标签 - Attributes : **ECMA**-335\n* 内存模型与内存管理 - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* 类型模板 - Type Classes : **Haskell**\n* 代码箱 - Crate : Assembly in the **ECMA**-335 CLI model\n* 通道与并发 - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* 消息传递与线程失败处理 - Message passing and Thread failure : **Erlang**  \n\n以及其他。\n\n\nRust默认情况下**并不使用自动垃圾回收机制（GC)**。\n\nRust编译器在**编译阶段**会对代码做大量检查以尽量防止在C++代码中较为常见的[**可能的类型错误**](https://doc.rust-lang.org/error-index.html) 。\n","date":"2018-12-17T12:53:35.069Z","updated":"2018-12-17T12:53:35.069Z","path":"docs/zh-cn/a1.why_rust.html","comments":1,"layout":"page","_id":"cjpt525fy000tumzab943izm1","content":"<h2 id=\"Rust的历史\"><a href=\"#Rust的历史\" class=\"headerlink\" title=\"Rust的历史\"></a>Rust的历史</h2><p>Rust最初由Mozilla的员工<strong>Graydon Hoare</strong>作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。</p>\n<h2 id=\"Rust愿景\"><a href=\"#Rust愿景\" class=\"headerlink\" title=\"Rust愿景\"></a>Rust愿景</h2><p>Rust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust是一个年轻又现代的编程语言。它是一种<strong>预编译语言</strong>并使用<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>作为后盾。同时，Rust是一个<strong>多范式编程语言</strong>， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"灵感来源\"><a href=\"#灵感来源\" class=\"headerlink\" title=\"灵感来源\"></a>灵感来源</h2><p>Rust在设计的过程中，从很多语言汲取了诸多灵感：</p>\n<ul>\n<li>抽象机器模型 - Abstract Machine Model : <strong>C</strong></li>\n<li>数据类型 - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>可选绑定 - Optional Bindings : <strong>Swift</strong></li>\n<li>洁净宏 - Hygienic Macros : <strong>Scheme</strong></li>\n<li>函数式编程 - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>属性标签 - Attributes : <strong>ECMA</strong>-335</li>\n<li>内存模型与内存管理 - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>类型模板 - Type Classes : <strong>Haskell</strong></li>\n<li>代码箱 - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>通道与并发 - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>消息传递与线程失败处理 - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>以及其他。</p>\n<p>Rust默认情况下<strong>并不使用自动垃圾回收机制（GC)</strong>。</p>\n<p>Rust编译器在<strong>编译阶段</strong>会对代码做大量检查以尽量防止在C++代码中较为常见的<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>可能的类型错误</strong></a> 。</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Rust的历史\"><a href=\"#Rust的历史\" class=\"headerlink\" title=\"Rust的历史\"></a>Rust的历史</h2><p>Rust最初由Mozilla的员工<strong>Graydon Hoare</strong>作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。</p>\n<h2 id=\"Rust愿景\"><a href=\"#Rust愿景\" class=\"headerlink\" title=\"Rust愿景\"></a>Rust愿景</h2><p>Rust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust是一个年轻又现代的编程语言。它是一种<strong>预编译语言</strong>并使用<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>作为后盾。同时，Rust是一个<strong>多范式编程语言</strong>， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"灵感来源\"><a href=\"#灵感来源\" class=\"headerlink\" title=\"灵感来源\"></a>灵感来源</h2><p>Rust在设计的过程中，从很多语言汲取了诸多灵感：</p>\n<ul>\n<li>抽象机器模型 - Abstract Machine Model : <strong>C</strong></li>\n<li>数据类型 - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>可选绑定 - Optional Bindings : <strong>Swift</strong></li>\n<li>洁净宏 - Hygienic Macros : <strong>Scheme</strong></li>\n<li>函数式编程 - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>属性标签 - Attributes : <strong>ECMA</strong>-335</li>\n<li>内存模型与内存管理 - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>类型模板 - Type Classes : <strong>Haskell</strong></li>\n<li>代码箱 - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>通道与并发 - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>消息传递与线程失败处理 - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>以及其他。</p>\n<p>Rust默认情况下<strong>并不使用自动垃圾回收机制（GC)</strong>。</p>\n<p>Rust编译器在<strong>编译阶段</strong>会对代码做大量检查以尽量防止在C++代码中较为常见的<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>可能的类型错误</strong></a> 。</p>\n"},{"title":"Installation","_content":"\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n> ⭐️ If you are on **Microsoft Windows**, you have to install **Visual C++ Build Tools** 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\nAfter installing Rust you can check the current version by typing `rustc --version` or`rustc -V` on your terminal to verify the success of the installation.\n","source":"docs/zh-cn/a2.installation.md","raw":"title: Installation\n---\n\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n> ⭐️ If you are on **Microsoft Windows**, you have to install **Visual C++ Build Tools** 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\nAfter installing Rust you can check the current version by typing `rustc --version` or`rustc -V` on your terminal to verify the success of the installation.\n","date":"2018-12-17T12:27:39.803Z","updated":"2018-12-17T12:27:39.803Z","path":"docs/zh-cn/a2.installation.html","comments":1,"layout":"page","_id":"cjpt525fz000uumzaileiu44d","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<blockquote>\n<p>⭐️ If you are on <strong>Microsoft Windows</strong>, you have to install <strong>Visual C++ Build Tools</strong> 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.</p>\n</blockquote>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<p>After installing Rust you can check the current version by typing <code>rustc --version</code> or<code>rustc -V</code> on your terminal to verify the success of the installation.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<blockquote>\n<p>⭐️ If you are on <strong>Microsoft Windows</strong>, you have to install <strong>Visual C++ Build Tools</strong> 2013 or higher. The recommended way is installing Visual C++ 2015 Build Tools which requires additional 3–4 GBs.</p>\n</blockquote>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<p>After installing Rust you can check the current version by typing <code>rustc --version</code> or<code>rustc -V</code> on your terminal to verify the success of the installation.</p>\n"},{"title":"Comments and Documenting the code","_content":"\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **Always avoid block comments, Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nAlso we can use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.\n\nIn here each comments are equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/zh-cn/a5.comments_and_documenting_the_code.md","raw":"title: Comments and Documenting the code\n---\n\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **Always avoid block comments, Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nAlso we can use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.\n\nIn here each comments are equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2018-12-17T12:27:39.804Z","updated":"2018-12-17T12:27:39.804Z","path":"docs/zh-cn/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjpt525fz000vumzaog1gel5n","content":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>Always avoid block comments, Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>Also we can use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>In here each comments are equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>Always avoid block comments, Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. First comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using mod blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>Also we can use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>In here each comments are equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"Cargo, Crates and Basic Project Structure","_content":"\n## Cargo\n\nCargo is Rust’s built-in Package Manager. But mainly it uses for,\n\n- Create new project : `cargo new`\n- Update dependencies : `cargo update`\n- Build project : `cargo build`\n- Analyze project to see it has any errors, without building : `cargo check`\n- Build and run a project : `cargo run`  \n- Run tests : `cargo test`  \n- Generate documentation via rustdoc : `cargo doc`\n\nOther than that there are some cargo commands, especially for publishing crates directly via cargo.\n\n- `cargo login` : acquiring an API token  \n- `cargo package` : make the local create uploadable to crates.io  \n- `cargo publish` : make the local create uploadable to crates.io and upload the crate\n\n## Crate\n\n⭐️ **A crate is a package. Crates can be shared via [Cargo](https://crates.io/).**\n\n\nA crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  \n01.  `cargo new crate_name --bin` OR `cargo new crate_name`: produces an **executable**  \n02.  `cargo new crate_name --lib` : produces a **library**\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when build it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout) about the recommended Project Layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- Source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","source":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","raw":"title: Cargo, Crates and Basic Project Structure\n---\n\n## Cargo\n\nCargo is Rust’s built-in Package Manager. But mainly it uses for,\n\n- Create new project : `cargo new`\n- Update dependencies : `cargo update`\n- Build project : `cargo build`\n- Analyze project to see it has any errors, without building : `cargo check`\n- Build and run a project : `cargo run`  \n- Run tests : `cargo test`  \n- Generate documentation via rustdoc : `cargo doc`\n\nOther than that there are some cargo commands, especially for publishing crates directly via cargo.\n\n- `cargo login` : acquiring an API token  \n- `cargo package` : make the local create uploadable to crates.io  \n- `cargo publish` : make the local create uploadable to crates.io and upload the crate\n\n## Crate\n\n⭐️ **A crate is a package. Crates can be shared via [Cargo](https://crates.io/).**\n\n\nA crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  \n01.  `cargo new crate_name --bin` OR `cargo new crate_name`: produces an **executable**  \n02.  `cargo new crate_name --lib` : produces a **library**\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when build it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout) about the recommended Project Layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- Source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","date":"2018-12-17T12:27:39.804Z","updated":"2018-12-17T12:27:39.804Z","path":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjpt525g0000wumzamlqkt37g","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in Package Manager. But mainly it uses for,</p>\n<ul>\n<li>Create new project : <code>cargo new</code></li>\n<li>Update dependencies : <code>cargo update</code></li>\n<li>Build project : <code>cargo build</code></li>\n<li>Analyze project to see it has any errors, without building : <code>cargo check</code></li>\n<li>Build and run a project : <code>cargo run</code>  </li>\n<li>Run tests : <code>cargo test</code>  </li>\n<li>Generate documentation via rustdoc : <code>cargo doc</code></li>\n</ul>\n<p>Other than that there are some cargo commands, especially for publishing crates directly via cargo.</p>\n<ul>\n<li><code>cargo login</code> : acquiring an API token  </li>\n<li><code>cargo package</code> : make the local create uploadable to crates.io  </li>\n<li><code>cargo publish</code> : make the local create uploadable to crates.io and upload the crate</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>A crate is a package. Crates can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>.</strong></p>\n<p>A crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  </p>\n<ol>\n<li><code>cargo new crate_name --bin</code> OR <code>cargo new crate_name</code>: produces an <strong>executable</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : produces a <strong>library</strong></li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when build it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended Project Layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>Source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in Package Manager. But mainly it uses for,</p>\n<ul>\n<li>Create new project : <code>cargo new</code></li>\n<li>Update dependencies : <code>cargo update</code></li>\n<li>Build project : <code>cargo build</code></li>\n<li>Analyze project to see it has any errors, without building : <code>cargo check</code></li>\n<li>Build and run a project : <code>cargo run</code>  </li>\n<li>Run tests : <code>cargo test</code>  </li>\n<li>Generate documentation via rustdoc : <code>cargo doc</code></li>\n</ul>\n<p>Other than that there are some cargo commands, especially for publishing crates directly via cargo.</p>\n<ul>\n<li><code>cargo login</code> : acquiring an API token  </li>\n<li><code>cargo package</code> : make the local create uploadable to crates.io  </li>\n<li><code>cargo publish</code> : make the local create uploadable to crates.io and upload the crate</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>A crate is a package. Crates can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>.</strong></p>\n<p>A crate can produce an executable or a library. In other words, it can be a binary crate or a library crate.  </p>\n<ol>\n<li><code>cargo new crate_name --bin</code> OR <code>cargo new crate_name</code>: produces an <strong>executable</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : produces a <strong>library</strong></li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when build it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended Project Layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>Source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. main function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicate that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) instead of a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compiling via `rustc file.rs`\n- Executing by `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of println! macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/zh-cn/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. main function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicate that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) instead of a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compiling via `rustc file.rs`\n- Executing by `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of println! macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2018-12-17T12:27:39.803Z","updated":"2018-12-17T12:27:39.803Z","path":"docs/zh-cn/a3.hello_world.html","comments":1,"layout":"page","_id":"cjpt525g0000xumzaiu3nrpcs","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. main function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicate that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> instead of a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compiling via <code>rustc file.rs</code></li>\n<li>Executing by <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of println! macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. main function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicate that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> instead of a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compiling via <code>rustc file.rs</code></li>\n<li>Executing by <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of println! macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! macro is used to store the formatted STRING\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"Variable bindings , Constants & Statics","_content":"\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; It checks data type at compile time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. **static** is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually statics are placed at top of the code file, outside the functions.\n","source":"docs/zh-cn/a6.variable_bindings,constants_and_statics.md","raw":"title: Variable bindings , Constants & Statics\n---\n\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; It checks data type at compile time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. **static** is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually statics are placed at top of the code file, outside the functions.\n","date":"2018-12-17T12:27:39.804Z","updated":"2018-12-17T12:27:39.804Z","path":"docs/zh-cn/a6.variable_bindings,constants_and_statics.html","comments":1,"layout":"page","_id":"cjpt525g1000yumzamia267hs","content":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; It checks data type at compile time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. <strong>static</strong> is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually statics are placed at top of the code file, outside the functions.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; It checks data type at compile time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but have no fixed address in memory. <strong>static</strong> is used to define ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually statics are placed at top of the code file, outside the functions.</p>\n"},{"title":"Functions","_content":"\n* Functions are declared with the keyword `fn`\n* When using **arguments**, you **must declare data types**.\n* By default functions **return empty tuple ()**. If you want to return a value, **return type must be specified** after **->**\n\n### Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### Returning Values\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it's last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a7.functions.md","raw":"title: Functions\n---\n\n* Functions are declared with the keyword `fn`\n* When using **arguments**, you **must declare data types**.\n* By default functions **return empty tuple ()**. If you want to return a value, **return type must be specified** after **->**\n\n### Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### Returning Values\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it's last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n```\n","date":"2018-12-17T12:27:39.804Z","updated":"2018-12-17T12:27:39.804Z","path":"docs/zh-cn/a7.functions.html","comments":1,"layout":"page","_id":"cjpt525g2000zumzafuwt2jfn","content":"<ul>\n<li>Functions are declared with the keyword <code>fn</code></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default functions <strong>return empty tuple ()</strong>. If you want to return a value, <strong>return type must be specified</strong> after <strong>-&gt;</strong></li>\n</ul>\n<h3 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"Passing-arguments\"><a href=\"#Passing-arguments\" class=\"headerlink\" title=\"Passing arguments\"></a>Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"Returning-Values\"><a href=\"#Returning-Values\" class=\"headerlink\" title=\"Returning Values\"></a>Returning Values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it&#39;s last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul>\n<li>Functions are declared with the keyword <code>fn</code></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default functions <strong>return empty tuple ()</strong>. If you want to return a value, <strong>return type must be specified</strong> after <strong>-&gt;</strong></li>\n</ul>\n<h3 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"Passing-arguments\"><a href=\"#Passing-arguments\" class=\"headerlink\" title=\"Passing arguments\"></a>Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"Returning-Values\"><a href=\"#Returning-Values\" class=\"headerlink\" title=\"Returning Values\"></a>Returning Values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; //return a+2 but bad practice,\n    //should use only on conditional returnes, except it&#39;s last expression\n}\n\n// ⭐️ Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; //same, with type inference\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n//because of Unicode support, char is not a single byte, but four.\n```\n\n\n- ## i8, i16, i32, i64, i128\nFixed size(bit) signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **-2ⁿ⁻¹ to 2ⁿ⁻¹-1** . You can use **min_value()** and **max_value()** to find min and max of each integer type, ex. i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nFixed size(bit) unsigned(+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **0 to 2ⁿ-1** . Same way you can use **min_value()** and **max_value()** to find min and max of each integer type, ex. u8::max_value();\n\n\n- ## isize\nVariable sized signed(+/-) integer\n\nSimply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .\n\n\n- ## usize\nVariable sized unsigned(+) integer\n\nSimply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.\n\n\n- ## f32\n32-bit floating point\n\nSimilar to float in other languages, **Single precision**.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## f64\n64-bit floating point\n\nSimilar to double in other languages, **Double precision**.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and also **even with mut, its element count can not be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **&str** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, b is a function pointer, to plus_one function\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a8.primitive_data_types.md","raw":"title: Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n//because of Unicode support, char is not a single byte, but four.\n```\n\n\n- ## i8, i16, i32, i64, i128\nFixed size(bit) signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **-2ⁿ⁻¹ to 2ⁿ⁻¹-1** . You can use **min_value()** and **max_value()** to find min and max of each integer type, ex. i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\nFixed size(bit) unsigned(+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From **0 to 2ⁿ-1** . Same way you can use **min_value()** and **max_value()** to find min and max of each integer type, ex. u8::max_value();\n\n\n- ## isize\nVariable sized signed(+/-) integer\n\nSimply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .\n\n\n- ## usize\nVariable sized unsigned(+) integer\n\nSimply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.\n\n\n- ## f32\n32-bit floating point\n\nSimilar to float in other languages, **Single precision**.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## f64\n64-bit floating point\n\nSimilar to double in other languages, **Double precision**.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and also **even with mut, its element count can not be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **&str** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, b is a function pointer, to plus_one function\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2018-12-17T12:27:39.805Z","updated":"2018-12-17T12:27:39.805Z","path":"docs/zh-cn/a8.primitive_data_types.html","comments":1,"layout":"page","_id":"cjpt525g30010umza04lfvl6g","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n//because of Unicode support, char is not a single byte, but four.\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Fixed size(bit) signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>-2ⁿ⁻¹ to 2ⁿ⁻¹-1</strong> . You can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Fixed size(bit) unsigned(+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>0 to 2ⁿ-1</strong> . Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize\"><a href=\"#isize\" class=\"headerlink\" title=\"isize\"></a>isize</h2>Variable sized signed(+/-) integer</li>\n</ul>\n<p>Simply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .</p>\n<ul>\n<li><h2 id=\"usize\"><a href=\"#usize\" class=\"headerlink\" title=\"usize\"></a>usize</h2>Variable sized unsigned(+) integer</li>\n</ul>\n<p>Simply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.</p>\n<ul>\n<li><h2 id=\"f32\"><a href=\"#f32\" class=\"headerlink\" title=\"f32\"></a>f32</h2>32-bit floating point</li>\n</ul>\n<p>Similar to float in other languages, <strong>Single precision</strong>.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"f64\"><a href=\"#f64\" class=\"headerlink\" title=\"f64\"></a>f64</h2>64-bit floating point</li>\n</ul>\n<p>Similar to double in other languages, <strong>Double precision</strong>.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and also <strong>even with mut, its element count can not be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong>&amp;str</strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, b is a function pointer, to plus_one function</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n//because of Unicode support, char is not a single byte, but four.\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>Fixed size(bit) signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>-2ⁿ⁻¹ to 2ⁿ⁻¹-1</strong> . You can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>Fixed size(bit) unsigned(+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 Same as signed numbers, min and max values are based on IEEE standard for Binary Floating-Point Arithmetic; From <strong>0 to 2ⁿ-1</strong> . Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> to find min and max of each integer type, ex. u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize\"><a href=\"#isize\" class=\"headerlink\" title=\"isize\"></a>isize</h2>Variable sized signed(+/-) integer</li>\n</ul>\n<p>Simply this is the data type to cover all signed integer types but memory allocates according to the size of a pointer. Min and max values are similar to i64 .</p>\n<ul>\n<li><h2 id=\"usize\"><a href=\"#usize\" class=\"headerlink\" title=\"usize\"></a>usize</h2>Variable sized unsigned(+) integer</li>\n</ul>\n<p>Simply this is the data type to cover all unsigned integer types but memory allocates according to the size of a pointer. Min and max values are similar to u64.</p>\n<ul>\n<li><h2 id=\"f32\"><a href=\"#f32\" class=\"headerlink\" title=\"f32\"></a>f32</h2>32-bit floating point</li>\n</ul>\n<p>Similar to float in other languages, <strong>Single precision</strong>.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware not supports for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"f64\"><a href=\"#f64\" class=\"headerlink\" title=\"f64\"></a>f64</h2>64-bit floating point</li>\n</ul>\n<p>Similar to double in other languages, <strong>Double precision</strong>.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and also <strong>even with mut, its element count can not be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with mut, its element count can not be changed. Also, if you want to change an element’s value, new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows to create a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable, and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong>&amp;str</strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, b is a function pointer, to plus_one function</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Operators","_content":"\n## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**\n\n\n## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)\nlet g = a >> a; //0  (remove 2 positions from the end -> o̶1̶ -> 0)\n```\n\n\n## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","source":"docs/zh-cn/a9.operators.md","raw":"title: Operators\n---\n\n## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**\n\n\n## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)\nlet g = a >> a; //0  (remove 2 positions from the end -> o̶1̶ -> 0)\n```\n\n\n## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","date":"2018-12-17T12:27:39.805Z","updated":"2018-12-17T12:27:39.805Z","path":"docs/zh-cn/a9.operators.html","comments":1,"layout":"page","_id":"cjpt525g40011umzavugh6dat","content":"<h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong></p>\n</blockquote>\n<h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (add 2 positions to the end -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (remove 2 positions from the end -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2><p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2><p>&amp; &amp;mut *</p>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong></p>\n</blockquote>\n<h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types, ! inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (add 2 positions to the end -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (remove 2 positions from the end -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2><p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2><p>&amp; &amp;mut *</p>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n"},{"title":"Structs","_content":"\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/zh-cn/b2.structs.md","raw":"title: Structs\n---\n\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/b2.structs.html","comments":1,"layout":"page","_id":"cjpt525g50012umzatav10ryl","content":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/zh-cn/b4.generics.md","raw":"title: Generics\n---\n\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/b4.generics.html","comments":1,"layout":"page","_id":"cjpt525g50013umza011068rl","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Vectors","_content":"\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/zh-cn/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/b1.vectors.html","comments":1,"layout":"page","_id":"cjpt525g60014umzay6olo292","content":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/zh-cn/b3.enums.md","raw":"title: Enums\n---\n\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/b3.enums.html","comments":1,"layout":"page","_id":"cjpt525g60015umzafh7nsyct","content":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/zh-cn/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2018-12-17T12:27:39.807Z","updated":"2018-12-17T12:27:39.807Z","path":"docs/zh-cn/c2.borrowing.html","comments":1,"layout":"page","_id":"cjpt525g70016umzae2gx4rsh","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Impls & Traits","_content":"\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/zh-cn/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjpt525g70017umzakmyk6qph","content":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","source":"docs/zh-cn/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","date":"2018-12-17T12:27:39.806Z","updated":"2018-12-17T12:27:39.806Z","path":"docs/zh-cn/c1.ownership.html","comments":1,"layout":"page","_id":"cjpt525g80018umzaymbn0acp","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/zh-cn/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2018-12-17T12:27:39.807Z","updated":"2018-12-17T12:27:39.807Z","path":"docs/zh-cn/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjpt525g80019umzaf8ellte1","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","source":"docs/zh-cn/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","date":"2018-12-17T12:27:39.807Z","updated":"2018-12-17T12:27:39.807Z","path":"docs/zh-cn/d1.code_organization.html","comments":1,"layout":"page","_id":"cjpt525g9001aumza08qh1ak9","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/zh-cn/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2018-12-17T12:27:39.807Z","updated":"2018-12-17T12:27:39.807Z","path":"docs/zh-cn/d2.functions.html","comments":1,"layout":"page","_id":"cjpt525g9001bumza522ssjdf","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/zh-cn/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2018-12-17T12:27:39.807Z","updated":"2018-12-17T12:27:39.807Z","path":"docs/zh-cn/d3.modules.html","comments":1,"layout":"page","_id":"cjpt525ga001cumza29zbeypq","content":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/zh-cn/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2018-12-17T12:27:39.808Z","updated":"2018-12-17T12:27:39.808Z","path":"docs/zh-cn/d5.workspaces.html","comments":1,"layout":"page","_id":"cjpt525gb001dumzacsh6cr73","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Crate","_content":"\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/zh-cn/d4.crates.md","raw":"title: Crate\n---\n\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","date":"2018-12-17T12:27:39.808Z","updated":"2018-12-17T12:27:39.808Z","path":"docs/zh-cn/d4.crates.html","comments":1,"layout":"page","_id":"cjpt525gb001eumza8g819z7m","content":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"},{"title":"Use","_content":"\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","source":"docs/zh-cn/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","date":"2018-12-17T12:27:39.808Z","updated":"2018-12-17T12:27:39.808Z","path":"docs/zh-cn/d6.use.html","comments":1,"layout":"page","_id":"cjpt525gb001fumzabl996mv6","content":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/zh-cn/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2018-12-17T12:27:39.808Z","updated":"2018-12-17T12:27:39.808Z","path":"docs/zh-cn/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjpt525gc001gumza1i3l6qua","content":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/zh-cn/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2018-12-17T12:27:39.809Z","updated":"2018-12-17T12:27:39.809Z","path":"docs/zh-cn/index.html","comments":1,"layout":"page","_id":"cjpt525gc001humzaptyvbmq8","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"}}},"menu":{"docs":"/docs/a1.why_rust.html"}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}