{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/browserconfig.xml","path":"browserconfig.xml","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/footer.ejs","path":"footer.ejs","modified":1,"renderable":0},{"_id":"source/header.ejs","path":"header.ejs","modified":1,"renderable":0},{"_id":"source/icon.png","path":"icon.png","modified":1,"renderable":0},{"_id":"source/logo.png","path":"logo.png","modified":1,"renderable":0},{"_id":"source/logo.svg","path":"logo.svg","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/tile.png","path":"tile.png","modified":1,"renderable":0},{"_id":"source/tile-wide.png","path":"tile-wide.png","modified":1,"renderable":0},{"_id":"themes/navy/source/css/navy.styl","path":"css/navy.styl","modified":1,"renderable":1},{"_id":"themes/navy/source/js/lang_select.js","path":"js/lang_select.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/mobile_nav.js","path":"js/mobile_nav.js","modified":1,"renderable":1},{"_id":"themes/navy/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/docs/images/rust_playground.png","path":"docs/images/rust_playground.png","modified":1,"renderable":0},{"_id":"source/docs/images/learning_rust_medium.png","path":"docs/images/learning_rust_medium.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/browserconfig.xml","hash":"fbbe41933e15560e7852d721804f026586ee912f","modified":1537969649328},{"_id":"source/favicon.ico","hash":"63e4879d10467b4bc481a208c3a64649242a1420","modified":1537969649341},{"_id":"source/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1537969649341},{"_id":"source/header.ejs","hash":"f11e05683613fadbe26d60c0e4caa17446a3f753","modified":1537969649342},{"_id":"source/icon.png","hash":"2e2866bf9acc59972ff373313a4a55d63a99d5fa","modified":1537969649342},{"_id":"source/index.jade","hash":"4ff791b949071d063b26b0a1536a368f54ac26a3","modified":1547916800797},{"_id":"source/logo.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649342},{"_id":"source/logo.svg","hash":"5e0c7d1865879f49f310bd47a09b97963c48b301","modified":1537969649343},{"_id":"source/robots.txt","hash":"99982b66ad7cd8004bc97a41ee92a7fb05c986ab","modified":1537969649343},{"_id":"source/tile.png","hash":"f0d614f11bc0fcb08aa9dd002267c06e76c12cdd","modified":1537969649344},{"_id":"source/tile-wide.png","hash":"24120ca25a08d3dce34608fd99dcfda0955fc6b9","modified":1537969649344},{"_id":"source/_data/languages.yml","hash":"f6ca069b95ecc899c54143606db156542cb65431","modified":1553007031969},{"_id":"source/docs/a1.why_rust.md","hash":"46fd6f1eff1fe4e77241ac86858757bdd8147524","modified":1553007039948},{"_id":"source/docs/a10.control_flows.md","hash":"a81c53d4cbc76ee86ab0a155b18f3499a97063bf","modified":1553007039949},{"_id":"source/docs/a2.installation.md","hash":"dc91c028e1cd343c3b0fce6666688306888fb0f1","modified":1553007039949},{"_id":"source/_data/menu.yml","hash":"4d92fec119c237b2c0d0ad45e66f5dac7bd50c59","modified":1537969649328},{"_id":"source/_data/sidebar.yml","hash":"30003bad5ccd07fb53f8818b866b864e51fc5683","modified":1547916800790},{"_id":"source/docs/a4.cargo,crates_and_basic_project_structure.md","hash":"a5f8ebb53a4bf0f8dbd2c9f9f4456200a76ca703","modified":1553007039949},{"_id":"source/docs/a5.comments_and_documenting_the_code.md","hash":"461058b592719c8abb75a5b2f36338f6b91f2a38","modified":1553007039950},{"_id":"source/docs/a6.variable_bindings,constants_and_statics.md","hash":"d6c11d390a72880f20f0923d6d3b202f22d3bd41","modified":1553007039950},{"_id":"source/docs/a7.functions.md","hash":"dae58c82383375279e8f54eef12870e2bcec6575","modified":1553007039950},{"_id":"source/docs/a3.hello_world.md","hash":"d7ba8f42c87485c4a46b64cc6e5c85b71da5c727","modified":1547916800790},{"_id":"source/docs/a8.primitive_data_types.md","hash":"dc271542b84bdbd3b83ef1883f1f6ad3d5edc91a","modified":1553007039951},{"_id":"source/docs/a9.operators.md","hash":"58353dc54c5b9f989e124fe472f14e752cc7c1e4","modified":1553007039951},{"_id":"source/docs/b1.vectors.md","hash":"816fffba05d7a10a0d0478ef390b7e637cb09756","modified":1553007039951},{"_id":"source/docs/b2.structs.md","hash":"9692c38ae9e3b923fcbaebdc1daa4c5c425e972b","modified":1553007039952},{"_id":"source/docs/b3.enums.md","hash":"e89cff8f895ecbee890c4f760c89dbf5b8c9557d","modified":1553007039952},{"_id":"source/docs/b4.generics.md","hash":"e4751cbc623a0c183464eb5101938afb2b367828","modified":1553007039952},{"_id":"source/docs/b5.impls_and_traits.md","hash":"fde00c7b4a159fe843cabf78c00fcc78c38232e4","modified":1553007039953},{"_id":"source/docs/c1.ownership.md","hash":"0858097c16363be947ee029d6c433f4e7fa09ed5","modified":1553007039953},{"_id":"source/docs/c2.borrowing.md","hash":"c7ae57d6cb813490d5821ac02817a4ebab954e2b","modified":1553007039953},{"_id":"source/docs/c3.lifetimes.md","hash":"0efd4513e5b88efe78bc96ab93e7079263a476b7","modified":1553007039954},{"_id":"source/docs/d1.code_organization.md","hash":"3ce2928b3b1e95401fa3af7d3acfed9a583ae8e7","modified":1553007039954},{"_id":"source/docs/d2.functions.md","hash":"efa339c80519f45f0245d58e2f14c954e4c96720","modified":1553007039955},{"_id":"source/docs/d3.modules.md","hash":"f7e570107ec6874fd6c3422979e4dba76f176acd","modified":1553007039955},{"_id":"source/docs/d4.crates.md","hash":"70f63469b3f614d30a262d93395fcdc1ab8720c7","modified":1553007039956},{"_id":"source/docs/d5.workspaces.md","hash":"842b95ef4c92031ee7af09eb79b41dd63d57c7e9","modified":1553007039956},{"_id":"source/docs/d6.use.md","hash":"3ffd95fc893279655db6e9dcb148485fb55a361e","modified":1553007039957},{"_id":"source/docs/e2.panicking.md","hash":"6b2844ea66522a4372891eaa7e13a88b93b77343","modified":1553007039959},{"_id":"source/docs/d7.std_primitives_and_preludes.md","hash":"fc9f042e91986731cd43e9c74ab929ebc409c80a","modified":1553007039957},{"_id":"source/docs/e1.smart_compiler.md","hash":"a765f01346a5b7052bb974e40125612ff08d3a73","modified":1553007039958},{"_id":"source/docs/e4.unwrap_and_expect.md","hash":"0e5e14e3a98b108773c4c194cda34123c74dff00","modified":1553007039960},{"_id":"source/docs/e3.option_and_result.md","hash":"b3ef6835add898de9683c53870935e638a97fb45","modified":1547916800795},{"_id":"source/docs/e5.error_and_none_propagation.md","hash":"591b7dd8c21f51c027b7b4726d30f3c37f7a11a6","modified":1547916800795},{"_id":"source/docs/e6.combinators.md","hash":"8ca64b34f06204e310df613e190fa44ff6ed2dcf","modified":1547916800795},{"_id":"source/docs/e7.custom_error_types.md","hash":"f0b538c4c2f56ac48a06ec534784414bc1a3d659","modified":1547916800795},{"_id":"source/docs/index.md","hash":"bf823c5b239bbbd03d0863fd9a4275f82f30eb67","modified":1547916800797},{"_id":"source/zh-cn/index.jade","hash":"a75a061d696d4c48814d07bc627d36ee51ce2e7c","modified":1553007031988},{"_id":"themes/navy/languages/zh-cn.yml","hash":"940e0d9b2330d05f69f4f3f0d18632ada54ebcc7","modified":1553007031988},{"_id":"themes/navy/languages/en.yml","hash":"bf72903ca6d77c193681ee8c6d2f4c3f45003bfd","modified":1547916800797},{"_id":"themes/navy/layout/index.swig","hash":"c52c941a231710700aeafd4866d964c069afb6a6","modified":1537969649345},{"_id":"themes/navy/layout/layout.swig","hash":"ef28a5f5fc3258622e72ee3a836ff8cf415fb790","modified":1537969649345},{"_id":"themes/navy/layout/page.swig","hash":"85ac992e8fc5a6577f434c65f6f71fa021a36114","modified":1537969649346},{"_id":"source/docs/zh-cn/a1.why_rust.md","hash":"7b700fa56f98732688b5b55a066fbce5f6887611","modified":1553007031980},{"_id":"source/docs/zh-cn/a10.control_flows.md","hash":"01d70eb768bcb3aa3ce826ed4ceccad2f1993f35","modified":1553007031980},{"_id":"source/docs/zh-cn/a2.installation.md","hash":"97d351de0abc4659a389a168eda0ec85bef24aae","modified":1553007031980},{"_id":"source/docs/zh-cn/a3.hello_world.md","hash":"a532fdaed694777f9d2e73c007235d444d02be90","modified":1553007031981},{"_id":"source/docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","hash":"016872103e1ca87ed242f380796b80fd030feadf","modified":1553007031982},{"_id":"source/docs/zh-cn/a5.comments_and_documenting_the_code.md","hash":"ed9000ecb788923d5bb8e2bc9655237af39c6fbd","modified":1553007045775},{"_id":"source/docs/zh-cn/a6.variable_bindings,constants_and_statics.md","hash":"c817d6e22779dffe02e72336e8838f695a7b6539","modified":1553007045775},{"_id":"source/docs/zh-cn/a7.functions.md","hash":"ccf6381f015ece607907261b8aed8198edf106f6","modified":1553007031982},{"_id":"source/docs/zh-cn/a8.primitive_data_types.md","hash":"30305ebe7287398654305451db20f230cf52ea45","modified":1553007031983},{"_id":"source/docs/zh-cn/a9.operators.md","hash":"12522be27f4d522ee96cfda556900ca02e6b98ad","modified":1553007031983},{"_id":"source/docs/zh-cn/b1.vectors.md","hash":"501b1a01586ec2832730d851f3712a2f2c644fff","modified":1553007031983},{"_id":"source/docs/zh-cn/b2.structs.md","hash":"cf526b9c92b58916f8bb9402bb3e09a2f027ded6","modified":1553007031983},{"_id":"source/docs/zh-cn/b3.enums.md","hash":"1fbb49355b7efdaf29140e3fbf178592eae60362","modified":1553007031983},{"_id":"source/docs/zh-cn/b4.generics.md","hash":"169ff9b1a0d44b9a53e7435163d4e5a41aeb5378","modified":1553007031984},{"_id":"source/docs/zh-cn/b5.impls_and_traits.md","hash":"ca56634d1900c7acf0cb95547c99620594fe7dd2","modified":1553007031984},{"_id":"source/docs/zh-cn/c1.ownership.md","hash":"d07cd45fb444b328287c31f52e77a44894d43167","modified":1553007031984},{"_id":"source/docs/zh-cn/c2.borrowing.md","hash":"0e9c6ef9b0dbbc0ec7b21bf48857ec719748680a","modified":1553007031984},{"_id":"source/docs/zh-cn/c3.lifetimes.md","hash":"201c598dd8a745bd7ec70080401eab323a730f83","modified":1553007031985},{"_id":"source/docs/zh-cn/d1.code_organization.md","hash":"244e1e3c0e860b9f37f6e5816811ffaf54efb33e","modified":1553007031985},{"_id":"source/docs/zh-cn/d2.functions.md","hash":"f7980784d321a7c82e5c439ff4b637c15841886e","modified":1553007031985},{"_id":"source/docs/zh-cn/d3.modules.md","hash":"09cb368ddd985465950df006dba5625b3f8d1b21","modified":1553007031985},{"_id":"source/docs/zh-cn/d4.crates.md","hash":"cec2915e8677b9eb9b848afb28d3742112ea72d7","modified":1553007031986},{"_id":"source/docs/zh-cn/d5.workspaces.md","hash":"8b6ea3fd7457ede0f13c61a098314fa2350399a0","modified":1553007031986},{"_id":"source/docs/zh-cn/d6.use.md","hash":"31a4e957de4a9b5536ec5d78d12f04edde6e386f","modified":1553007031986},{"_id":"source/docs/zh-cn/d7.std_primitives_and_preludes.md","hash":"8c5ef8f5c191f518dfcd7de1ac4682b12d47c272","modified":1553007031986},{"_id":"source/docs/zh-cn/index.md","hash":"b69b14f0bdc74a4d29983d7c14d4f6baa80f41ca","modified":1553007031987},{"_id":"themes/navy/layout/partial/footer.swig","hash":"9c7c019889a8aafb129b651d1f296fd589741919","modified":1547916800798},{"_id":"themes/navy/layout/partial/after_footer.swig","hash":"0cdfcc5b1be944b906a59d25e84f55a35a179c28","modified":1537969649346},{"_id":"themes/navy/layout/partial/google_analytics.swig","hash":"44869c53540e7dfc6dfde2550e3bb94e0693c8a6","modified":1537969649347},{"_id":"themes/navy/layout/partial/head.swig","hash":"b4838ad7bb5be71d97dbf94d7afcc45a324ee914","modified":1547916800798},{"_id":"themes/navy/layout/partial/header.swig","hash":"ceb929b9688b7295652ea5e778e627b6edb88a32","modified":1547916800798},{"_id":"themes/navy/layout/partial/mobile_nav.swig","hash":"78b20fe48e8de9e1ecc07399c9278ed4e0c404f9","modified":1537969649347},{"_id":"themes/navy/layout/partial/post.swig","hash":"27b0b027a12215a4b05eec31a4868448a5c7d16e","modified":1537969649348},{"_id":"themes/navy/layout/partial/share.swig","hash":"43087d425d24eb2c59ad850a68d4528f43f9842d","modified":1537969649348},{"_id":"themes/navy/layout/partial/sidebar.swig","hash":"6bb7120a1ab8eadf5089d16f63100ce7f36d7343","modified":1537969649348},{"_id":"themes/navy/source/css/_variables.styl","hash":"70a2675653277dd86d178b25c7ad50de0902583a","modified":1537969649351},{"_id":"themes/navy/source/css/navy.styl","hash":"82192ed1cf748fa515751b52c6c6240e22f32439","modified":1537969649352},{"_id":"themes/navy/source/js/lang_select.js","hash":"f3d61d478e8f7e6d9d661e5e83fdc4450a012e67","modified":1537969649352},{"_id":"themes/navy/source/js/mobile_nav.js","hash":"f4976aef22eb1e5e06b20c7735f7d3ef29b8956e","modified":1537969649352},{"_id":"themes/navy/source/js/toc.js","hash":"d95c8db8caddf36cada66acf03a2377d28e9c107","modified":1537969649353},{"_id":"source/docs/images/rust_playground.png","hash":"c3b021fb45cb2ebdc7689ba7fe809841c9f4af03","modified":1537969649341},{"_id":"themes/navy/source/css/_partial/base.styl","hash":"c4f8602ab539480b5b3c6ebaa8c368432ca5ca7b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/footer.styl","hash":"ba0a2262f0d5cf982ad1149be8f05331f492aaff","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/header.styl","hash":"b84db68c0c3cc37a9bedb7f82cf563e676dd495b","modified":1537969649349},{"_id":"themes/navy/source/css/_partial/highlight.styl","hash":"f03294c7392e0c371a5f7150fe7c4e436fd361fe","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/index.styl","hash":"bae9cbbde385ba4303e60c1f5e69464059478ad2","modified":1537969649350},{"_id":"themes/navy/source/css/_partial/mobile_nav.styl","hash":"7fd521d9f54865a17af453ac94dcd6b4ae420ccb","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/sidebar.styl","hash":"bd44876a668ec1337d7b39be3f47e99bd95b3e3e","modified":1537969649351},{"_id":"themes/navy/source/css/_partial/page.styl","hash":"7da422e27ecc807b881b880202ae76656f2a39c3","modified":1537969649351},{"_id":"source/docs/images/learning_rust_medium.png","hash":"8e64be2d9da4e336b00a14703b3228b975588d05","modified":1547916800796}],"Category":[],"Data":[{"_id":"languages","data":{"en":"English","zh-cn":"Chinese"}},{"_id":"menu","data":{"docs":"/docs/a1.why_rust.html"}},{"_id":"sidebar","data":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}],"Page":[{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-user-astronaut\n      h3.intro-feature-title\n        a(href='/docs/e1.smart_compiler.html') Error Handling\n      p.intro-feature-desc Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-meteor\n      h3.intro-feature-title\n        a(href='#') Stay tuned!\n      p.intro-feature-desc More things are coming in 2019. Stay in touch!\n","source":"index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/a1.why_rust.html') Basics\n      p.intro-feature-desc Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/b1.vectors.html') Beyond the Basics\n      p.intro-feature-desc Vectors, Structs, Enums, Generics, Impls & Traits.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/c1.ownership.html') The Tough Part\n      p.intro-feature-desc Ownership, Borrowing, Lifetimes & Lifetime Elision.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/d1.code_organization.html') Let's Get It Started\n      p.intro-feature-desc Modules, Crates, Workspaces, std modules and Preludes.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-user-astronaut\n      h3.intro-feature-title\n        a(href='/docs/e1.smart_compiler.html') Error Handling\n      p.intro-feature-desc Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-meteor\n      h3.intro-feature-title\n        a(href='#') Stay tuned!\n      p.intro-feature-desc More things are coming in 2019. Stay in touch!\n","date":"2019-01-19T16:53:20.797Z","updated":"2019-01-19T16:53:20.797Z","path":"index.html","title":"","comments":1,"_id":"cjtfwbiyn0000dwgpv1rke8wk","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-user-astronaut\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/e1.smart_compiler.html\">Error Handling</a></h3><p class=\"intro-feature-desc\">Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-meteor\"></i></div><h3 class=\"intro-feature-title\"><a href=\"#\">Stay tuned!</a></h3><p class=\"intro-feature-desc\">More things are coming in 2019. Stay in touch!</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/a1.why_rust.html\">Basics</a></h3><p class=\"intro-feature-desc\">Installation, Hello World, Cargo, Crates, Variable bindings, Functions, Primitive Data Types, Operators & Control Flows.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/b1.vectors.html\">Beyond the Basics</a></h3><p class=\"intro-feature-desc\">Vectors, Structs, Enums, Generics, Impls & Traits.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/c1.ownership.html\">The Tough Part</a></h3><p class=\"intro-feature-desc\">Ownership, Borrowing, Lifetimes & Lifetime Elision.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/d1.code_organization.html\">Let's Get It Started</a></h3><p class=\"intro-feature-desc\">Modules, Crates, Workspaces, std modules and Preludes.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-user-astronaut\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/e1.smart_compiler.html\">Error Handling</a></h3><p class=\"intro-feature-desc\">Smart compiler, Panicking, Option & Result, Unwrap & Expect, Error & None propagation, Combinators and Custom Error Types.</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-meteor\"></i></div><h3 class=\"intro-feature-title\"><a href=\"#\">Stay tuned!</a></h3><p class=\"intro-feature-desc\">More things are coming in 2019. Stay in touch!</p></div></li></ul>"},{"title":"Why Rust?","_content":"\n## History of Rust\nRust was initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It is a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on the backend. Also, Rust is a **multi-paradigm programming language**, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at compile-time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile-time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model: **C**\n* Data types: **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings: **Swift**\n* Hygienic Macros: **Scheme**\n* Functional Programming: **Haskell, OCaml, F\\#**\n* Attributes: **ECMA**-335\n* Memory Model and Memory Management: **C++, ML Kit, Cyclone**\n* Type Classes: **Haskell**\n* Crate: Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency: **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure: **Erlang**\n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compile-time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C, C++ like programming languages.\n","source":"docs/a1.why_rust.md","raw":"title: Why Rust?\n---\n\n## History of Rust\nRust was initially designed and developed by Mozilla employee **Graydon Hoare** as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.\n\n## Initial Goals\nThe goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust is very young and very modern language. It is a **compiled programming language** and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on the backend. Also, Rust is a **multi-paradigm programming language**, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at compile-time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile-time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## Influences\nIts design elements came from a wide range of sources.\n\n* Abstract Machine Model: **C**\n* Data types: **C, SML, OCaml, Lisp, Limbo**\n* Optional Bindings: **Swift**\n* Hygienic Macros: **Scheme**\n* Functional Programming: **Haskell, OCaml, F\\#**\n* Attributes: **ECMA**-335\n* Memory Model and Memory Management: **C++, ML Kit, Cyclone**\n* Type Classes: **Haskell**\n* Crate: Assembly in the **ECMA**-335 CLI model\n* Channels and Concurrency: **Newsqueak, Alef, Limbo**\n* Message passing and Thread failure: **Erlang**\n\nand etc.\n\n\nRust **doesn't use an automated garbage collection** system\\(GC\\) by default.\n\nRust compiler observes the code **at compile-time** and helps to [**prevent many types of errors**](https://doc.rust-lang.org/error-index.html) that are possible to write in C, C++ like programming languages.\n","date":"2019-03-19T14:50:39.948Z","updated":"2019-03-19T14:50:39.948Z","path":"docs/a1.why_rust.html","comments":1,"layout":"page","_id":"cjtfwbiz60001dwgp0sfyimjw","content":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust was initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It is a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on the backend. Also, Rust is a <strong>multi-paradigm programming language</strong>, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at compile-time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile-time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model: <strong>C</strong></li>\n<li>Data types: <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings: <strong>Swift</strong></li>\n<li>Hygienic Macros: <strong>Scheme</strong></li>\n<li>Functional Programming: <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes: <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management: <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes: <strong>Haskell</strong></li>\n<li>Crate: Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency: <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure: <strong>Erlang</strong></li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn’t use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compile-time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C, C++ like programming languages.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"History-of-Rust\"><a href=\"#History-of-Rust\" class=\"headerlink\" title=\"History of Rust\"></a>History of Rust</h2><p>Rust was initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.</p>\n<h2 id=\"Initial-Goals\"><a href=\"#Initial-Goals\" class=\"headerlink\" title=\"Initial Goals\"></a>Initial Goals</h2><p>The goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust is very young and very modern language. It is a <strong>compiled programming language</strong> and it uses <a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a> on the backend. Also, Rust is a <strong>multi-paradigm programming language</strong>, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at compile-time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile-time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"Influences\"><a href=\"#Influences\" class=\"headerlink\" title=\"Influences\"></a>Influences</h2><p>Its design elements came from a wide range of sources.</p>\n<ul>\n<li>Abstract Machine Model: <strong>C</strong></li>\n<li>Data types: <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>Optional Bindings: <strong>Swift</strong></li>\n<li>Hygienic Macros: <strong>Scheme</strong></li>\n<li>Functional Programming: <strong>Haskell, OCaml, F#</strong></li>\n<li>Attributes: <strong>ECMA</strong>-335</li>\n<li>Memory Model and Memory Management: <strong>C++, ML Kit, Cyclone</strong></li>\n<li>Type Classes: <strong>Haskell</strong></li>\n<li>Crate: Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>Channels and Concurrency: <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>Message passing and Thread failure: <strong>Erlang</strong></li>\n</ul>\n<p>and etc.</p>\n<p>Rust <strong>doesn’t use an automated garbage collection</strong> system(GC) by default.</p>\n<p>Rust compiler observes the code <strong>at compile-time</strong> and helps to <a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>prevent many types of errors</strong></a> that are possible to write in C, C++ like programming languages.</p>\n"},{"title":"Control Flows","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be the same on each block when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/a10.control_flows.md","raw":"title: Control Flows\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **Return data type should be the same on each block when using this as an expression.**\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a10.control_flows.html","comments":1,"layout":"page","_id":"cjtfwbiz60002dwgponcwthsj","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be the same on each block when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>Return data type should be the same on each block when using this as an expression.</strong></p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // check 16\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;,\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped\n    // Because data type of is_allowed is boolean and all possibilities checked on conditions\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot;\n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { //set label outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// Working with arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() turn the array into a simple iterator\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"Installation","_content":"\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run.\n\n> ⭐ If you are on **Microsoft Windows**, you have to install **[Visual C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)** 2015 or higher, which requires an additional 3–4 GBs.\n\nAfter installing Rust you can check the current version by typing **`rustc --version`** or **`rustc -V`** on your terminal to verify the success of the installation.\n","source":"docs/a2.installation.md","raw":"title: Installation\n---\n\n## Rustup\nThere are many ways to install Rust on your system. For the moment the official way to install Rust is using [Rustup](https://rustup.rs/).\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between **stable, beta, and nightly** compilers and keep them updated. It makes **cross-compiling** simpler with binary builds of the standard library for common platforms.\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs **`rustc`, `cargo`, `rustup`** and other standard tools to Cargo's `bin` directory. On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\\.cargo\\bin`. This is the same directory that `cargo install` will install Rust programs and Cargo plugins.\n\n💡 More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).\n\n### For Mac and Linux Users\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### For Windows Users\nDownload **`rustup-init.exe`** from [www.rustup.rs](https://rustup.rs/) and run.\n\n> ⭐ If you are on **Microsoft Windows**, you have to install **[Visual C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)** 2015 or higher, which requires an additional 3–4 GBs.\n\nAfter installing Rust you can check the current version by typing **`rustc --version`** or **`rustc -V`** on your terminal to verify the success of the installation.\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a2.installation.html","comments":1,"layout":"page","_id":"cjtfwbiz70003dwgpwyg7coni","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run.</p>\n<blockquote>\n<p>⭐ If you are on <strong>Microsoft Windows</strong>, you have to install <strong><a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\" rel=\"noopener\">Visual C++ Build Tools</a></strong> 2015 or higher, which requires an additional 3–4 GBs.</p>\n</blockquote>\n<p>After installing Rust you can check the current version by typing <strong><code>rustc --version</code></strong> or <strong><code>rustc -V</code></strong> on your terminal to verify the success of the installation.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo’s <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\\.cargo\\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>\n<p>💡 More information can be found on the <a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Github page of Rustup project</a>.</p>\n<h3 id=\"For-Mac-and-Linux-Users\"><a href=\"#For-Mac-and-Linux-Users\" class=\"headerlink\" title=\"For Mac and Linux Users\"></a>For Mac and Linux Users</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"For-Windows-Users\"><a href=\"#For-Windows-Users\" class=\"headerlink\" title=\"For Windows Users\"></a>For Windows Users</h3><p>Download <strong><code>rustup-init.exe</code></strong> from <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a> and run.</p>\n<blockquote>\n<p>⭐ If you are on <strong>Microsoft Windows</strong>, you have to install <strong><a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\" rel=\"noopener\">Visual C++ Build Tools</a></strong> 2015 or higher, which requires an additional 3–4 GBs.</p>\n</blockquote>\n<p>After installing Rust you can check the current version by typing <strong><code>rustc --version</code></strong> or <strong><code>rustc -V</code></strong> on your terminal to verify the success of the installation.</p>\n"},{"title":"Comments and Documenting the code","_content":"\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **By convention, try to avoid block comments. Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/a5.comments_and_documenting_the_code.md","raw":"title: Comments and Documenting the code\n---\n\n## Comments\n\n```rust\n// Line comments\n/* Block comments */\n```\n\nNested block comments are supported.\n\n💡 **By convention, try to avoid block comments. Use line comments instead.**\n\n## Doc Comments\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjtfwbiz80004dwgpp7d2yyz3","content":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>By convention, try to avoid block comments. Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Line comments\n/* Block comments */\n</code></pre>\n<p>Nested block comments are supported.</p>\n<p>💡 <strong>By convention, try to avoid block comments. Use line comments instead.</strong></p>\n<h2 id=\"Doc-Comments\"><a href=\"#Doc-Comments\" class=\"headerlink\" title=\"Doc Comments\"></a>Doc Comments</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"Cargo, Crates and Basic Project Structure","_content":"\n## Cargo\n\nCargo is Rust’s built-in package manager and the build system. It can be used to,\n\n- Create a new project: `cargo new`\n- Build the project: `cargo build`\n- Run the project: `cargo run`  \n- Update project dependencies: `cargo update`\n- Run tests: `cargo test`  \n- Generate the project documentation via [rustdoc](https://doc.rust-lang.org/stable/rustdoc/): `cargo doc`\n- Analyze the project to see it has any errors, without building it: `cargo check`\n\nIn addition, there are `cargo` commands to publish the project as a crate/ package to **Rust's official crate registry, [crates.io](https://crates.io/)**.\n\n> 💡 We need to get an API token from [crates.io](https://crates.io/) to publish a crate to it. The API token can be found in the [Account Settings page](https://crates.io/me), after login to that site. We will discuss more about this under [code organization with crates](https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io).\n\n- Log in to [crates.io](https://crates.io/) with the API token: `cargo login`\n- Make the local crate uploadable to [crates.io](https://crates.io/): `cargo package`\n- Upload the crate to [crates.io](https://crates.io/): `cargo publish`\n\n## Crate\n\nA crate is a package, which can be shared via [crates.io](https://crates.io/). A crate can produce an executable or a library. In other words, it can be a **binary** crate or a **library** crate.\n\n01. `cargo new crate_name --bin` or `cargo new crate_name`: Produces an executable\n02. `cargo new crate_name --lib`: Produces a library\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when building it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](https://doc.rust-lang.org/cargo/guide/project-layout.html) about the recommended project layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- The source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","source":"docs/a4.cargo,crates_and_basic_project_structure.md","raw":"title: Cargo, Crates and Basic Project Structure\n---\n\n## Cargo\n\nCargo is Rust’s built-in package manager and the build system. It can be used to,\n\n- Create a new project: `cargo new`\n- Build the project: `cargo build`\n- Run the project: `cargo run`  \n- Update project dependencies: `cargo update`\n- Run tests: `cargo test`  \n- Generate the project documentation via [rustdoc](https://doc.rust-lang.org/stable/rustdoc/): `cargo doc`\n- Analyze the project to see it has any errors, without building it: `cargo check`\n\nIn addition, there are `cargo` commands to publish the project as a crate/ package to **Rust's official crate registry, [crates.io](https://crates.io/)**.\n\n> 💡 We need to get an API token from [crates.io](https://crates.io/) to publish a crate to it. The API token can be found in the [Account Settings page](https://crates.io/me), after login to that site. We will discuss more about this under [code organization with crates](https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io).\n\n- Log in to [crates.io](https://crates.io/) with the API token: `cargo login`\n- Make the local crate uploadable to [crates.io](https://crates.io/): `cargo package`\n- Upload the crate to [crates.io](https://crates.io/): `cargo publish`\n\n## Crate\n\nA crate is a package, which can be shared via [crates.io](https://crates.io/). A crate can produce an executable or a library. In other words, it can be a **binary** crate or a **library** crate.\n\n01. `cargo new crate_name --bin` or `cargo new crate_name`: Produces an executable\n02. `cargo new crate_name --lib`: Produces a library\n\nThe first one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\nand the second one generates,\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(capital c\\) is the configuration file which contains all of the metadata that Cargo needs to compile your project.\n* **src** folder is the place to store the source code.\n* Each crate has an implicit crate root/ entry point. **main.rs** is the crate root for a binary crate and **lib.rs** is the crate root for a library crate.\n\n> 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable file will be stored in **target/debug/** folder. But when building it via `cargo build --release` for a release it will be stored in **target/release/** folder.\n\n## Project Structure\n\nThis is how [Cargo Docs describes](https://doc.rust-lang.org/cargo/guide/project-layout.html) about the recommended project layout,\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- The source code goes in the `src` directory.  \n- The default library file is `src/lib.rs`.  \n- The default executable file is `src/main.rs`.  \n- Other executables can be placed in `src/bin/*.rs`.  \n- Integration tests go in the `tests` directory \\(unit tests go in each file they're testing\\).  \n- Examples go in the `examples` directory.  \n- Benchmarks go in the `benches` directory.\n","date":"2019-03-19T14:50:39.949Z","updated":"2019-03-19T14:50:39.949Z","path":"docs/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjtfwbiz90005dwgpm88ehmlx","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in package manager and the build system. It can be used to,</p>\n<ul>\n<li>Create a new project: <code>cargo new</code></li>\n<li>Build the project: <code>cargo build</code></li>\n<li>Run the project: <code>cargo run</code>  </li>\n<li>Update project dependencies: <code>cargo update</code></li>\n<li>Run tests: <code>cargo test</code>  </li>\n<li>Generate the project documentation via <a href=\"https://doc.rust-lang.org/stable/rustdoc/\" target=\"_blank\" rel=\"noopener\">rustdoc</a>: <code>cargo doc</code></li>\n<li>Analyze the project to see it has any errors, without building it: <code>cargo check</code></li>\n</ul>\n<p>In addition, there are <code>cargo</code> commands to publish the project as a crate/ package to <strong>Rust’s official crate registry, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a></strong>.</p>\n<blockquote>\n<p>💡 We need to get an API token from <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> to publish a crate to it. The API token can be found in the <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings page</a>, after login to that site. We will discuss more about this under <a href=\"https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io\">code organization with crates</a>.</p>\n</blockquote>\n<ul>\n<li>Log in to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> with the API token: <code>cargo login</code></li>\n<li>Make the local crate uploadable to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo package</code></li>\n<li>Upload the crate to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo publish</code></li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>A crate is a package, which can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. A crate can produce an executable or a library. In other words, it can be a <strong>binary</strong> crate or a <strong>library</strong> crate.</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> or <code>cargo new crate_name</code>: Produces an executable</li>\n<li><code>cargo new crate_name --lib</code>: Produces a library</li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when building it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"https://doc.rust-lang.org/cargo/guide/project-layout.html\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended project layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>The source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo is Rust’s built-in package manager and the build system. It can be used to,</p>\n<ul>\n<li>Create a new project: <code>cargo new</code></li>\n<li>Build the project: <code>cargo build</code></li>\n<li>Run the project: <code>cargo run</code>  </li>\n<li>Update project dependencies: <code>cargo update</code></li>\n<li>Run tests: <code>cargo test</code>  </li>\n<li>Generate the project documentation via <a href=\"https://doc.rust-lang.org/stable/rustdoc/\" target=\"_blank\" rel=\"noopener\">rustdoc</a>: <code>cargo doc</code></li>\n<li>Analyze the project to see it has any errors, without building it: <code>cargo check</code></li>\n</ul>\n<p>In addition, there are <code>cargo</code> commands to publish the project as a crate/ package to <strong>Rust’s official crate registry, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a></strong>.</p>\n<blockquote>\n<p>💡 We need to get an API token from <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> to publish a crate to it. The API token can be found in the <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings page</a>, after login to that site. We will discuss more about this under <a href=\"https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io\">code organization with crates</a>.</p>\n</blockquote>\n<ul>\n<li>Log in to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> with the API token: <code>cargo login</code></li>\n<li>Make the local crate uploadable to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo package</code></li>\n<li>Upload the crate to <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>: <code>cargo publish</code></li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>A crate is a package, which can be shared via <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. A crate can produce an executable or a library. In other words, it can be a <strong>binary</strong> crate or a <strong>library</strong> crate.</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> or <code>cargo new crate_name</code>: Produces an executable</li>\n<li><code>cargo new crate_name --lib</code>: Produces a library</li>\n</ol>\n<p>The first one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>and the second one generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>\n<li><strong>src</strong> folder is the place to store the source code.</li>\n<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>\n</ul>\n<blockquote>\n<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when building it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>This is how <a href=\"https://doc.rust-lang.org/cargo/guide/project-layout.html\" target=\"_blank\" rel=\"noopener\">Cargo Docs describes</a> about the recommended project layout,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>The source code goes in the <code>src</code> directory.  </li>\n<li>The default library file is <code>src/lib.rs</code>.  </li>\n<li>The default executable file is <code>src/main.rs</code>.  </li>\n<li>Other executables can be placed in <code>src/bin/*.rs</code>.  </li>\n<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they’re testing).  </li>\n<li>Examples go in the <code>examples</code> directory.  </li>\n<li>Benchmarks go in the <code>benches</code> directory.</li>\n</ul>\n"},{"title":"Variable bindings, Constants & Statics","_content":"\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, the `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; it checks data types at compile-time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics, you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to a set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The **static** keyword is used to define a ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually, statics are placed at the top of the code file, outside the functions.\n","source":"docs/a6.variable_bindings,constants_and_statics.md","raw":"title: Variable bindings, Constants & Statics\n---\n\n⭐️ In Rust variables are **immutable by default**, so we call them **Variable bindings**. To make them mutable, the `mut` keyword is used.\n\n⭐️ Rust is a **statically typed** language; it checks data types at compile-time. But it **doesn’t require you to actually type it when declaring variable bindings**. In that case, the compiler checks the usage and sets a better data type for it. But for **constants and statics, you must annotate the type**. Types come after a colon(:)\n\n* ### Variable bindings\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### Constants\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### Statics\n\n```rust\nstatic N: i32 = 5;\n```\n\nThe **let** keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to a set of values or function values.\n\nThe **const** keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The **static** keyword is used to define a ‘global variable’ type facility. There is only one instance for each value, and it’s at a **fixed location in memory**.\n\n💡 **Always use const**, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.\n\n💡 Usually, statics are placed at the top of the code file, outside the functions.\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a6.variable_bindings,constants_and_statics.html","comments":1,"layout":"page","_id":"cjtfwbiz90006dwgpglb0p1id","content":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, the <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; it checks data types at compile-time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics, you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to a set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The <strong>static</strong> keyword is used to define a ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually, statics are placed at the top of the code file, outside the functions.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, the <code>mut</code> keyword is used.</p>\n<p>⭐️ Rust is a <strong>statically typed</strong> language; it checks data types at compile-time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics, you must annotate the type</strong>. Types come after a colon(:)</p>\n<ul>\n<li><h3 id=\"Variable-bindings\"><a href=\"#Variable-bindings\" class=\"headerlink\" title=\"Variable bindings\"></a>Variable bindings</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"Statics\"><a href=\"#Statics\" class=\"headerlink\" title=\"Statics\"></a>Statics</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to a set of values or function values.</p>\n<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The <strong>static</strong> keyword is used to define a ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>\n<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>\n<p>💡 Usually, statics are placed at the top of the code file, outside the functions.</p>\n"},{"title":"Functions","_content":"\n## Named functions\n\n* Named functions are declared with the keyword **`fn`**\n* When using **arguments**, you **must declare data types**.\n* By default, functions **return empty tuple/ `()`**. If you want to return a value, the **return type must be specified** after **`->`**\n\n### i. Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ii. Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### iii. Returning values\n\n```rust\n// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -> i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // Returns a+2. But, this's a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n```\n\n### iv. Function pointers, Usage as a Data Type\n\n```rust\n// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n\n\n## Closures\n\n* Also known as **anonymous functions** or **lambda functions**.\n* The **data types of arguments and returns are optional**.\n\nExample with a named function, before using closures.\n```rust\nfn main() {\n  let x = 2;\n  println!(\"{}\", get_square_value(x));\n}\n\nfn get_square_value(x: i32) -> i32 {\n    x * x\n}\n```\n\n### i. With optional type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x: i32| -> i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(\"{}\", square(x));\n}\n```\n\n### ii. Without type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(\"{}\", square(x));\n}\n```\n","source":"docs/a7.functions.md","raw":"title: Functions\n---\n\n## Named functions\n\n* Named functions are declared with the keyword **`fn`**\n* When using **arguments**, you **must declare data types**.\n* By default, functions **return empty tuple/ `()`**. If you want to return a value, the **return type must be specified** after **`->`**\n\n### i. Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### ii. Passing arguments\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### iii. Returning values\n\n```rust\n// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -> i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // Returns a+2. But, this's a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n```\n\n### iv. Function pointers, Usage as a Data Type\n\n```rust\n// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n\n\n## Closures\n\n* Also known as **anonymous functions** or **lambda functions**.\n* The **data types of arguments and returns are optional**.\n\nExample with a named function, before using closures.\n```rust\nfn main() {\n  let x = 2;\n  println!(\"{}\", get_square_value(x));\n}\n\nfn get_square_value(x: i32) -> i32 {\n    x * x\n}\n```\n\n### i. With optional type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x: i32| -> i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(\"{}\", square(x));\n}\n```\n\n### ii. Without type declarations of input and return types\n```rust\nfn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(\"{}\", square(x));\n}\n```\n","date":"2019-03-19T14:50:39.950Z","updated":"2019-03-19T14:50:39.950Z","path":"docs/a7.functions.html","comments":1,"layout":"page","_id":"cjtfwbiza0007dwgp3fs8luyf","content":"<h2 id=\"Named-functions\"><a href=\"#Named-functions\" class=\"headerlink\" title=\"Named functions\"></a>Named functions</h2><ul>\n<li>Named functions are declared with the keyword <strong><code>fn</code></strong></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default, functions <strong>return empty tuple/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-&gt;</code></strong></li>\n</ul>\n<h3 id=\"i-Hello-world\"><a href=\"#i-Hello-world\" class=\"headerlink\" title=\"i. Hello world\"></a>i. Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"ii-Passing-arguments\"><a href=\"#ii-Passing-arguments\" class=\"headerlink\" title=\"ii. Passing arguments\"></a>ii. Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"iii-Returning-values\"><a href=\"#iii-Returning-values\" class=\"headerlink\" title=\"iii. Returning values\"></a>iii. Returning values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -&gt; i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // Returns a+2. But, this&#39;s a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n</code></pre>\n<h3 id=\"iv-Function-pointers-Usage-as-a-Data-Type\"><a href=\"#iv-Function-pointers-Usage-as-a-Data-Type\" class=\"headerlink\" title=\"iv. Function pointers, Usage as a Data Type\"></a>iv. Function pointers, Usage as a Data Type</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n<h2 id=\"Closures\"><a href=\"#Closures\" class=\"headerlink\" title=\"Closures\"></a>Closures</h2><ul>\n<li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li>\n<li>The <strong>data types of arguments and returns are optional</strong>.</li>\n</ul>\n<p>Example with a named function, before using closures.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let x = 2;\n  println!(&quot;{}&quot;, get_square_value(x));\n}\n\nfn get_square_value(x: i32) -&gt; i32 {\n    x * x\n}\n</code></pre>\n<h3 id=\"i-With-optional-type-declarations-of-input-and-return-types\"><a href=\"#i-With-optional-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"i. With optional type declarations of input and return types\"></a>i. With optional type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x: i32| -&gt; i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n<h3 id=\"ii-Without-type-declarations-of-input-and-return-types\"><a href=\"#ii-Without-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"ii. Without type declarations of input and return types\"></a>ii. Without type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Named-functions\"><a href=\"#Named-functions\" class=\"headerlink\" title=\"Named functions\"></a>Named functions</h2><ul>\n<li>Named functions are declared with the keyword <strong><code>fn</code></strong></li>\n<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>\n<li>By default, functions <strong>return empty tuple/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-&gt;</code></strong></li>\n</ul>\n<h3 id=\"i-Hello-world\"><a href=\"#i-Hello-world\" class=\"headerlink\" title=\"i. Hello world\"></a>i. Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"ii-Passing-arguments\"><a href=\"#ii-Passing-arguments\" class=\"headerlink\" title=\"ii. Passing arguments\"></a>ii. Passing arguments</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"iii-Returning-values\"><a href=\"#iii-Returning-values\" class=\"headerlink\" title=\"iii. Returning values\"></a>iii. Returning values</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without the return keyword. Only last expression returns.\nfn plus_one(a: i32) -&gt; i32 {\n    a + 1\n    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`\n}\n\n// 02. With the return keyword.\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // Returns a+2. But, this&#39;s a bad practice.\n    // Should use only on conditional returns, except in the last expression\n}\n</code></pre>\n<h3 id=\"iv-Function-pointers-Usage-as-a-Data-Type\"><a href=\"#iv-Function-pointers-Usage-as-a-Data-Type\" class=\"headerlink\" title=\"iv. Function pointers, Usage as a Data Type\"></a>iv. Function pointers, Usage as a Data Type</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Without type declarations\nlet b = plus_one;\nlet c = b(5); //6\n\n// 02. With type declarations\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n<h2 id=\"Closures\"><a href=\"#Closures\" class=\"headerlink\" title=\"Closures\"></a>Closures</h2><ul>\n<li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li>\n<li>The <strong>data types of arguments and returns are optional</strong>.</li>\n</ul>\n<p>Example with a named function, before using closures.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let x = 2;\n  println!(&quot;{}&quot;, get_square_value(x));\n}\n\nfn get_square_value(x: i32) -&gt; i32 {\n    x * x\n}\n</code></pre>\n<h3 id=\"i-With-optional-type-declarations-of-input-and-return-types\"><a href=\"#i-With-optional-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"i. With optional type declarations of input and return types\"></a>i. With optional type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x: i32| -&gt; i32 { // Input parameters are passed inside | | and expression body is wrapped within { }\n        x * x \n    };\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n<h3 id=\"ii-Without-type-declarations-of-input-and-return-types\"><a href=\"#ii-Without-type-declarations-of-input-and-return-types\" class=\"headerlink\" title=\"ii. Without type declarations of input and return types\"></a>ii. Without type declarations of input and return types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x = 2;\n    let square = |x| x * x; // { } are optional for single-lined closures\n    println!(&quot;{}&quot;, square(x));\n}\n</code></pre>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. The `main` function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicates that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) rather than a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save the above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compile it with `rustc file.rs`\n- Execute it with `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of the `println!` macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 The format! macro is used to store the formatted string.\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` means function. The `main` function is the beginning of every Rust program.  \n`println!` prints text to the console and its *!* indicates that it’s a [macro](https://doc.rust-lang.org/book/first-edition/macros.html) rather than a function.\n\n> 💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).\n\n- Save the above code in `file.rs` , but it can be any name with `.rs` extension.\n- Compile it with `rustc file.rs`\n- Execute it with `./file` on Linux and Mac or `file.exe` on Windows\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/) is a web interface for running Rust code.\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## Usages of println!\n\n💯 These are the other usages of the `println!` macro,\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 The format! macro is used to store the formatted string.\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2019-01-19T16:53:20.790Z","updated":"2019-01-19T16:53:20.790Z","path":"docs/a3.hello_world.html","comments":1,"layout":"page","_id":"cjtfwbizb0008dwgp884ysaqk","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. The <code>main</code> function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicates that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> rather than a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save the above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compile it with <code>rustc file.rs</code></li>\n<li>Execute it with <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of the <code>println!</code> macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 The format! macro is used to store the formatted string.\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> means function. The <code>main</code> function is the beginning of every Rust program.<br><code>println!</code> prints text to the console and its <em>!</em> indicates that it’s a <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">macro</a> rather than a function.</p>\n<blockquote>\n<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">snake_case</a>.</p>\n</blockquote>\n<ul>\n<li>Save the above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>\n<li>Compile it with <code>rustc file.rs</code></li>\n<li>Execute it with <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a> is a web interface for running Rust code.</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"Usages-of-println\"><a href=\"#Usages-of-println\" class=\"headerlink\" title=\"Usages of println!\"></a>Usages of println!</h2><p>💯 These are the other usages of the <code>println!</code> macro,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 The format! macro is used to store the formatted string.\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n```\nBecause of Unicode support, char is not a single byte, but four.\n\n- ## i8, i16, i32, i64, i128\n8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 The min and max values are based on the following equation; **from -(2ⁿ⁻¹) to 2ⁿ⁻¹-1**. You can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`i8::min_value();`\n\n\n- ## u8, u16, u32, u64, u128\n8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 The min and max values are based on the following equation; **from 0 to 2ⁿ-1**. Same way you can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`u8::max_value();`\n\n\n- ## isize, usize\nPointer sized signed and unsigned integer types\n\nThe actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.\n\n> 🔎 Search more about [cross-compiling](https://github.com/rust-lang/rustup.rs#cross-compilation) and [Supported Tiers](https://forge.rust-lang.org/platform-support.html) of Rust programs.\n\n\n- ## f32, f64\n32 and 64 bit sized floating point numbers(numbers with decimal points)\n\nRust follows IEEE Standard for Binary Floating-Point Arithmetic. The `f32` type is similar to float(**Single precision**) in other languages, while `f64` is similar to double(**Double precision**) in other languages.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and **even with `mut`, its element count cannot be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with `mut`, its element count cannot be changed. Also, if you want to change an element’s value, the new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **`&str`** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, `b` is a function pointer, to `plus_one()` in the below code.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/a8.primitive_data_types.md","raw":"title: Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n```\n\n\n- ## char\nA single Unicode scalar value\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ no \"x\", only single quotes\n```\nBecause of Unicode support, char is not a single byte, but four.\n\n- ## i8, i16, i32, i64, i128\n8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 The min and max values are based on the following equation; **from -(2ⁿ⁻¹) to 2ⁿ⁻¹-1**. You can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`i8::min_value();`\n\n\n- ## u8, u16, u32, u64, u128\n8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types\n\n| DATA TYPE | MIN | MAX                                     |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡 The min and max values are based on the following equation; **from 0 to 2ⁿ-1**. Same way you can use **min_value()** and **max_value()** functions to find min and max of each integer type. ex.`u8::max_value();`\n\n\n- ## isize, usize\nPointer sized signed and unsigned integer types\n\nThe actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.\n\n> 🔎 Search more about [cross-compiling](https://github.com/rust-lang/rustup.rs#cross-compilation) and [Supported Tiers](https://forge.rust-lang.org/platform-support.html) of Rust programs.\n\n\n- ## f32, f64\n32 and 64 bit sized floating point numbers(numbers with decimal points)\n\nRust follows IEEE Standard for Binary Floating-Point Arithmetic. The `f32` type is similar to float(**Single precision**) in other languages, while `f64` is similar to double(**Double precision**) in other languages.\n\n💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.\n\n\n- ## arrays\nFixed size list of elements of same data type\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ Arrays are **immutable** by default and **even with `mut`, its element count cannot be changed**.\n\n> 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors can contain any type of elements but all elements must be in the same data type.\n\n\n- ## tuples\nFixed size ordered list of elements of different(or same) data types\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ Tuples are also **immutable** by default and **even with `mut`, its element count cannot be changed. Also, if you want to change an element’s value, the new value should have the same data type of previous value**.\n\n\n- ## slice\nDynamically-sized reference to another data structure\n\nThink you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\nUnsized UTF-8 sequence of Unicode string slices\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized sequence of UTF-8** code points stored in somewhere in memory. **&str** is used to borrow and assign the whole array to the given variable binding.\n\n> 🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a **heap**-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();`  `String::from(\"Hello\");`\n\n💡 In general, you should use **String** when you need **ownership**, and **`&str`** when you just need to **borrow a string**.\n\n\n- ## functions\nAs we discussed on functions section, `b` is a function pointer, to `plus_one()` in the below code.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/a8.primitive_data_types.html","comments":1,"layout":"page","_id":"cjtfwbizb0009dwgpbgni4si1","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n</code></pre>\n<p>Because of Unicode support, char is not a single byte, but four.</p>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 The min and max values are based on the following equation; <strong>from -(2ⁿ⁻¹) to 2ⁿ⁻¹-1</strong>. You can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>i8::min_value();</code></p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 The min and max values are based on the following equation; <strong>from 0 to 2ⁿ-1</strong>. Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>u8::max_value();</code></p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>Pointer sized signed and unsigned integer types</li>\n</ul>\n<p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.</p>\n<blockquote>\n<p>🔎 Search more about <a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">cross-compiling</a> and <a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a> of Rust programs.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>32 and 64 bit sized floating point numbers(numbers with decimal points)</li>\n</ul>\n<p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element’s value, the new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong><code>&amp;str</code></strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, <code>b</code> is a function pointer, to <code>plus_one()</code> in the below code.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ no TRUE, FALSE, 1, 0\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>A single Unicode scalar value</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ no &quot;x&quot;, only single quotes\n</code></pre>\n<p>Because of Unicode support, char is not a single byte, but four.</p>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 The min and max values are based on the following equation; <strong>from -(2ⁿ⁻¹) to 2ⁿ⁻¹-1</strong>. You can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>i8::min_value();</code></p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡 The min and max values are based on the following equation; <strong>from 0 to 2ⁿ-1</strong>. Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>u8::max_value();</code></p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>Pointer sized signed and unsigned integer types</li>\n</ul>\n<p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.</p>\n<blockquote>\n<p>🔎 Search more about <a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">cross-compiling</a> and <a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a> of Rust programs.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>32 and 64 bit sized floating point numbers(numbers with decimal points)</li>\n</ul>\n<p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p>\n<p>💡 Should avoid using this unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p>\n<ul>\n<li><h2 id=\"arrays\"><a href=\"#arrays\" class=\"headerlink\" title=\"arrays\"></a>arrays</h2>Fixed size list of elements of same data type</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p>\n<blockquote>\n<p>🔎 If you are looking for a dynamic/growable array, you can use <strong>Vec</strong>. Vectors can contain any type of elements but all elements must be in the same data type.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"tuples\"><a href=\"#tuples\" class=\"headerlink\" title=\"tuples\"></a>tuples</h2>Fixed size ordered list of elements of different(or same) data types</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element’s value, the new value should have the same data type of previous value</strong>.</p>\n<ul>\n<li><h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2>Dynamically-sized reference to another data structure</li>\n</ul>\n<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &amp;[i32] = &amp;a; //Slicing whole array\nlet c = &amp;a[0..4]; // From 0th position to 4th(excluding)\nlet d = &amp;a[..]; //Slicing whole array\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>Unsized UTF-8 sequence of Unicode string slices</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️ It’s an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>\n<blockquote>\n<p>🔎 A <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">String</a> is a <strong>heap</strong>-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong><code>&amp;str</code></strong> when you just need to <strong>borrow a string</strong>.</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>As we discussed on functions section, <code>b</code> is a function pointer, to <code>plus_one()</code> in the below code.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"Operators","_content":"\n- ## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**.\n\n\n- ## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n- ## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types,`!` inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n- ## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b;  //0  (01 && 10 -> 00)\nlet d = a | b;  //3  (01 || 10 -> 11)\nlet e = a ^ b;  //3  (01 != 10 -> 11)\nlet f = a << b; //4  (Add b number of 0s to the end of a -> '01'+'00' -> 100)\nlet g = a >> b; //0  (Remove b number of bits from the end of a -> o̶1̶ -> 0)\n```\n\n\n- ## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n- ## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n- ## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer to [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","source":"docs/a9.operators.md","raw":"title: Operators\n---\n\n- ## Arithmetic Operators\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 Also **+** is used for **array and string concatenation**.\n\n\n- ## Comparison Operators\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n- ## Logical Operators\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 On integer types,`!` inverts the individual bits in the two’s complement representation of the value.\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n- ## Bitwise Operators\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b;  //0  (01 && 10 -> 00)\nlet d = a | b;  //3  (01 || 10 -> 11)\nlet e = a ^ b;  //3  (01 != 10 -> 11)\nlet f = a << b; //4  (Add b number of 0s to the end of a -> '01'+'00' -> 100)\nlet g = a >> b; //0  (Remove b number of bits from the end of a -> o̶1̶ -> 0)\n```\n\n\n- ## Assignment and Compound Assignment Operators\n\nThe = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % & | ^ << >> operators with = operator.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n- ## Type Casting Operator\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n- ## Borrowing and Dereference Operators\n& &mut *\n\nThe **& or &mut** operators are used for **borrowing** and ***** operator for **Dereferencing**.\n\n> 🔎 For more information, refer to [Ownership](c1.ownership.html), [Borrowing](c2.borrowing.html) & [Lifetimes](c3.lifetimes.html) sections.\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/a9.operators.html","comments":1,"layout":"page","_id":"cjtfwbizc000adwgppf617jvp","content":"<ul>\n<li><h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><strong> + - * / %</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong>.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2>== != &lt; &gt; &lt;= &gt;=</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<ul>\n<li><h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2>! &amp;&amp; ||</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types,<code>!</code> inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<ul>\n<li><h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2>&amp; | ^ &lt;&lt; &gt;&gt;</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b;  //3  (01 || 10 -&gt; 11)\nlet e = a ^ b;  //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<ul>\n<li><h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2></li>\n</ul>\n<p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<ul>\n<li><h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2>as</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<ul>\n<li><h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2>&amp; &amp;mut *</li>\n</ul>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer to <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"Arithmetic-Operators\"><a href=\"#Arithmetic-Operators\" class=\"headerlink\" title=\"Arithmetic Operators\"></a>Arithmetic Operators</h2><strong> + - * / %</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong>.</p>\n</blockquote>\n<ul>\n<li><h2 id=\"Comparison-Operators\"><a href=\"#Comparison-Operators\" class=\"headerlink\" title=\"Comparison Operators\"></a>Comparison Operators</h2>== != &lt; &gt; &lt;= &gt;=</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<ul>\n<li><h2 id=\"Logical-Operators\"><a href=\"#Logical-Operators\" class=\"headerlink\" title=\"Logical Operators\"></a>Logical Operators</h2>! &amp;&amp; ||</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 On integer types,<code>!</code> inverts the individual bits in the two’s complement representation of the value.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<ul>\n<li><h2 id=\"Bitwise-Operators\"><a href=\"#Bitwise-Operators\" class=\"headerlink\" title=\"Bitwise Operators\"></a>Bitwise Operators</h2>&amp; | ^ &lt;&lt; &gt;&gt;</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b;  //3  (01 || 10 -&gt; 11)\nlet e = a ^ b;  //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<ul>\n<li><h2 id=\"Assignment-and-Compound-Assignment-Operators\"><a href=\"#Assignment-and-Compound-Assignment-Operators\" class=\"headerlink\" title=\"Assignment and Compound Assignment Operators\"></a>Assignment and Compound Assignment Operators</h2></li>\n</ul>\n<p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<ul>\n<li><h2 id=\"Type-Casting-Operator\"><a href=\"#Type-Casting-Operator\" class=\"headerlink\" title=\"Type Casting Operator\"></a>Type Casting Operator</h2>as</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<ul>\n<li><h2 id=\"Borrowing-and-Dereference-Operators\"><a href=\"#Borrowing-and-Dereference-Operators\" class=\"headerlink\" title=\"Borrowing and Dereference Operators\"></a>Borrowing and Dereference Operators</h2>&amp; &amp;mut *</li>\n</ul>\n<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and <strong>*</strong> operator for <strong>Dereferencing</strong>.</p>\n<blockquote>\n<p>🔎 For more information, refer to <a href=\"c1.ownership.html\">Ownership</a>, <a href=\"c2.borrowing.html\">Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">Lifetimes</a> sections.</p>\n</blockquote>\n"},{"title":"Vectors","_content":"\nIf you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in a dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- A **pointer** to the data\n- **No of elements** currently have(**length**)\n- **Capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 The **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in a dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- A **pointer** to the data\n- **No of elements** currently have(**length**)\n- **Capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 The **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2019-03-19T14:50:39.951Z","updated":"2019-03-19T14:50:39.951Z","path":"docs/b1.vectors.html","comments":1,"layout":"page","_id":"cjtfwbizd000bdwgpouecj1ye","content":"<p>If you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in a dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>A <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>Capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 The <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>If you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in a dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.With new() keyword\nlet mut b = vec![]; //2.Using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //Ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing existing data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; Cannot assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>A <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>Capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 The <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Structs","_content":"\n⭐️ Structs are used to **encapsulate related properties** into one unified data type.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * One or more comma-separated name:value pairs\n  * Brace-enclosed list\n  * Similar to classes \\(without its methods\\) in OOP languages\n  * Because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * One or more comma-separated values\n  * A parenthesized list like tuples\n  * Looks like a named tuples\n\n3. **Unit structs**\n  * A struct with no members at all\n  * It defines a new type but it resembles an empty tuple, \\(\\)\n  * Rarely in use, useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct has only one element, we call it **newtype pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own. But in combination with other features, it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/b2.structs.md","raw":"title: Structs\n---\n\n⭐️ Structs are used to **encapsulate related properties** into one unified data type.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * One or more comma-separated name:value pairs\n  * Brace-enclosed list\n  * Similar to classes \\(without its methods\\) in OOP languages\n  * Because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * One or more comma-separated values\n  * A parenthesized list like tuples\n  * Looks like a named tuples\n\n3. **Unit structs**\n  * A struct with no members at all\n  * It defines a new type but it resembles an empty tuple, \\(\\)\n  * Rarely in use, useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct has only one element, we call it **newtype pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own. But in combination with other features, it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b2.structs.html","comments":1,"layout":"page","_id":"cjtfwbizf000cdwgpzeihnjcl","content":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified data type.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>One or more comma-separated name:value pairs</li>\n<li>Brace-enclosed list</li>\n<li>Similar to classes (without its methods) in OOP languages</li>\n<li>Because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>One or more comma-separated values</li>\n<li>A parenthesized list like tuples</li>\n<li>Looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>A struct with no members at all</li>\n<li>It defines a new type but it resembles an empty tuple, ()</li>\n<li>Rarely in use, useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct has only one element, we call it <strong>newtype pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own. But in combination with other features, it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified data type.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>One or more comma-separated name:value pairs</li>\n<li>Brace-enclosed list</li>\n<li>Similar to classes (without its methods) in OOP languages</li>\n<li>Because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>One or more comma-separated values</li>\n<li>A parenthesized list like tuples</li>\n<li>Looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>A struct with no members at all</li>\n<li>It defines a new type but it resembles an empty tuple, ()</li>\n<li>Rarely in use, useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // Creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // Accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // Structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // Copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // Destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // Creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // Destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct has only one element, we call it <strong>newtype pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color(u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // Creating an instance\n  let black = Color(0, 0, 0);\n\n  // Destructure the instance using a `let` binding, this will not destruct black instance\n  let Color(r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  // Newtype pattern\n  let distance = Kilometers(20);\n  // Destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own. But in combination with other features, it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation, ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* No data (unit variant)\n* Unnamed ordered data (tuple variant)\n* Named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => // Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/b3.enums.md","raw":"title: Enums\n---\n\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation, ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* No data (unit variant)\n* Unnamed ordered data (tuple variant)\n* Named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => // Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b3.enums.html","comments":1,"layout":"page","_id":"cjtfwbizf000ddwgplrmr0p7e","content":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation, ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>No data (unit variant)</li>\n<li>Unnamed ordered data (tuple variant)</li>\n<li>Named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; // Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// The `Day` is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation, ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>No data (unit variant)</li>\n<li>Unnamed ordered data (tuple variant)</li>\n<li>Named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, // A unit variant\n  Warning{ category: i32, message: String }, // A struct variant\n  Error(String) // A tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // Pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; // Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead of x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // Multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// 💭 So, on the above function, instead of setting return type as usize\n//   set return type as Option<usize>\n// Instead of return userId, return Some(userId)\n//   else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n// 💭 Instead of assignee: Person, we use Option<Person>\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  // if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// 💭 On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/b4.generics.md","raw":"title: Generics\n---\n\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead of x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // Multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// 💭 So, on the above function, instead of setting return type as usize\n//   set return type as Option<usize>\n// Instead of return userId, return Some(userId)\n//   else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n// 💭 Instead of assignee: Person, we use Option<Person>\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  // if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// 💭 On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2019-03-19T14:50:39.952Z","updated":"2019-03-19T14:50:39.952Z","path":"docs/b4.generics.html","comments":1,"layout":"page","_id":"cjtfwbizg000edwgpmix13yle","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead of x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // Multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// 💭 So, on the above function, instead of setting return type as usize\n//   set return type as Option&lt;usize&gt;\n// Instead of return userId, return Some(userId)\n//   else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n// 💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  // if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// 💭 On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead of x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // Both x and y has the same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // Multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When adding an implementation for a generic struct, the type parameters should be declared after the impl as well\n//   impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    // if username can be found in the system, set userId\n        return Some(userId);\n    // else\n        None\n}\n\n// 💭 So, on the above function, instead of setting return type as usize\n//   set return type as Option&lt;usize&gt;\n// Instead of return userId, return Some(userId)\n//   else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n// 💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n// because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// When using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  // if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  // else, count and return the word count\n    // let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n// 💭 On the above function,\n// instead panic(break) the app, when the file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Impls & Traits","_content":"\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overridden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types.\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from the struct.\nex. `Person::new(“Elon Musk Jr”);`\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n// Should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overridden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types.\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from the struct.\nex. `Person::new(“Elon Musk Jr”);`\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n// Should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjtfwbizg000fdwgp94t9h4ma","content":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overridden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types.\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from the struct.<br>ex. <code>Person::new(“Elon Musk Jr”);</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n// Should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overridden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types.\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types.\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from the struct.<br>ex. <code>Person::new(“Elon Musk Jr”);</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// We have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here, instead of using new() and full_name() separately as two expressions, \n// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n// Should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { // Employee inherits from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of `a` to `b`** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings is set to **“copied” state**.\n   * **Mostly Primitive types**\n   \n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings is set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**`core::marker::Copy trait`**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to `b` and `a` doesn’t have any ownership to access the resource.**\n","source":"docs/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of `a` to `b`** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings is set to **“copied” state**.\n   * **Mostly Primitive types**\n   \n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings is set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**`core::marker::Copy trait`**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to `b` and `a` doesn’t have any ownership to access the resource.**\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/c1.ownership.html","comments":1,"layout":"page","_id":"cjtfwbizh000gdwgp7hdhtev9","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of <code>a</code> to <code>b</code></strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><p><strong>Copy Type</strong></p>\n<ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings is set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><p><strong>Move type</strong></p>\n<ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings is set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong><code>core::marker::Copy trait</code></strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to <code>b</code> and <code>a</code> doesn’t have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of <code>a</code> to <code>b</code></strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><p><strong>Copy Type</strong></p>\n<ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings is set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><p><strong>Move type</strong></p>\n<ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings is set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong><code>core::marker::Copy trait</code></strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to <code>b</code> and <code>a</code> doesn’t have any ownership to access the resource.</strong></p>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of `a` starts here\n    // any other code\n  }                  //  &mut borrow of `a` ends here\n\n  println!(\"{:?}\", a); // allow borrowing `a` as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of `a` starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of `a` starts here\n    // any other code\n  }                  //  &mut borrow of `a` ends here\n\n  println!(\"{:?}\", a); // allow borrowing `a` as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2019-03-19T14:50:39.953Z","updated":"2019-03-19T14:50:39.953Z","path":"docs/c2.borrowing.html","comments":1,"layout":"page","_id":"cjtfwbizh000hdwgp3yadp9r6","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n    // any other code\n  }                  //  &amp;mut borrow of `a` ends here\n\n  println!(&quot;{:?}&quot;, a); // allow borrowing `a` as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access `a` as a shared borrow, so giving an error\n}                  //  &amp;mut borrow of `a` ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here\n    // any other code\n  }                  //  &amp;mut borrow of `a` ends here\n\n  println!(&quot;{:?}&quot;, a); // allow borrowing `a` as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### [Functions](d2.functions.html)\n\n2. ### [Modules](d3.modules.html)\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### [Crates](d4.crates.html)\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **Path**\n    - **Git repository**\n    - **crates.io**\n    \n4. ### [Workspaces](d5.workspaces.html)\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead of printing the `String` inside the function.","source":"docs/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### [Functions](d2.functions.html)\n\n2. ### [Modules](d3.modules.html)\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### [Crates](d4.crates.html)\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **Path**\n    - **Git repository**\n    - **crates.io**\n    \n4. ### [Workspaces](d5.workspaces.html)\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead of printing the `String` inside the function.","date":"2019-03-19T14:50:39.954Z","updated":"2019-03-19T14:50:39.954Z","path":"docs/d1.code_organization.html","comments":1,"layout":"page","_id":"cjtfwbizi000idwgpb01etu4x","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a><a href=\"d2.functions.html\">Functions</a></h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a><a href=\"d3.modules.html\">Modules</a></h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a><a href=\"d4.crates.html\">Crates</a></h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>Path</strong></li>\n<li><strong>Git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a><a href=\"d5.workspaces.html\">Workspaces</a></h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead of printing the <code>String</code> inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a><a href=\"d2.functions.html\">Functions</a></h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a><a href=\"d3.modules.html\">Modules</a></h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a><a href=\"d4.crates.html\">Crates</a></h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>Path</strong></li>\n<li><strong>Git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a><a href=\"d5.workspaces.html\">Workspaces</a></h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead of printing the <code>String</code> inside the function.</p>\n</blockquote>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2019-03-19T14:50:39.955Z","updated":"2019-03-19T14:50:39.955Z","path":"docs/d2.functions.html","comments":1,"layout":"page","_id":"cjtfwbizj000jdwgp4vmm10iw","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); // Do one thing\n  ask_location(); // Do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // Test attribute indicates this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in the next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In the same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 The `self` keyword is used to refer the same module, while the `super` keyword is used to refer parent module. Also, the `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In a different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In a different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import the `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In the same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 The `self` keyword is used to refer the same module, while the `super` keyword is used to refer parent module. Also, the `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In a different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In a different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ The function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import the `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2019-03-19T14:50:39.955Z","updated":"2019-03-19T14:50:39.955Z","path":"docs/d3.modules.html","comments":1,"layout":"page","_id":"cjtfwbizj000kdwgplfqu4o1n","content":"<h2 id=\"01-In-the-same-file\"><a href=\"#01-In-the-same-file\" class=\"headerlink\" title=\"01. In the same file\"></a>01. In the same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 The <code>self</code> keyword is used to refer the same module, while the <code>super</code> keyword is used to refer parent module. Also, the <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-a-different-file-same-directory\"><a href=\"#02-In-a-different-file-same-directory\" class=\"headerlink\" title=\"02. In a different file, same directory\"></a>02. In a different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-a-different-file-different-directory\"><a href=\"#03-In-a-different-file-different-directory\" class=\"headerlink\" title=\"03. In a different file, different directory\"></a>03. In a different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import the <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"01-In-the-same-file\"><a href=\"#01-In-the-same-file\" class=\"headerlink\" title=\"01. In the same file\"></a>01. In the same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); // Or `self::hello();`\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 The <code>self</code> keyword is used to refer the same module, while the <code>super</code> keyword is used to refer parent module. Also, the <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // Only compiles when running tests\nmod tests {\n    use super::greet; // Import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-a-different-file-same-directory\"><a href=\"#02-In-a-different-file-same-directory\" class=\"headerlink\" title=\"02. In a different file, same directory\"></a>02. In a different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // Import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ No need to wrap the code with a mod declaration. The file itself acts as a module.\npub fn hello() { // The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-a-different-file-different-directory\"><a href=\"#03-In-a-different-file-different-directory\" class=\"headerlink\" title=\"03. In a different file, different directory\"></a>03. In a different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ The function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ The module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import the <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // You can call `hello()` directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Use","_content":"\nLet's see the main usages of the `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So the user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way the `use` keyword is used to import the elements of other crates including the `std`, Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using the `std` library. We will discuss more about this under the Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don’t need to know/follow the whole directory map of the elements of the library while working with them.","source":"docs/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of the `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So the user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way the `use` keyword is used to import the elements of other crates including the `std`, Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using the `std` library. We will discuss more about this under the Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don’t need to know/follow the whole directory map of the elements of the library while working with them.","date":"2019-03-19T14:50:39.957Z","updated":"2019-03-19T14:50:39.957Z","path":"docs/d6.use.html","comments":1,"layout":"page","_id":"cjtfwbizk000ldwgpknshiq1y","content":"<p>Let’s see the main usages of the <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So the user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way the <code>use</code> keyword is used to import the elements of other crates including the <code>std</code>, Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using the <code>std</code> library. We will discuss more about this under the Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don’t need to know/follow the whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Let’s see the main usages of the <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So the user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without the `use` keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // Using full path\n}\n\n\n// -- Usage of the `use` keyword --\n// 01. Create an alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. Create an alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. Customize names with the `as` keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; // Import the `hello()` function into the scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way the <code>use</code> keyword is used to import the elements of other crates including the <code>std</code>, Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. Importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. Importing module and elements --\nstd::fs::{self, File} // `use std::fs; use std::fs::File;`\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. Importing multiple elements --\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using the <code>std</code> library. We will discuss more about this under the Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); // Not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; // Re-export `greetings::hello` to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don’t need to know/follow the whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n ├── Cargo.toml\n ├── examples\n │  └── hello\n │     ├── Cargo.toml\n │     └── src\n │        └── main.rs\n └── lib\n    ├── Cargo.toml\n    └── src\n       └── lib.rs\n```\n\nWe have to modify the following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n ├── Cargo.toml\n ├── examples\n │  └── hello\n │     ├── Cargo.toml\n │     └── src\n │        └── main.rs\n └── lib\n    ├── Cargo.toml\n    └── src\n       └── lib.rs\n```\n\nWe have to modify the following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2019-03-19T14:50:39.956Z","updated":"2019-03-19T14:50:39.956Z","path":"docs/d5.workspaces.html","comments":1,"layout":"page","_id":"cjtfwbizk000mdwgpusva4dhe","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n ├── Cargo.toml\n ├── examples\n │  └── hello\n │     ├── Cargo.toml\n │     └── src\n │        └── main.rs\n └── lib\n    ├── Cargo.toml\n    └── src\n       └── lib.rs\n</code></pre><p>We have to modify the following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n ├── Cargo.toml\n ├── examples\n │  └── hello\n │     ├── Cargo.toml\n │     └── src\n │        └── main.rs\n └── lib\n    ├── Cargo.toml\n    └── src\n       └── lib.rs\n</code></pre><p>We have to modify the following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Panicking","_content":"\n## panic!()\n\n- In some cases, while an error happens we can not do anything to handle it, **if the error is something, which should not be happened**. In other words, if it’s an **unrecoverable error**.\n- Also **when we are not using a feature-rich debugger or proper logs**, sometimes we need to **debug the code by quitting the program from a specific line of code** by printing out a specific message or a value of a variable binding to understand the current flow of the program.\nFor above cases, we can use `panic!` macro.\n\n⭐ `panic!()` runs **thread based**. One thread can be panicked, while other threads are running.\n\n### 01. Quit from a specific line.\n```rust\nfn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:5\n```\n\n### 02. Quit with a custom error message.\n```rust\n#[allow(unused_mut)] // 💡 A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n  \n    if username.is_empty() {\n        panic!(\"Username is empty!\");\n    }\n\n    println!(\"{}\", username);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Username is empty!', src/main.rs:8:9\n```\n\n### 03. Quit with the value of code elements.\n```rust\n#[derive(Debug)] // 💡 A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // 💡 A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n    \n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(\"{:?}\", some_color);\n\n    println!(\n        \"The color = rgb({},{},{})\",\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5\n```\n\nAs you can see in the above examples `panic!()` supports [`println!()` type style arguments](a3.hello_world.html#Usages-of-println). By default, it prints the **error message, file path and line & column numbers** where the error happens.\n\n## unimplemented!()\n\n💡 If your code is having **unfinished code sections**, there is a standardized macro as `unimplemented!()` to mark those routes. The program will be panicked with a **“not yet implemented”** error message, if the program runs through those routes.\n\n```rust\n// error messages with panic!()\nthread 'main' panicked at 'explicit panic', src/main.rs:6:5\nthread 'main' panicked at 'Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread 'main' panicked at 'not yet implemented', src/main.rs:6:5\nthread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n```\n\n## unreachable!()\n\nThis is the standard macro to mark **routes that the program should not enter**. The program will be panicked with a **“'internal error: entered unreachable code'”** error message, if the program entered those routes.\n\n```rust\nfn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 => \"beginner\",\n        6...10 => \"intermediate\",\n        11...20 => \"expert\",\n        _ => unreachable!(),\n    };\n    \n    println!(\"{}\", stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20\n```\n\nWe can set custom error messages for this as well.\n\n```rust\n// --- with a custom message ---\n_ => unreachable!(\"Custom message\"),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20\n\n\n// --- with debug data ---\n_ => unreachable!(\"level is {}\", level),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14\n```\n\n## assert!(), assert_eq!(), assert_ne!()\n\nThese are standard macros which usually use with test assertions.\n\n- `assert!()` ensures that a boolean expression is true. It panics if the expression is false.\n\n```rust\nfn main() {\n    let f = false;\n    \n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: f', src/main.rs:4:5\n```\n\n- `assert_eq!()` ensures that two expressions are equal. It panics if the expressions are not equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`', src/main.rs:5:5\n```\n\n- `assert_ne!()` ensures that two expressions are not equal. It panics if the expressions are equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 10;\n    \n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left != right)`\n  left: `10`,\n right: `10`', src/main.rs:5:5\n```\n\n> ⭐ Expressions which use with `assert_eq!()` and `assert_ne!()` should return same data type.\n\nWe can set custom error messages for these macros as well. For examples,\n\n1. With a custom message for `assert_eq!()`\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b, \"a and b should be equal\");\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal', src/main.rs:5:5\n```\n\n2. `assert_eq!()` with debug data\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n    \n    assert_eq!(a+b, c, \"a = {} ; b = {}\", a, b);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20', src/main.rs:7:5\n```\n\n## debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\n\n🔎 These are similar to above `assert` macros. But these statements are only enabled in non optimized builds by default. All these `debug_assert` macros will be omitted in release builds, unless we pass `-C debug-assertions` to the compiler.\n","source":"docs/e2.panicking.md","raw":"title: Panicking\n---\n\n## panic!()\n\n- In some cases, while an error happens we can not do anything to handle it, **if the error is something, which should not be happened**. In other words, if it’s an **unrecoverable error**.\n- Also **when we are not using a feature-rich debugger or proper logs**, sometimes we need to **debug the code by quitting the program from a specific line of code** by printing out a specific message or a value of a variable binding to understand the current flow of the program.\nFor above cases, we can use `panic!` macro.\n\n⭐ `panic!()` runs **thread based**. One thread can be panicked, while other threads are running.\n\n### 01. Quit from a specific line.\n```rust\nfn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:5\n```\n\n### 02. Quit with a custom error message.\n```rust\n#[allow(unused_mut)] // 💡 A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n  \n    if username.is_empty() {\n        panic!(\"Username is empty!\");\n    }\n\n    println!(\"{}\", username);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Username is empty!', src/main.rs:8:9\n```\n\n### 03. Quit with the value of code elements.\n```rust\n#[derive(Debug)] // 💡 A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // 💡 A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n    \n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(\"{:?}\", some_color);\n\n    println!(\n        \"The color = rgb({},{},{})\",\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5\n```\n\nAs you can see in the above examples `panic!()` supports [`println!()` type style arguments](a3.hello_world.html#Usages-of-println). By default, it prints the **error message, file path and line & column numbers** where the error happens.\n\n## unimplemented!()\n\n💡 If your code is having **unfinished code sections**, there is a standardized macro as `unimplemented!()` to mark those routes. The program will be panicked with a **“not yet implemented”** error message, if the program runs through those routes.\n\n```rust\n// error messages with panic!()\nthread 'main' panicked at 'explicit panic', src/main.rs:6:5\nthread 'main' panicked at 'Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread 'main' panicked at 'not yet implemented', src/main.rs:6:5\nthread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9\nthread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5\n```\n\n## unreachable!()\n\nThis is the standard macro to mark **routes that the program should not enter**. The program will be panicked with a **“'internal error: entered unreachable code'”** error message, if the program entered those routes.\n\n```rust\nfn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 => \"beginner\",\n        6...10 => \"intermediate\",\n        11...20 => \"expert\",\n        _ => unreachable!(),\n    };\n    \n    println!(\"{}\", stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20\n```\n\nWe can set custom error messages for this as well.\n\n```rust\n// --- with a custom message ---\n_ => unreachable!(\"Custom message\"),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20\n\n\n// --- with debug data ---\n_ => unreachable!(\"level is {}\", level),\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14\n```\n\n## assert!(), assert_eq!(), assert_ne!()\n\nThese are standard macros which usually use with test assertions.\n\n- `assert!()` ensures that a boolean expression is true. It panics if the expression is false.\n\n```rust\nfn main() {\n    let f = false;\n    \n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: f', src/main.rs:4:5\n```\n\n- `assert_eq!()` ensures that two expressions are equal. It panics if the expressions are not equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`', src/main.rs:5:5\n```\n\n- `assert_ne!()` ensures that two expressions are not equal. It panics if the expressions are equal.\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 10;\n    \n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left != right)`\n  left: `10`,\n right: `10`', src/main.rs:5:5\n```\n\n> ⭐ Expressions which use with `assert_eq!()` and `assert_ne!()` should return same data type.\n\nWe can set custom error messages for these macros as well. For examples,\n\n1. With a custom message for `assert_eq!()`\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n    \n    assert_eq!(a, b, \"a and b should be equal\");\n}\n\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal', src/main.rs:5:5\n```\n\n2. `assert_eq!()` with debug data\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n    \n    assert_eq!(a+b, c, \"a = {} ; b = {}\", a, b);\n}\n\n// -------------- Compile-time error --------------\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20', src/main.rs:7:5\n```\n\n## debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\n\n🔎 These are similar to above `assert` macros. But these statements are only enabled in non optimized builds by default. All these `debug_assert` macros will be omitted in release builds, unless we pass `-C debug-assertions` to the compiler.\n","date":"2019-03-19T14:50:39.959Z","updated":"2019-03-19T14:50:39.959Z","path":"docs/e2.panicking.html","comments":1,"layout":"page","_id":"cjtfwbizl000ndwgp9vztkoob","content":"<h2 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic!()\"></a>panic!()</h2><ul>\n<li>In some cases, while an error happens we can not do anything to handle it, <strong>if the error is something, which should not be happened</strong>. In other words, if it’s an <strong>unrecoverable error</strong>.</li>\n<li>Also <strong>when we are not using a feature-rich debugger or proper logs</strong>, sometimes we need to <strong>debug the code by quitting the program from a specific line of code</strong> by printing out a specific message or a value of a variable binding to understand the current flow of the program.<br>For above cases, we can use <code>panic!</code> macro.</li>\n</ul>\n<p>⭐ <code>panic!()</code> runs <strong>thread based</strong>. One thread can be panicked, while other threads are running.</p>\n<h3 id=\"01-Quit-from-a-specific-line\"><a href=\"#01-Quit-from-a-specific-line\" class=\"headerlink\" title=\"01. Quit from a specific line.\"></a>01. Quit from a specific line.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:5\n</code></pre>\n<h3 id=\"02-Quit-with-a-custom-error-message\"><a href=\"#02-Quit-with-a-custom-error-message\" class=\"headerlink\" title=\"02. Quit with a custom error message.\"></a>02. Quit with a custom error message.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_mut)] // 💡 A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n\n    if username.is_empty() {\n        panic!(&quot;Username is empty!&quot;);\n    }\n\n    println!(&quot;{}&quot;, username);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:8:9\n</code></pre>\n<h3 id=\"03-Quit-with-the-value-of-code-elements\"><a href=\"#03-Quit-with-the-value-of-code-elements\" class=\"headerlink\" title=\"03. Quit with the value of code elements.\"></a>03. Quit with the value of code elements.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[derive(Debug)] // 💡 A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // 💡 A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n\n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(&quot;{:?}&quot;, some_color);\n\n    println!(\n        &quot;The color = rgb({},{},{})&quot;,\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:16:5\n</code></pre>\n<p>As you can see in the above examples <code>panic!()</code> supports <a href=\"a3.hello_world.html#Usages-of-println\"><code>println!()</code> type style arguments</a>. By default, it prints the <strong>error message, file path and line &amp; column numbers</strong> where the error happens.</p>\n<h2 id=\"unimplemented\"><a href=\"#unimplemented\" class=\"headerlink\" title=\"unimplemented!()\"></a>unimplemented!()</h2><p>💡 If your code is having <strong>unfinished code sections</strong>, there is a standardized macro as <code>unimplemented!()</code> to mark those routes. The program will be panicked with a <strong>“not yet implemented”</strong> error message, if the program runs through those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// error messages with panic!()\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread &#39;main&#39; panicked at &#39;not yet implemented&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;not yet implemented: Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;not yet implemented: Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n</code></pre>\n<h2 id=\"unreachable\"><a href=\"#unreachable\" class=\"headerlink\" title=\"unreachable!()\"></a>unreachable!()</h2><p>This is the standard macro to mark <strong>routes that the program should not enter</strong>. The program will be panicked with a <strong>“’internal error: entered unreachable code’”</strong> error message, if the program entered those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 =&gt; &quot;beginner&quot;,\n        6...10 =&gt; &quot;intermediate&quot;,\n        11...20 =&gt; &quot;expert&quot;,\n        _ =&gt; unreachable!(),\n    };\n\n    println!(&quot;{}&quot;, stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code&#39;, src/main.rs:7:20\n</code></pre>\n<p>We can set custom error messages for this as well.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// --- with a custom message ---\n_ =&gt; unreachable!(&quot;Custom message&quot;),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: Custom message&#39;, src/main.rs:7:20\n\n\n// --- with debug data ---\n_ =&gt; unreachable!(&quot;level is {}&quot;, level),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: level is 22&#39;, src/main.rs:7:14\n</code></pre>\n<h2 id=\"assert-assert-eq-assert-ne\"><a href=\"#assert-assert-eq-assert-ne\" class=\"headerlink\" title=\"assert!(), assert_eq!(), assert_ne!()\"></a>assert!(), assert_eq!(), assert_ne!()</h2><p>These are standard macros which usually use with test assertions.</p>\n<ul>\n<li><code>assert!()</code> ensures that a boolean expression is true. It panics if the expression is false.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let f = false;\n\n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: f&#39;, src/main.rs:4:5\n</code></pre>\n<ul>\n<li><code>assert_eq!()</code> ensures that two expressions are equal. It panics if the expressions are not equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`&#39;, src/main.rs:5:5\n</code></pre>\n<ul>\n<li><code>assert_ne!()</code> ensures that two expressions are not equal. It panics if the expressions are equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 10;\n\n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left != right)`\n  left: `10`,\n right: `10`&#39;, src/main.rs:5:5\n</code></pre>\n<blockquote>\n<p>⭐ Expressions which use with <code>assert_eq!()</code> and <code>assert_ne!()</code> should return same data type.</p>\n</blockquote>\n<p>We can set custom error messages for these macros as well. For examples,</p>\n<ol>\n<li>With a custom message for <code>assert_eq!()</code></li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b, &quot;a and b should be equal&quot;);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal&#39;, src/main.rs:5:5\n</code></pre>\n<ol start=\"2\">\n<li><code>assert_eq!()</code> with debug data</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n\n    assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20&#39;, src/main.rs:7:5\n</code></pre>\n<h2 id=\"debug-assert-debug-assert-eq-debug-assert-ne\"><a href=\"#debug-assert-debug-assert-eq-debug-assert-ne\" class=\"headerlink\" title=\"debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\"></a>debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</h2><p>🔎 These are similar to above <code>assert</code> macros. But these statements are only enabled in non optimized builds by default. All these <code>debug_assert</code> macros will be omitted in release builds, unless we pass <code>-C debug-assertions</code> to the compiler.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"panic\"><a href=\"#panic\" class=\"headerlink\" title=\"panic!()\"></a>panic!()</h2><ul>\n<li>In some cases, while an error happens we can not do anything to handle it, <strong>if the error is something, which should not be happened</strong>. In other words, if it’s an <strong>unrecoverable error</strong>.</li>\n<li>Also <strong>when we are not using a feature-rich debugger or proper logs</strong>, sometimes we need to <strong>debug the code by quitting the program from a specific line of code</strong> by printing out a specific message or a value of a variable binding to understand the current flow of the program.<br>For above cases, we can use <code>panic!</code> macro.</li>\n</ul>\n<p>⭐ <code>panic!()</code> runs <strong>thread based</strong>. One thread can be panicked, while other threads are running.</p>\n<h3 id=\"01-Quit-from-a-specific-line\"><a href=\"#01-Quit-from-a-specific-line\" class=\"headerlink\" title=\"01. Quit from a specific line.\"></a>01. Quit from a specific line.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // some code\n\n    // if we need to debug in here\n    panic!();\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:5\n</code></pre>\n<h3 id=\"02-Quit-with-a-custom-error-message\"><a href=\"#02-Quit-with-a-custom-error-message\" class=\"headerlink\" title=\"02. Quit with a custom error message.\"></a>02. Quit with a custom error message.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_mut)] // 💡 A lint attribute used to suppress the warning; username variable does not need to be mutable\nfn main() {\n    let mut username = String::new();\n\n    // some code to get the name\n\n    if username.is_empty() {\n        panic!(&quot;Username is empty!&quot;);\n    }\n\n    println!(&quot;{}&quot;, username);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:8:9\n</code></pre>\n<h3 id=\"03-Quit-with-the-value-of-code-elements\"><a href=\"#03-Quit-with-the-value-of-code-elements\" class=\"headerlink\" title=\"03. Quit with the value of code elements.\"></a>03. Quit with the value of code elements.</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[derive(Debug)] // 💡 A lint attribute which use to implement `std::fmt::Debug` to Color\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\n#[allow(unreachable_code)] // 💡 A lint attribute used to suppress the warning; unreachable statement\nfn main() {\n    let some_color: Color;\n\n    // some code to get the color. ex\n    some_color = Color {r: 255, g: 255, b: 0};\n\n    // if we need to debug in here\n    panic!(&quot;{:?}&quot;, some_color);\n\n    println!(\n        &quot;The color = rgb({},{},{})&quot;,\n        some_color.r, some_color.g, some_color.b\n    );\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:16:5\n</code></pre>\n<p>As you can see in the above examples <code>panic!()</code> supports <a href=\"a3.hello_world.html#Usages-of-println\"><code>println!()</code> type style arguments</a>. By default, it prints the <strong>error message, file path and line &amp; column numbers</strong> where the error happens.</p>\n<h2 id=\"unimplemented\"><a href=\"#unimplemented\" class=\"headerlink\" title=\"unimplemented!()\"></a>unimplemented!()</h2><p>💡 If your code is having <strong>unfinished code sections</strong>, there is a standardized macro as <code>unimplemented!()</code> to mark those routes. The program will be panicked with a <strong>“not yet implemented”</strong> error message, if the program runs through those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// error messages with panic!()\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n\n// error messages with unimplemented!()\nthread &#39;main&#39; panicked at &#39;not yet implemented&#39;, src/main.rs:6:5\nthread &#39;main&#39; panicked at &#39;not yet implemented: Username is empty!&#39;, src/main.rs:9:9\nthread &#39;main&#39; panicked at &#39;not yet implemented: Color { r: 255, g: 255, b: 0 }&#39;, src/main.rs:17:5\n</code></pre>\n<h2 id=\"unreachable\"><a href=\"#unreachable\" class=\"headerlink\" title=\"unreachable!()\"></a>unreachable!()</h2><p>This is the standard macro to mark <strong>routes that the program should not enter</strong>. The program will be panicked with a <strong>“’internal error: entered unreachable code’”</strong> error message, if the program entered those routes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let level = 22;\n    let stage = match level {\n        1...5 =&gt; &quot;beginner&quot;,\n        6...10 =&gt; &quot;intermediate&quot;,\n        11...20 =&gt; &quot;expert&quot;,\n        _ =&gt; unreachable!(),\n    };\n\n    println!(&quot;{}&quot;, stage);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code&#39;, src/main.rs:7:20\n</code></pre>\n<p>We can set custom error messages for this as well.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// --- with a custom message ---\n_ =&gt; unreachable!(&quot;Custom message&quot;),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: Custom message&#39;, src/main.rs:7:20\n\n\n// --- with debug data ---\n_ =&gt; unreachable!(&quot;level is {}&quot;, level),\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;internal error: entered unreachable code: level is 22&#39;, src/main.rs:7:14\n</code></pre>\n<h2 id=\"assert-assert-eq-assert-ne\"><a href=\"#assert-assert-eq-assert-ne\" class=\"headerlink\" title=\"assert!(), assert_eq!(), assert_ne!()\"></a>assert!(), assert_eq!(), assert_ne!()</h2><p>These are standard macros which usually use with test assertions.</p>\n<ul>\n<li><code>assert!()</code> ensures that a boolean expression is true. It panics if the expression is false.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let f = false;\n\n    assert!(f)\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: f&#39;, src/main.rs:4:5\n</code></pre>\n<ul>\n<li><code>assert_eq!()</code> ensures that two expressions are equal. It panics if the expressions are not equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`&#39;, src/main.rs:5:5\n</code></pre>\n<ul>\n<li><code>assert_ne!()</code> ensures that two expressions are not equal. It panics if the expressions are equal.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 10;\n\n    assert_ne!(a, b);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left != right)`\n  left: `10`,\n right: `10`&#39;, src/main.rs:5:5\n</code></pre>\n<blockquote>\n<p>⭐ Expressions which use with <code>assert_eq!()</code> and <code>assert_ne!()</code> should return same data type.</p>\n</blockquote>\n<p>We can set custom error messages for these macros as well. For examples,</p>\n<ol>\n<li>With a custom message for <code>assert_eq!()</code></li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    assert_eq!(a, b, &quot;a and b should be equal&quot;);\n}\n\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `10`,\n right: `20`: a and b should be equal&#39;, src/main.rs:5:5\n</code></pre>\n<ol start=\"2\">\n<li><code>assert_eq!()</code> with debug data</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = 10;\n    let b = 20;\n\n    let c = 40;\n\n    assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);\n}\n\n// -------------- Compile-time error --------------\nthread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `30`,\n right: `40`: a = 10 ; b = 20&#39;, src/main.rs:7:5\n</code></pre>\n<h2 id=\"debug-assert-debug-assert-eq-debug-assert-ne\"><a href=\"#debug-assert-debug-assert-eq-debug-assert-ne\" class=\"headerlink\" title=\"debug_assert!(), debug_assert_eq!(), debug_assert_ne!()\"></a>debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</h2><p>🔎 These are similar to above <code>assert</code> macros. But these statements are only enabled in non optimized builds by default. All these <code>debug_assert</code> macros will be omitted in release builds, unless we pass <code>-C debug-assertions</code> to the compiler.</p>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)**: Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)**: Defined by both compiler and `std`\n\nThe **`std`** library has been divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements the **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n```\n\n> 🔎 When examining [Rust’s source code](https://github.com/rust-lang/rust), you can see that the [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though it is having many library crates, by examining [root `Cargo.toml`](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of the `std` modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross-platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and everything of `std` library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.[`std::io`](https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs)) and many libraries (ex. [Diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)**: Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)**: Defined by both compiler and `std`\n\nThe **`std`** library has been divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements the **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n```\n\n> 🔎 When examining [Rust’s source code](https://github.com/rust-lang/rust), you can see that the [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though it is having many library crates, by examining [root `Cargo.toml`](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of the `std` modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross-platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and everything of `std` library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.[`std::io`](https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs)) and many libraries (ex. [Diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2019-03-19T14:50:39.957Z","updated":"2019-03-19T14:50:39.957Z","path":"docs/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjtfwbizl000odwgp5eudl57x","content":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong>: Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong>: Defined by both compiler and <code>std</code></li>\n</ul>\n<p>The <strong><code>std</code></strong> library has been divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements the <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examining <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that the <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though it is having many library crates, by examining <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root <code>Cargo.toml</code></a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of the <code>std</code> modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross-platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and everything of <code>std</code> library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.<a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs\" target=\"_blank\" rel=\"noopener\"><code>std::io</code></a>) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324\" target=\"_blank\" rel=\"noopener\">Diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong>: Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong>: Defined by both compiler and <code>std</code></li>\n</ul>\n<p>The <strong><code>std</code></strong> library has been divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements the <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives: Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify // concat_idents: nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local // select: nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap: nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics: nightly-only experimental API\nraw // raw: nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examining <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that the <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though it is having many library crates, by examining <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root <code>Cargo.toml</code></a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of the <code>std</code> modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross-platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and everything of <code>std</code> library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.<a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs\" target=\"_blank\" rel=\"noopener\"><code>std::io</code></a>) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324\" target=\"_blank\" rel=\"noopener\">Diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Smart Compiler","_content":"\n## Why Compiler?\n\nThe Rust compiler does the most significant job to prevent errors in Rust programs. It **analyzes the code at compile-time** and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. \n\nFor example,\n```rust\n#[allow(unused_variables)] //💡 A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(\"{:?}\", a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --> src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(\"{:?}\", a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ⭐ instead using #[allow(unused_variables)], consider using \"let _b = a;\" in line 4. \n// Also you can use \"let _ =\" to completely ignore return values\n```\n\n> 💭 In the previous sections, we have discussed memory management concepts like [ownership](c1.ownership.html), [borrowing](c2.borrowing.html), [lifetimes](c3.lifetimes.md) and etc.\n\nRust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.\n\n```rust\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(\"Yellow = rgb({},{},{})\", yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --> src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n```\n\n## Explain Error Codes\n\nAbove error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, **`rustc --explain`** commands help us **to identify the error type and how to solve** it, by showing **simple code samples** which express the same problem and the solution we have to use. \n\nFor example, `rustc --explain E0571` shows the following output in the console.\n\n```rust\nA `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\n｀｀｀\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\n｀｀｀\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\n｀｀｀\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\n｀｀｀\n```\n\n💡 Also you can read the same explanations via [Rust Compiler Error Index](https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html). For example to check the explanation of `E0571` error, you can use https://doc.rust-lang.org/error-index.html#E0571.\n","source":"docs/e1.smart_compiler.md","raw":"title: Smart Compiler\n---\n\n## Why Compiler?\n\nThe Rust compiler does the most significant job to prevent errors in Rust programs. It **analyzes the code at compile-time** and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. \n\nFor example,\n```rust\n#[allow(unused_variables)] //💡 A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(\"{:?}\", a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --> src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(\"{:?}\", a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ⭐ instead using #[allow(unused_variables)], consider using \"let _b = a;\" in line 4. \n// Also you can use \"let _ =\" to completely ignore return values\n```\n\n> 💭 In the previous sections, we have discussed memory management concepts like [ownership](c1.ownership.html), [borrowing](c2.borrowing.html), [lifetimes](c3.lifetimes.md) and etc.\n\nRust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.\n\n```rust\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(\"Yellow = rgb({},{},{})\", yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --> src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n```\n\n## Explain Error Codes\n\nAbove error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, **`rustc --explain`** commands help us **to identify the error type and how to solve** it, by showing **simple code samples** which express the same problem and the solution we have to use. \n\nFor example, `rustc --explain E0571` shows the following output in the console.\n\n```rust\nA `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\n｀｀｀\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\n｀｀｀\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\n｀｀｀\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\n｀｀｀\n```\n\n💡 Also you can read the same explanations via [Rust Compiler Error Index](https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html). For example to check the explanation of `E0571` error, you can use https://doc.rust-lang.org/error-index.html#E0571.\n","date":"2019-03-19T14:50:39.958Z","updated":"2019-03-19T14:50:39.958Z","path":"docs/e1.smart_compiler.html","comments":1,"layout":"page","_id":"cjtfwbizl000pdwgpux401idd","content":"<h2 id=\"Why-Compiler\"><a href=\"#Why-Compiler\" class=\"headerlink\" title=\"Why Compiler?\"></a>Why Compiler?</h2><p>The Rust compiler does the most significant job to prevent errors in Rust programs. It <strong>analyzes the code at compile-time</strong> and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. </p>\n<p>For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_variables)] //💡 A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(&quot;{:?}&quot;, a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --&gt; src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(&quot;{:?}&quot;, a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ⭐ instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. \n// Also you can use &quot;let _ =&quot; to completely ignore return values\n</code></pre>\n<blockquote>\n<p>💭 In the previous sections, we have discussed memory management concepts like <a href=\"c1.ownership.html\">ownership</a>, <a href=\"c2.borrowing.html\">borrowing</a>, <a href=\"c3.lifetimes.md\">lifetimes</a> and etc.</p>\n</blockquote>\n<p>Rust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --&gt; src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n</code></pre>\n<h2 id=\"Explain-Error-Codes\"><a href=\"#Explain-Error-Codes\" class=\"headerlink\" title=\"Explain Error Codes\"></a>Explain Error Codes</h2><p>Above error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, <strong><code>rustc --explain</code></strong> commands help us <strong>to identify the error type and how to solve</strong> it, by showing <strong>simple code samples</strong> which express the same problem and the solution we have to use. </p>\n<p>For example, <code>rustc --explain E0571</code> shows the following output in the console.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">A `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\n｀｀｀\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\n｀｀｀\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\n｀｀｀\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\n｀｀｀\n</code></pre>\n<p>💡 Also you can read the same explanations via <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html\" target=\"_blank\" rel=\"noopener\">Rust Compiler Error Index</a>. For example to check the explanation of <code>E0571</code> error, you can use <a href=\"https://doc.rust-lang.org/error-index.html#E0571\" target=\"_blank\" rel=\"noopener\">https://doc.rust-lang.org/error-index.html#E0571</a>.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Why-Compiler\"><a href=\"#Why-Compiler\" class=\"headerlink\" title=\"Why Compiler?\"></a>Why Compiler?</h2><p>The Rust compiler does the most significant job to prevent errors in Rust programs. It <strong>analyzes the code at compile-time</strong> and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. </p>\n<p>For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#[allow(unused_variables)] //💡 A lint attribute used to suppress the warning; unused variable: `b`\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n\n    println!(&quot;{:?}&quot;, a);\n}\n\n\n// ------ Compile-time error ------\nerror[E0382]: use of moved value: `a`\n --&gt; src/main.rs:6:22\n  |\n3 |     let b = a;\n  |         - value moved here\n4 |\n5 |     println!(&quot;{:?}&quot;, a);\n  |                      ^ value used here after move\n  |\n  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0382`.\n\n// ⭐ instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. \n// Also you can use &quot;let _ =&quot; to completely ignore return values\n</code></pre>\n<blockquote>\n<p>💭 In the previous sections, we have discussed memory management concepts like <a href=\"c1.ownership.html\">ownership</a>, <a href=\"c2.borrowing.html\">borrowing</a>, <a href=\"c3.lifetimes.md\">lifetimes</a> and etc.</p>\n</blockquote>\n<p>Rust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\nfn main() {\n    let yellow = Color {\n        r: 255,\n        g: 255,\n        d: 0,\n    };\n\n    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);\n}\n\n\n// ------------ Compile-time error ------------\nerror[E0560]: struct `Color` has no field named `d`\n  --&gt; src/main.rs:11:9\n   |\n11 |         d: 0,\n   |         ^ field does not exist - did you mean `b`?\n\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0560`.\n</code></pre>\n<h2 id=\"Explain-Error-Codes\"><a href=\"#Explain-Error-Codes\" class=\"headerlink\" title=\"Explain Error Codes\"></a>Explain Error Codes</h2><p>Above error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, <strong><code>rustc --explain</code></strong> commands help us <strong>to identify the error type and how to solve</strong> it, by showing <strong>simple code samples</strong> which express the same problem and the solution we have to use. </p>\n<p>For example, <code>rustc --explain E0571</code> shows the following output in the console.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">A `break` statement with an argument appeared in a non-`loop` loop.\n\nExample of erroneous code:\n｀｀｀\nlet result = while true {\n    if satisfied(i) {\n        break 2*i; // error: `break` with value from a `while` loop\n    }\n    i += 1;\n};\n｀｀｀\n\nThe `break` statement can take an argument (which will be the value of the loop\nexpression if the `break` statement is executed) in `loop` loops, but not\n`for`, `while`, or `while let` loops.\n\nMake sure `break value;` statements only occur in `loop` loops:\n｀｀｀\nlet result = loop { // ok!\n    if satisfied(i) {\n        break 2*i;\n    }\n    i += 1;\n};\n｀｀｀\n</code></pre>\n<p>💡 Also you can read the same explanations via <a href=\"https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html\" target=\"_blank\" rel=\"noopener\">Rust Compiler Error Index</a>. For example to check the explanation of <code>E0571</code> error, you can use <a href=\"https://doc.rust-lang.org/error-index.html#E0571\" target=\"_blank\" rel=\"noopener\">https://doc.rust-lang.org/error-index.html#E0571</a>.</p>\n"},{"title":"Unwrap and Expect","_content":"\n## unwrap()\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **program panics**; If `Err`, panics with the error message.\n\nThe functionality is bit similar to the following codes, which are using `match` instead `unwrap()`.\n\nExample with `Option` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) => x = v, // if Some(\"abc\"), set x to \"abc\"\n        None => panic!(), // if None, panic without any message\n    }\n\n    println!(\"{}\", x); // \"abc\" ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:17\n```\n\nExample with `Result` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) => x = v, // if Ok(255), set x to 255\n        Err(e) => panic!(e), // if Err(\"some message\"), panic with error message \"some message\"\n    }\n\n    println!(\"{}\", x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'some message', src/main.rs:5:19\n```\n\nSame codes in above `main` functions can be written with `unwrap()` using two lines.\n\n```rust\n// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: \"some message\"', libcore/result.rs:945:5\n```\n\n⭐ But as you can see, when using `unwrap()` error messages are not showing the exact line numbers where the panic happens.\n\n\n## expect()\n\nSimilar to `unwrap()` but can set a custom message for the panics.\n\n```rust\n// 01. expect error message for None\nfn main() {\n    let n: Option<i8> = None;\n    \n    n.expect(\"empty value returned\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'empty value returned', libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result<i8, &str> = Err(\"some message\");\n\n    e.expect(\"expect error message\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'expect error message: \"some message\"', libcore/result.rs:945:5\n```\n\n\n## unwrap_err() and expect_err() for Result types\nThe opposite case of `unwrap()` and `expect()`; Panics with `Ok` values, instead `Err`. Both print the value inside `Ok` on the error message.\n\n💡 Usually use with tests.\n\n```rust\n// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.expect_err(\"Should not get Ok value\");\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5\n```\n\n\n## unwrap_or(), unwrap_or_default() and unwrap_or_else() \n>💡 These are bit similar to `unwrap()`, If an `Option` type has `Some` value or a `Result` type has a `Ok` value, the value inside them passes to the next step. But when having `None` or `Err`, the functionalities are bit different.\n\n- `unwrap_or()` : With `None` or `Err`, **the value you passes to `unwrap_or()`** is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n```\n\n- `unwrap_or_default()` :  With `None` or `Err`, **the default value of the data type of the relevant `Some` or `Ok`**, is passing to the next step.\n\n```rust\nfn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option<i8> = Some(8);\n    let n: Option<i8> = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n```\n\n- `unwrap_or_else()` : Similar to `unwrap_or()`. The only difference is, instead of passing a value, you have to pass a **[closure](a7.functions.html#Closures)** which returns a value with the same data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n```\n","source":"docs/e4.unwrap_and_expect.md","raw":"title: Unwrap and Expect\n---\n\n## unwrap()\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **program panics**; If `Err`, panics with the error message.\n\nThe functionality is bit similar to the following codes, which are using `match` instead `unwrap()`.\n\nExample with `Option` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) => x = v, // if Some(\"abc\"), set x to \"abc\"\n        None => panic!(), // if None, panic without any message\n    }\n\n    println!(\"{}\", x); // \"abc\" ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'explicit panic', src/main.rs:5:17\n```\n\nExample with `Result` and `match`, before using `unwrap()`\n\n```rust\nfn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) => x = v, // if Ok(255), set x to 255\n        Err(e) => panic!(e), // if Err(\"some message\"), panic with error message \"some message\"\n    }\n\n    println!(\"{}\", x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'some message', src/main.rs:5:19\n```\n\nSame codes in above `main` functions can be written with `unwrap()` using two lines.\n\n```rust\n// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(\"{}\", x);\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: \"some message\"', libcore/result.rs:945:5\n```\n\n⭐ But as you can see, when using `unwrap()` error messages are not showing the exact line numbers where the panic happens.\n\n\n## expect()\n\nSimilar to `unwrap()` but can set a custom message for the panics.\n\n```rust\n// 01. expect error message for None\nfn main() {\n    let n: Option<i8> = None;\n    \n    n.expect(\"empty value returned\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'empty value returned', libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result<i8, &str> = Err(\"some message\");\n\n    e.expect(\"expect error message\");\n}\n\n// --------------- Compile-time error ---------------\nthread 'main' panicked at 'expect error message: \"some message\"', libcore/result.rs:945:5\n```\n\n\n## unwrap_err() and expect_err() for Result types\nThe opposite case of `unwrap()` and `expect()`; Panics with `Ok` values, instead `Err`. Both print the value inside `Ok` on the error message.\n\n💡 Usually use with tests.\n\n```rust\n// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n\n    o.expect_err(\"Should not get Ok value\");\n}\n\n// ---------- Compile-time error ----------\nthread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5\n```\n\n\n## unwrap_or(), unwrap_or_default() and unwrap_or_else() \n>💡 These are bit similar to `unwrap()`, If an `Option` type has `Some` value or a `Result` type has a `Ok` value, the value inside them passes to the next step. But when having `None` or `Err`, the functionalities are bit different.\n\n- `unwrap_or()` : With `None` or `Err`, **the value you passes to `unwrap_or()`** is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n```\n\n- `unwrap_or_default()` :  With `None` or `Err`, **the default value of the data type of the relevant `Some` or `Ok`**, is passing to the next step.\n\n```rust\nfn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option<i8> = Some(8);\n    let n: Option<i8> = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n```\n\n- `unwrap_or_else()` : Similar to `unwrap_or()`. The only difference is, instead of passing a value, you have to pass a **[closure](a7.functions.html#Closures)** which returns a value with the same data type of the relevant `Some` or `Ok`.\n\n```rust\nfn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"error\");\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n```\n","date":"2019-03-19T14:50:39.960Z","updated":"2019-03-19T14:50:39.960Z","path":"docs/e4.unwrap_and_expect.html","comments":1,"layout":"page","_id":"cjtfwbizm000qdwgp17msm0jl","content":"<h2 id=\"unwrap\"><a href=\"#unwrap\" class=\"headerlink\" title=\"unwrap()\"></a>unwrap()</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>program panics</strong>; If <code>Err</code>, panics with the error message.</li>\n</ul>\n<p>The functionality is bit similar to the following codes, which are using <code>match</code> instead <code>unwrap()</code>.</p>\n<p>Example with <code>Option</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n        None =&gt; panic!(), // if None, panic without any message\n    }\n\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:17\n</code></pre>\n<p>Example with <code>Result</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) =&gt; x = v, // if Ok(255), set x to 255\n        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;\n    }\n\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;some message&#39;, src/main.rs:5:19\n</code></pre>\n<p>Same codes in above <code>main</code> functions can be written with <code>unwrap()</code> using two lines.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<p>⭐ But as you can see, when using <code>unwrap()</code> error messages are not showing the exact line numbers where the panic happens.</p>\n<h2 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect()\"></a>expect()</h2><p>Similar to <code>unwrap()</code> but can set a custom message for the panics.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. expect error message for None\nfn main() {\n    let n: Option&lt;i8&gt; = None;\n\n    n.expect(&quot;empty value returned&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;empty value returned&#39;, libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);\n\n    e.expect(&quot;expect error message&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;expect error message: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-err-and-expect-err-for-Result-types\"><a href=\"#unwrap-err-and-expect-err-for-Result-types\" class=\"headerlink\" title=\"unwrap_err() and expect_err() for Result types\"></a>unwrap_err() and expect_err() for Result types</h2><p>The opposite case of <code>unwrap()</code> and <code>expect()</code>; Panics with <code>Ok</code> values, instead <code>Err</code>. Both print the value inside <code>Ok</code> on the error message.</p>\n<p>💡 Usually use with tests.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap_err()` on an `Ok` value: 8&#39;, libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.expect_err(&quot;Should not get Ok value&quot;);\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;Should not get Ok value: 8&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-or-unwrap-or-default-and-unwrap-or-else\"><a href=\"#unwrap-or-unwrap-or-default-and-unwrap-or-else\" class=\"headerlink\" title=\"unwrap_or(), unwrap_or_default() and unwrap_or_else()\"></a>unwrap_or(), unwrap_or_default() and unwrap_or_else()</h2><blockquote>\n<p>💡 These are bit similar to <code>unwrap()</code>, If an <code>Option</code> type has <code>Some</code> value or a <code>Result</code> type has a <code>Ok</code> value, the value inside them passes to the next step. But when having <code>None</code> or <code>Err</code>, the functionalities are bit different.</p>\n</blockquote>\n<ul>\n<li><code>unwrap_or()</code> : With <code>None</code> or <code>Err</code>, <strong>the value you passes to <code>unwrap_or()</code></strong> is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_default()</code> :  With <code>None</code> or <code>Err</code>, <strong>the default value of the data type of the relevant <code>Some</code> or <code>Ok</code></strong>, is passing to the next step.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option&lt;i8&gt; = Some(8);\n    let n: Option&lt;i8&gt; = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_else()</code> : Similar to <code>unwrap_or()</code>. The only difference is, instead of passing a value, you have to pass a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns a value with the same data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"unwrap\"><a href=\"#unwrap\" class=\"headerlink\" title=\"unwrap()\"></a>unwrap()</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>program panics</strong>; If <code>Err</code>, panics with the error message.</li>\n</ul>\n<p>The functionality is bit similar to the following codes, which are using <code>match</code> instead <code>unwrap()</code>.</p>\n<p>Example with <code>Option</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match get_an_optional_value() {\n        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n        None =&gt; panic!(), // if None, panic without any message\n    }\n\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;explicit panic&#39;, src/main.rs:5:17\n</code></pre>\n<p>Example with <code>Result</code> and <code>match</code>, before using <code>unwrap()</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x;\n    match function_with_error() {\n        Ok(v) =&gt; x = v, // if Ok(255), set x to 255\n        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;\n    }\n\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;some message&#39;, src/main.rs:5:19\n</code></pre>\n<p>Same codes in above <code>main</code> functions can be written with <code>unwrap()</code> using two lines.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap error message for None\nfn main() {\n    let x = get_an_optional_value().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, libcore/option.rs:345:21\n\n\n// 02. unwrap error message for Err\nfn main() {\n    let x = function_with_error().unwrap();\n\n    println!(&quot;{}&quot;, x);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<p>⭐ But as you can see, when using <code>unwrap()</code> error messages are not showing the exact line numbers where the panic happens.</p>\n<h2 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect()\"></a>expect()</h2><p>Similar to <code>unwrap()</code> but can set a custom message for the panics.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. expect error message for None\nfn main() {\n    let n: Option&lt;i8&gt; = None;\n\n    n.expect(&quot;empty value returned&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;empty value returned&#39;, libcore/option.rs:989:5\n\n\n// 02. expect error message for Err\nfn main() {\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);\n\n    e.expect(&quot;expect error message&quot;);\n}\n\n// --------------- Compile-time error ---------------\nthread &#39;main&#39; panicked at &#39;expect error message: &quot;some message&quot;&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-err-and-expect-err-for-Result-types\"><a href=\"#unwrap-err-and-expect-err-for-Result-types\" class=\"headerlink\" title=\"unwrap_err() and expect_err() for Result types\"></a>unwrap_err() and expect_err() for Result types</h2><p>The opposite case of <code>unwrap()</code> and <code>expect()</code>; Panics with <code>Ok</code> values, instead <code>Err</code>. Both print the value inside <code>Ok</code> on the error message.</p>\n<p>💡 Usually use with tests.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. unwrap_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.unwrap_err();\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;called `Result::unwrap_err()` on an `Ok` value: 8&#39;, libcore/result.rs:945:5\n\n\n// 02. expect_err error message for Ok\nfn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n\n    o.expect_err(&quot;Should not get Ok value&quot;);\n}\n\n// ---------- Compile-time error ----------\nthread &#39;main&#39; panicked at &#39;Should not get Ok value: 8&#39;, libcore/result.rs:945:5\n</code></pre>\n<h2 id=\"unwrap-or-unwrap-or-default-and-unwrap-or-else\"><a href=\"#unwrap-or-unwrap-or-default-and-unwrap-or-else\" class=\"headerlink\" title=\"unwrap_or(), unwrap_or_default() and unwrap_or_else()\"></a>unwrap_or(), unwrap_or_default() and unwrap_or_else()</h2><blockquote>\n<p>💡 These are bit similar to <code>unwrap()</code>, If an <code>Option</code> type has <code>Some</code> value or a <code>Result</code> type has a <code>Ok</code> value, the value inside them passes to the next step. But when having <code>None</code> or <code>Err</code>, the functionalities are bit different.</p>\n</blockquote>\n<ul>\n<li><code>unwrap_or()</code> : With <code>None</code> or <code>Err</code>, <strong>the value you passes to <code>unwrap_or()</code></strong> is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n\n    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1\n    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1\n    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_default()</code> :  With <code>None</code> or <code>Err</code>, <strong>the default value of the data type of the relevant <code>Some</code> or <code>Ok</code></strong>, is passing to the next step.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v = 8;\n    let v_default = 0;\n\n    let s_v: Option&lt;i8&gt; = Some(8);\n    let n: Option&lt;i8&gt; = None;\n\n    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v\n    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v\n\n    let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n\n    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v\n    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v\n}\n</code></pre>\n<ul>\n<li><code>unwrap_or_else()</code> : Similar to <code>unwrap_or()</code>. The only difference is, instead of passing a value, you have to pass a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns a value with the same data type of the relevant <code>Some</code> or <code>Ok</code>.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let v1 = 8;\n    let v2 = 16;\n\n    let s_v1 = Some(8);\n    let n = None;\n    let fn_v2_for_option = || 16;\n\n    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2\n\n    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);\n    let fn_v2_for_result = |_| 16;\n\n    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1\n    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2\n}\n</code></pre>\n"},{"title":"Option and Result","_content":"\n## Why Option and Result?\n\nMany languages use **`null`\\ `nil`\\ `undefined` types** to represent empty outputs, and **`Exceptions`** to handle errors. Rust skips using both, especially to prevent issues like **null pointer exceptions, sensitive data leakages through exceptions** and etc. Instead, Rust provides two special **generic enums**;`Option` and `Result` to deal with above cases.\n\n> 💭 In the previous sections, we have discussed about the basics of [enums](b3.enums.html), [generics](b4.generics.html) and [`Result` & `Option` types](b4.generics.html#Generalizing-enums).\n\nAs you know,\n- An **optional value** can have either **Some** value or no value/ **None**.\n- A **result** can represent either success/ **Ok** or failure/ **Err**\n\n```rust\n// An output can have either Some value or no value/ None.\nenum Option<T> { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n```\n\n💭 Also as we discussed in [preludes](d7.std_primitives_and_preludes.html#Preludes), not only `Option` and `Result`, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.\n\n## Basic usages of Option\n\nWhen writing a function or data type, \n- if an **argument** of the function is optional,\n- If the function is non-void and if the output it **returns** can be empty,\n- If the value, of a **property of the data type** can be empty,\nWe have to use their data type as an `Option` type\n\nFor example, if the function outputs a `&str` value and the output can be empty, the return type of the function should set as `Option<&str>`.\n\n```rust\nfn get_an_optional_value() -> Option<&str> {\n\n    //if the optional value is not empty\n    return Some(\"Some value\");\n    \n    //else\n    None\n}\n```\n\nSame way, if the value of a property of a data type can be empty or optional like the `middle_name` of `Name` data type in the following example, we should set its data type as an `Option` type.\n\n```rust\nstruct Name {\n  first_name: String,\n  middle_name: Option<String>, // middle_name can be empty\n  last_name: String,\n}\n```\n\n💭 As you know, we can use pattern matching to catch the relevant return type (`Some`/ `None`) via `match`. There is a function to get the current user’s home directory in **`std::env`** as **[`home_dir()`](https://doc.rust-lang.org/std/env/fn.home_dir.html)**. Because of all users doesn’t have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an `Option` type; [`Option<PathBuf>`](https://doc.rust-lang.org/std/path/struct.PathBuf.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) => println!(\"{:?}\", p), // This prints \"/root\", if you run this in Rust playground\n        None => println!(\"Can not find the home directory!\"),\n    }\n}\n```\n\n⭐ However, when using optional arguments with functions, we have to pass `None` values for empty arguments while calling the function.\n\n```rust\nfn get_full_name(fname: &str, lname: &str, mname: Option<&str>) -> String { // middle name can be empty\n  match mname {\n    Some(n) => format!(\"{} {} {}\", fname, n, lname),\n    None => format!(\"{} {}\", fname, lname),\n  }\n}\n\nfn main() {\n  println!(\"{}\", get_full_name(\"Galileo\", \"Galilei\", None));\n  println!(\"{}\", get_full_name(\"Leonardo\", \"Vinci\", Some(\"Da\")));\n}\n\n// 💡 Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n```\n\n🔎 Other than that, `Option` types are used with **nullable pointers** in Rust. Because of there is **no null pointers in Rust**, the pointer types should point to a valid location. So if a pointer can be nullable, we have use `Option<Box<T>>` .\n\n## Basic usages of Result\n\nIf a function can produce an error, we have to use a `Result` type by **combining the data type of the valid output and the data type of the error**. For example, if the data type of the valid output is `u64` and error type is `String`, return type should be `Result<u64, String>`.\n\n```rust\nfn function_with_error() -> Result<u64, String> {\n  \n    //if error happens\n    return Err(\"The error message\".to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n💭 As you know, we can use the pattern matching to catch the relevant return types (`Ok`/`Err`) via `match`. There is a function to fetch the value of any environment variable in **`std::env`** as **[`var()`](https://doc.rust-lang.org/std/env/fn.var.html)** . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a `Result` type; [`Result<String, VarError>`](https://doc.rust-lang.org/std/env/enum.VarError.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let key = \"HOME\";\n    match env::var(key) {\n        Ok(v) => println!(\"{}\", v), // This prints \"/root\", if you run this in Rust playground\n        Err(e) => println!(\"{}\", e), // This prints \"environment variable not found\", if you give a nonexistent environment variable\n    }\n}\n```\n\n## is_some(), is_none(), is_ok(), is_err()\n\nOther than `match` expressions, Rust provides `is_some()` , `is_none()` and `is_ok()` , `is_err()` functions to identify the return type.\n\n```rust\nfn main() {\n    let x: Option<&str> = Some(\"Hello, world!\");\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result<i8, &str> = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n```\n\n## ok(), err() for Result types\n\nIn addition to that Rust provides `ok()` and `err()` for `Result` types. They convert the `Ok<T>` and `Err<E>` values of a **`Result` type to `Option` types**.\n\n```rust\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"message\");\n    \n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n    \n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(\"message\")); // Err(v) err = Some(v)\n}\n```","source":"docs/e3.option_and_result.md","raw":"title: Option and Result\n---\n\n## Why Option and Result?\n\nMany languages use **`null`\\ `nil`\\ `undefined` types** to represent empty outputs, and **`Exceptions`** to handle errors. Rust skips using both, especially to prevent issues like **null pointer exceptions, sensitive data leakages through exceptions** and etc. Instead, Rust provides two special **generic enums**;`Option` and `Result` to deal with above cases.\n\n> 💭 In the previous sections, we have discussed about the basics of [enums](b3.enums.html), [generics](b4.generics.html) and [`Result` & `Option` types](b4.generics.html#Generalizing-enums).\n\nAs you know,\n- An **optional value** can have either **Some** value or no value/ **None**.\n- A **result** can represent either success/ **Ok** or failure/ **Err**\n\n```rust\n// An output can have either Some value or no value/ None.\nenum Option<T> { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n```\n\n💭 Also as we discussed in [preludes](d7.std_primitives_and_preludes.html#Preludes), not only `Option` and `Result`, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.\n\n## Basic usages of Option\n\nWhen writing a function or data type, \n- if an **argument** of the function is optional,\n- If the function is non-void and if the output it **returns** can be empty,\n- If the value, of a **property of the data type** can be empty,\nWe have to use their data type as an `Option` type\n\nFor example, if the function outputs a `&str` value and the output can be empty, the return type of the function should set as `Option<&str>`.\n\n```rust\nfn get_an_optional_value() -> Option<&str> {\n\n    //if the optional value is not empty\n    return Some(\"Some value\");\n    \n    //else\n    None\n}\n```\n\nSame way, if the value of a property of a data type can be empty or optional like the `middle_name` of `Name` data type in the following example, we should set its data type as an `Option` type.\n\n```rust\nstruct Name {\n  first_name: String,\n  middle_name: Option<String>, // middle_name can be empty\n  last_name: String,\n}\n```\n\n💭 As you know, we can use pattern matching to catch the relevant return type (`Some`/ `None`) via `match`. There is a function to get the current user’s home directory in **`std::env`** as **[`home_dir()`](https://doc.rust-lang.org/std/env/fn.home_dir.html)**. Because of all users doesn’t have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an `Option` type; [`Option<PathBuf>`](https://doc.rust-lang.org/std/path/struct.PathBuf.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) => println!(\"{:?}\", p), // This prints \"/root\", if you run this in Rust playground\n        None => println!(\"Can not find the home directory!\"),\n    }\n}\n```\n\n⭐ However, when using optional arguments with functions, we have to pass `None` values for empty arguments while calling the function.\n\n```rust\nfn get_full_name(fname: &str, lname: &str, mname: Option<&str>) -> String { // middle name can be empty\n  match mname {\n    Some(n) => format!(\"{} {} {}\", fname, n, lname),\n    None => format!(\"{} {}\", fname, lname),\n  }\n}\n\nfn main() {\n  println!(\"{}\", get_full_name(\"Galileo\", \"Galilei\", None));\n  println!(\"{}\", get_full_name(\"Leonardo\", \"Vinci\", Some(\"Da\")));\n}\n\n// 💡 Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n```\n\n🔎 Other than that, `Option` types are used with **nullable pointers** in Rust. Because of there is **no null pointers in Rust**, the pointer types should point to a valid location. So if a pointer can be nullable, we have use `Option<Box<T>>` .\n\n## Basic usages of Result\n\nIf a function can produce an error, we have to use a `Result` type by **combining the data type of the valid output and the data type of the error**. For example, if the data type of the valid output is `u64` and error type is `String`, return type should be `Result<u64, String>`.\n\n```rust\nfn function_with_error() -> Result<u64, String> {\n  \n    //if error happens\n    return Err(\"The error message\".to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n💭 As you know, we can use the pattern matching to catch the relevant return types (`Ok`/`Err`) via `match`. There is a function to fetch the value of any environment variable in **`std::env`** as **[`var()`](https://doc.rust-lang.org/std/env/fn.var.html)** . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a `Result` type; [`Result<String, VarError>`](https://doc.rust-lang.org/std/env/enum.VarError.html).\n\n```rust\nuse std::env;\n\nfn main() {\n    let key = \"HOME\";\n    match env::var(key) {\n        Ok(v) => println!(\"{}\", v), // This prints \"/root\", if you run this in Rust playground\n        Err(e) => println!(\"{}\", e), // This prints \"environment variable not found\", if you give a nonexistent environment variable\n    }\n}\n```\n\n## is_some(), is_none(), is_ok(), is_err()\n\nOther than `match` expressions, Rust provides `is_some()` , `is_none()` and `is_ok()` , `is_err()` functions to identify the return type.\n\n```rust\nfn main() {\n    let x: Option<&str> = Some(\"Hello, world!\");\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result<i8, &str> = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n```\n\n## ok(), err() for Result types\n\nIn addition to that Rust provides `ok()` and `err()` for `Result` types. They convert the `Ok<T>` and `Err<E>` values of a **`Result` type to `Option` types**.\n\n```rust\nfn main() {\n    let o: Result<i8, &str> = Ok(8);\n    let e: Result<i8, &str> = Err(\"message\");\n    \n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n    \n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(\"message\")); // Err(v) err = Some(v)\n}\n```","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e3.option_and_result.html","comments":1,"layout":"page","_id":"cjtfwbizm000rdwgpyer7yyvd","content":"<h2 id=\"Why-Option-and-Result\"><a href=\"#Why-Option-and-Result\" class=\"headerlink\" title=\"Why Option and Result?\"></a>Why Option and Result?</h2><p>Many languages use <strong><code>null</code>\\ <code>nil</code>\\ <code>undefined</code> types</strong> to represent empty outputs, and <strong><code>Exceptions</code></strong> to handle errors. Rust skips using both, especially to prevent issues like <strong>null pointer exceptions, sensitive data leakages through exceptions</strong> and etc. Instead, Rust provides two special <strong>generic enums</strong>;<code>Option</code> and <code>Result</code> to deal with above cases.</p>\n<blockquote>\n<p>💭 In the previous sections, we have discussed about the basics of <a href=\"b3.enums.html\">enums</a>, <a href=\"b4.generics.html\">generics</a> and <a href=\"b4.generics.html#Generalizing-enums\"><code>Result</code> &amp; <code>Option</code> types</a>.</p>\n</blockquote>\n<p>As you know,</p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// An output can have either Some value or no value/ None.\nenum Option&lt;T&gt; { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<p>💭 Also as we discussed in <a href=\"d7.std_primitives_and_preludes.html#Preludes\">preludes</a>, not only <code>Option</code> and <code>Result</code>, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.</p>\n<h2 id=\"Basic-usages-of-Option\"><a href=\"#Basic-usages-of-Option\" class=\"headerlink\" title=\"Basic usages of Option\"></a>Basic usages of Option</h2><p>When writing a function or data type, </p>\n<ul>\n<li>if an <strong>argument</strong> of the function is optional,</li>\n<li>If the function is non-void and if the output it <strong>returns</strong> can be empty,</li>\n<li>If the value, of a <strong>property of the data type</strong> can be empty,<br>We have to use their data type as an <code>Option</code> type</li>\n</ul>\n<p>For example, if the function outputs a <code>&amp;str</code> value and the output can be empty, the return type of the function should set as <code>Option&lt;&amp;str&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {\n\n    //if the optional value is not empty\n    return Some(&quot;Some value&quot;);\n\n    //else\n    None\n}\n</code></pre>\n<p>Same way, if the value of a property of a data type can be empty or optional like the <code>middle_name</code> of <code>Name</code> data type in the following example, we should set its data type as an <code>Option</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Name {\n  first_name: String,\n  middle_name: Option&lt;String&gt;, // middle_name can be empty\n  last_name: String,\n}\n</code></pre>\n<p>💭 As you know, we can use pattern matching to catch the relevant return type (<code>Some</code>/ <code>None</code>) via <code>match</code>. There is a function to get the current user’s home directory in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.home_dir.html\" target=\"_blank\" rel=\"noopener\"><code>home_dir()</code></a></strong>. Because of all users doesn’t have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an <code>Option</code> type; <a href=\"https://doc.rust-lang.org/std/path/struct.PathBuf.html\" target=\"_blank\" rel=\"noopener\"><code>Option&lt;PathBuf&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground\n        None =&gt; println!(&quot;Can not find the home directory!&quot;),\n    }\n}\n</code></pre>\n<p>⭐ However, when using optional arguments with functions, we have to pass <code>None</code> values for empty arguments while calling the function.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty\n  match mname {\n    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),\n    None =&gt; format!(&quot;{} {}&quot;, fname, lname),\n  }\n}\n\nfn main() {\n  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));\n  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));\n}\n\n// 💡 Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n</code></pre>\n<p>🔎 Other than that, <code>Option</code> types are used with <strong>nullable pointers</strong> in Rust. Because of there is <strong>no null pointers in Rust</strong>, the pointer types should point to a valid location. So if a pointer can be nullable, we have use <code>Option&lt;Box&lt;T&gt;&gt;</code> .</p>\n<h2 id=\"Basic-usages-of-Result\"><a href=\"#Basic-usages-of-Result\" class=\"headerlink\" title=\"Basic usages of Result\"></a>Basic usages of Result</h2><p>If a function can produce an error, we have to use a <code>Result</code> type by <strong>combining the data type of the valid output and the data type of the error</strong>. For example, if the data type of the valid output is <code>u64</code> and error type is <code>String</code>, return type should be <code>Result&lt;u64, String&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn function_with_error() -&gt; Result&lt;u64, String&gt; {\n\n    //if error happens\n    return Err(&quot;The error message&quot;.to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<p>💭 As you know, we can use the pattern matching to catch the relevant return types (<code>Ok</code>/<code>Err</code>) via <code>match</code>. There is a function to fetch the value of any environment variable in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.var.html\" target=\"_blank\" rel=\"noopener\"><code>var()</code></a></strong> . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a <code>Result</code> type; <a href=\"https://doc.rust-lang.org/std/env/enum.VarError.html\" target=\"_blank\" rel=\"noopener\"><code>Result&lt;String, VarError&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let key = &quot;HOME&quot;;\n    match env::var(key) {\n        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground\n        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable\n    }\n}\n</code></pre>\n<h2 id=\"is-some-is-none-is-ok-is-err\"><a href=\"#is-some-is-none-is-ok-is-err\" class=\"headerlink\" title=\"is_some(), is_none(), is_ok(), is_err()\"></a>is_some(), is_none(), is_ok(), is_err()</h2><p>Other than <code>match</code> expressions, Rust provides <code>is_some()</code> , <code>is_none()</code> and <code>is_ok()</code> , <code>is_err()</code> functions to identify the return type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result&lt;i8, &amp;str&gt; = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n</code></pre>\n<h2 id=\"ok-err-for-Result-types\"><a href=\"#ok-err-for-Result-types\" class=\"headerlink\" title=\"ok(), err() for Result types\"></a>ok(), err() for Result types</h2><p>In addition to that Rust provides <code>ok()</code> and <code>err()</code> for <code>Result</code> types. They convert the <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code> values of a <strong><code>Result</code> type to <code>Option</code> types</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);\n\n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n\n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Why-Option-and-Result\"><a href=\"#Why-Option-and-Result\" class=\"headerlink\" title=\"Why Option and Result?\"></a>Why Option and Result?</h2><p>Many languages use <strong><code>null</code>\\ <code>nil</code>\\ <code>undefined</code> types</strong> to represent empty outputs, and <strong><code>Exceptions</code></strong> to handle errors. Rust skips using both, especially to prevent issues like <strong>null pointer exceptions, sensitive data leakages through exceptions</strong> and etc. Instead, Rust provides two special <strong>generic enums</strong>;<code>Option</code> and <code>Result</code> to deal with above cases.</p>\n<blockquote>\n<p>💭 In the previous sections, we have discussed about the basics of <a href=\"b3.enums.html\">enums</a>, <a href=\"b4.generics.html\">generics</a> and <a href=\"b4.generics.html#Generalizing-enums\"><code>Result</code> &amp; <code>Option</code> types</a>.</p>\n</blockquote>\n<p>As you know,</p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// An output can have either Some value or no value/ None.\nenum Option&lt;T&gt; { // T is a generic and it can contain any type of value.\n    Some(T),\n    None,\n}\n\n// A result can represent either success/ Ok or failure/ Err.\nenum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<p>💭 Also as we discussed in <a href=\"d7.std_primitives_and_preludes.html#Preludes\">preludes</a>, not only <code>Option</code> and <code>Result</code>, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.</p>\n<h2 id=\"Basic-usages-of-Option\"><a href=\"#Basic-usages-of-Option\" class=\"headerlink\" title=\"Basic usages of Option\"></a>Basic usages of Option</h2><p>When writing a function or data type, </p>\n<ul>\n<li>if an <strong>argument</strong> of the function is optional,</li>\n<li>If the function is non-void and if the output it <strong>returns</strong> can be empty,</li>\n<li>If the value, of a <strong>property of the data type</strong> can be empty,<br>We have to use their data type as an <code>Option</code> type</li>\n</ul>\n<p>For example, if the function outputs a <code>&amp;str</code> value and the output can be empty, the return type of the function should set as <code>Option&lt;&amp;str&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {\n\n    //if the optional value is not empty\n    return Some(&quot;Some value&quot;);\n\n    //else\n    None\n}\n</code></pre>\n<p>Same way, if the value of a property of a data type can be empty or optional like the <code>middle_name</code> of <code>Name</code> data type in the following example, we should set its data type as an <code>Option</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Name {\n  first_name: String,\n  middle_name: Option&lt;String&gt;, // middle_name can be empty\n  last_name: String,\n}\n</code></pre>\n<p>💭 As you know, we can use pattern matching to catch the relevant return type (<code>Some</code>/ <code>None</code>) via <code>match</code>. There is a function to get the current user’s home directory in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.home_dir.html\" target=\"_blank\" rel=\"noopener\"><code>home_dir()</code></a></strong>. Because of all users doesn’t have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an <code>Option</code> type; <a href=\"https://doc.rust-lang.org/std/path/struct.PathBuf.html\" target=\"_blank\" rel=\"noopener\"><code>Option&lt;PathBuf&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let home_path = env::home_dir();\n    match home_path {\n        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground\n        None =&gt; println!(&quot;Can not find the home directory!&quot;),\n    }\n}\n</code></pre>\n<p>⭐ However, when using optional arguments with functions, we have to pass <code>None</code> values for empty arguments while calling the function.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty\n  match mname {\n    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),\n    None =&gt; format!(&quot;{} {}&quot;, fname, lname),\n  }\n}\n\nfn main() {\n  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));\n  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));\n}\n\n// 💡 Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()\n</code></pre>\n<p>🔎 Other than that, <code>Option</code> types are used with <strong>nullable pointers</strong> in Rust. Because of there is <strong>no null pointers in Rust</strong>, the pointer types should point to a valid location. So if a pointer can be nullable, we have use <code>Option&lt;Box&lt;T&gt;&gt;</code> .</p>\n<h2 id=\"Basic-usages-of-Result\"><a href=\"#Basic-usages-of-Result\" class=\"headerlink\" title=\"Basic usages of Result\"></a>Basic usages of Result</h2><p>If a function can produce an error, we have to use a <code>Result</code> type by <strong>combining the data type of the valid output and the data type of the error</strong>. For example, if the data type of the valid output is <code>u64</code> and error type is <code>String</code>, return type should be <code>Result&lt;u64, String&gt;</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn function_with_error() -&gt; Result&lt;u64, String&gt; {\n\n    //if error happens\n    return Err(&quot;The error message&quot;.to_string());\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<p>💭 As you know, we can use the pattern matching to catch the relevant return types (<code>Ok</code>/<code>Err</code>) via <code>match</code>. There is a function to fetch the value of any environment variable in <strong><code>std::env</code></strong> as <strong><a href=\"https://doc.rust-lang.org/std/env/fn.var.html\" target=\"_blank\" rel=\"noopener\"><code>var()</code></a></strong> . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a <code>Result</code> type; <a href=\"https://doc.rust-lang.org/std/env/enum.VarError.html\" target=\"_blank\" rel=\"noopener\"><code>Result&lt;String, VarError&gt;</code></a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::env;\n\nfn main() {\n    let key = &quot;HOME&quot;;\n    match env::var(key) {\n        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground\n        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable\n    }\n}\n</code></pre>\n<h2 id=\"is-some-is-none-is-ok-is-err\"><a href=\"#is-some-is-none-is-ok-is-err\" class=\"headerlink\" title=\"is_some(), is_none(), is_ok(), is_err()\"></a>is_some(), is_none(), is_ok(), is_err()</h2><p>Other than <code>match</code> expressions, Rust provides <code>is_some()</code> , <code>is_none()</code> and <code>is_ok()</code> , <code>is_err()</code> functions to identify the return type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);\n    assert_eq!(x.is_some(), true);\n    assert_eq!(x.is_none(), false);\n\n    let y: Result&lt;i8, &amp;str&gt; = Ok(10);\n    assert_eq!(y.is_ok(), true);\n    assert_eq!(y.is_err(), false);\n}\n</code></pre>\n<h2 id=\"ok-err-for-Result-types\"><a href=\"#ok-err-for-Result-types\" class=\"headerlink\" title=\"ok(), err() for Result types\"></a>ok(), err() for Result types</h2><p>In addition to that Rust provides <code>ok()</code> and <code>err()</code> for <code>Result</code> types. They convert the <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code> values of a <strong><code>Result</code> type to <code>Option</code> types</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o: Result&lt;i8, &amp;str&gt; = Ok(8);\n    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);\n\n    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)\n    assert_eq!(e.ok(), None);    // Err(v) ok = None\n\n    assert_eq!(o.err(), None);            // Ok(v) err = None\n    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)\n}\n</code></pre>\n"},{"title":"Error and None Propagation","_content":"\nWe should use panics like `panic!()`, `unwrap()`, `expect()` only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either `None` or `Err`, \n- we can handle them inside the same function. Or,\n- we can return `None` and `Err` types immediately to the caller. So the caller can decide how to handle them.\n\n💡 `None` types no need to handle by the caller of the function always. But Rusts’ convention to handle **`Err`** types is, **return them immediately to the caller to give more control to the caller to decide how to handle them.**\n\n## ? Operator\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **return them immediately** to the caller of the function.\n\nExample with `Option` type,\n\n```rust\nfn main() {\n    if complex_function().is_none() {\n        println!(\"X not exists!\");\n    }\n}\n\nfn complex_function() -> Option<&'static str> {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(\"abc\"), set x to \"abc\"\n\n    // some other code, ex\n    println!(\"{}\", x); // \"abc\" ; if you change line 19 `false` to `true` \n\n    Some(\"\")\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n```\n\nExample with `Result` Type,\n\n```rust\nfn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(\"Can not calculate X!\");\n    }\n}\n\nfn complex_function() -> Result<u64, String> {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(\"{}\", x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n## try!()\n\n⭐ `?` operator was added in Rust version 1.13. `try!()` macro is the old way to propagate errors before that. So we **should avoid** using this now.\n\n- If a `Result` type has **`Ok`** value, **the value inside it** passes to the next step. If it has **`Err`** value, **returns it immediately** to the caller of the function.\n\n```rust\n// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n```\n\n## Error propagation from main()\n\nBefore Rust version 1.26, we couldn't propagate `Result` and `Option` types from the `main()` function. But now, we **can propagate `Result` types** from the `main()` function and it prints the **`Debug` representation of the `Err`**.\n\n💡 We are going to discuss about `Debug` representations under [Error trait section](e7.custom_error_types.html#Error-trait).\n\n```rust\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let _ = File::open(\"not-existing-file.txt\")?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: \"No such file or directory\" })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\n> 💯 If you want to know about the all kind of errors `std::fs::File::open()` can produce, check the [error list on `std::fs::OpenOptions`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors).","source":"docs/e5.error_and_none_propagation.md","raw":"title: Error and None Propagation\n---\n\nWe should use panics like `panic!()`, `unwrap()`, `expect()` only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either `None` or `Err`, \n- we can handle them inside the same function. Or,\n- we can return `None` and `Err` types immediately to the caller. So the caller can decide how to handle them.\n\n💡 `None` types no need to handle by the caller of the function always. But Rusts’ convention to handle **`Err`** types is, **return them immediately to the caller to give more control to the caller to decide how to handle them.**\n\n## ? Operator\n\n- If an `Option` type has **`Some`** value or a `Result` type has a **`Ok`** value, **the value inside them** passes to the next step.\n- If the `Option` type has **`None`** value or the `Result` type has **`Err`** value, **return them immediately** to the caller of the function.\n\nExample with `Option` type,\n\n```rust\nfn main() {\n    if complex_function().is_none() {\n        println!(\"X not exists!\");\n    }\n}\n\nfn complex_function() -> Option<&'static str> {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(\"abc\"), set x to \"abc\"\n\n    // some other code, ex\n    println!(\"{}\", x); // \"abc\" ; if you change line 19 `false` to `true` \n\n    Some(\"\")\n}\n\nfn get_an_optional_value() -> Option<&'static str> {\n\n    //if the optional value is not empty\n    if false {\n        return Some(\"abc\");\n    }\n    \n    //else\n    None\n}\n```\n\nExample with `Result` Type,\n\n```rust\nfn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(\"Can not calculate X!\");\n    }\n}\n\nfn complex_function() -> Result<u64, String> {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(\"{}\", x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -> Result<u64, String> {\n    //if error happens\n    if true {\n        return Err(\"some message\".to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n```\n\n## try!()\n\n⭐ `?` operator was added in Rust version 1.13. `try!()` macro is the old way to propagate errors before that. So we **should avoid** using this now.\n\n- If a `Result` type has **`Ok`** value, **the value inside it** passes to the next step. If it has **`Err`** value, **returns it immediately** to the caller of the function.\n\n```rust\n// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n```\n\n## Error propagation from main()\n\nBefore Rust version 1.26, we couldn't propagate `Result` and `Option` types from the `main()` function. But now, we **can propagate `Result` types** from the `main()` function and it prints the **`Debug` representation of the `Err`**.\n\n💡 We are going to discuss about `Debug` representations under [Error trait section](e7.custom_error_types.html#Error-trait).\n\n```rust\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let _ = File::open(\"not-existing-file.txt\")?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: \"No such file or directory\" })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\n> 💯 If you want to know about the all kind of errors `std::fs::File::open()` can produce, check the [error list on `std::fs::OpenOptions`](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors).","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e5.error_and_none_propagation.html","comments":1,"layout":"page","_id":"cjtfwbizm000sdwgpq2sxyzp9","content":"<p>We should use panics like <code>panic!()</code>, <code>unwrap()</code>, <code>expect()</code> only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either <code>None</code> or <code>Err</code>, </p>\n<ul>\n<li>we can handle them inside the same function. Or,</li>\n<li>we can return <code>None</code> and <code>Err</code> types immediately to the caller. So the caller can decide how to handle them.</li>\n</ul>\n<p>💡 <code>None</code> types no need to handle by the caller of the function always. But Rusts’ convention to handle <strong><code>Err</code></strong> types is, <strong>return them immediately to the caller to give more control to the caller to decide how to handle them.</strong></p>\n<h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"? Operator\"></a>? Operator</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>return them immediately</strong> to the caller of the function.</li>\n</ul>\n<p>Example with <code>Option</code> type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    if complex_function().is_none() {\n        println!(&quot;X not exists!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Option&lt;&amp;&#39;static str&gt; {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` \n\n    Some(&quot;&quot;)\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n</code></pre>\n<p>Example with <code>Result</code> Type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(&quot;Can not calculate X!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Result&lt;u64, String&gt; {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<h2 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try!()\"></a>try!()</h2><p>⭐ <code>?</code> operator was added in Rust version 1.13. <code>try!()</code> macro is the old way to propagate errors before that. So we <strong>should avoid</strong> using this now.</p>\n<ul>\n<li>If a <code>Result</code> type has <strong><code>Ok</code></strong> value, <strong>the value inside it</strong> passes to the next step. If it has <strong><code>Err</code></strong> value, <strong>returns it immediately</strong> to the caller of the function.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n</code></pre>\n<h2 id=\"Error-propagation-from-main\"><a href=\"#Error-propagation-from-main\" class=\"headerlink\" title=\"Error propagation from main()\"></a>Error propagation from main()</h2><p>Before Rust version 1.26, we couldn’t propagate <code>Result</code> and <code>Option</code> types from the <code>main()</code> function. But now, we <strong>can propagate <code>Result</code> types</strong> from the <code>main()</code> function and it prints the <strong><code>Debug</code> representation of the <code>Err</code></strong>.</p>\n<p>💡 We are going to discuss about <code>Debug</code> representations under <a href=\"e7.custom_error_types.html#Error-trait\">Error trait section</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\n\nfn main() -&gt; std::io::Result&lt;()&gt; {\n    let _ = File::open(&quot;not-existing-file.txt&quot;)?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }\n</code></pre>\n<blockquote>\n<p>💯 If you want to know about the all kind of errors <code>std::fs::File::open()</code> can produce, check the <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors\" target=\"_blank\" rel=\"noopener\">error list on <code>std::fs::OpenOptions</code></a>.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>We should use panics like <code>panic!()</code>, <code>unwrap()</code>, <code>expect()</code> only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either <code>None</code> or <code>Err</code>, </p>\n<ul>\n<li>we can handle them inside the same function. Or,</li>\n<li>we can return <code>None</code> and <code>Err</code> types immediately to the caller. So the caller can decide how to handle them.</li>\n</ul>\n<p>💡 <code>None</code> types no need to handle by the caller of the function always. But Rusts’ convention to handle <strong><code>Err</code></strong> types is, <strong>return them immediately to the caller to give more control to the caller to decide how to handle them.</strong></p>\n<h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"? Operator\"></a>? Operator</h2><ul>\n<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>\n<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>return them immediately</strong> to the caller of the function.</li>\n</ul>\n<p>Example with <code>Option</code> type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    if complex_function().is_none() {\n        println!(&quot;X not exists!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Option&lt;&amp;&#39;static str&gt; {\n    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` \n\n    Some(&quot;&quot;)\n}\n\nfn get_an_optional_value() -&gt; Option&lt;&amp;&#39;static str&gt; {\n\n    //if the optional value is not empty\n    if false {\n        return Some(&quot;abc&quot;);\n    }\n\n    //else\n    None\n}\n</code></pre>\n<p>Example with <code>Result</code> Type,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // `main` function is the caller of `complex_function` function\n    // So we handle errors of complex_function(), inside main()\n    if complex_function().is_err() {\n        println!(&quot;Can not calculate X!&quot;);\n    }\n}\n\nfn complex_function() -&gt; Result&lt;u64, String&gt; {\n    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n    // some other code, ex\n    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`\n\n    Ok(0)\n}\n\nfn function_with_error() -&gt; Result&lt;u64, String&gt; {\n    //if error happens\n    if true {\n        return Err(&quot;some message&quot;.to_string());\n    }\n\n    // else, return valid output\n    Ok(255)\n}\n</code></pre>\n<h2 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try!()\"></a>try!()</h2><p>⭐ <code>?</code> operator was added in Rust version 1.13. <code>try!()</code> macro is the old way to propagate errors before that. So we <strong>should avoid</strong> using this now.</p>\n<ul>\n<li>If a <code>Result</code> type has <strong><code>Ok</code></strong> value, <strong>the value inside it</strong> passes to the next step. If it has <strong><code>Err</code></strong> value, <strong>returns it immediately</strong> to the caller of the function.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// using `?`\nlet x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255\n\n// using `try!()`\nlet x = try!(function_with_error());\n</code></pre>\n<h2 id=\"Error-propagation-from-main\"><a href=\"#Error-propagation-from-main\" class=\"headerlink\" title=\"Error propagation from main()\"></a>Error propagation from main()</h2><p>Before Rust version 1.26, we couldn’t propagate <code>Result</code> and <code>Option</code> types from the <code>main()</code> function. But now, we <strong>can propagate <code>Result</code> types</strong> from the <code>main()</code> function and it prints the <strong><code>Debug</code> representation of the <code>Err</code></strong>.</p>\n<p>💡 We are going to discuss about <code>Debug</code> representations under <a href=\"e7.custom_error_types.html#Error-trait\">Error trait section</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\n\nfn main() -&gt; std::io::Result&lt;()&gt; {\n    let _ = File::open(&quot;not-existing-file.txt&quot;)?;\n\n    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()\n}\n\n// Because of the program can not find not-existing-file.txt , it produces,\n//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })\n// While propagating error, the program prints,\n//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }\n</code></pre>\n<blockquote>\n<p>💯 If you want to know about the all kind of errors <code>std::fs::File::open()</code> can produce, check the <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors\" target=\"_blank\" rel=\"noopener\">error list on <code>std::fs::OpenOptions</code></a>.</p>\n</blockquote>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.\n\nThink,\n\n* We have a **variable binding**, `a`.\n* We are **referencing** the value of `a`, **from another variable binding** `x`.\n  We have to make sure that **`a` lives until we stop using `x`**.\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n\n## What is Lifetime?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ But because of lifetime annotations make the **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason for **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually**, Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after the `&` sign.\n  ex. `..(x: &'a str)` , `..(x: &'a mut str)`\n\n* After the function name, we should mention that the given lifetimes are generic types.\n  ex. `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// No inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// Single input\nfn function<'a>(x: &'a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// Multiple inputs, inputs can have different lifetimes 🔎\n// The output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after the `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // No need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future, it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // Only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // An fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; // A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; // a: &'static str\n\n\nfn index() -> &'static str { // No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n\n## Few more examples about the usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { // No need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.\n\nThink,\n\n* We have a **variable binding**, `a`.\n* We are **referencing** the value of `a`, **from another variable binding** `x`.\n  We have to make sure that **`a` lives until we stop using `x`**.\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n\n## What is Lifetime?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ But because of lifetime annotations make the **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason for **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually**, Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after the `&` sign.\n  ex. `..(x: &'a str)` , `..(x: &'a mut str)`\n\n* After the function name, we should mention that the given lifetimes are generic types.\n  ex. `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// No inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// Single input\nfn function<'a>(x: &'a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// Multiple inputs, inputs can have different lifetimes 🔎\n// The output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after the `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // No need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future, it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // Only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // An fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; // A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; // a: &'static str\n\n\nfn index() -> &'static str { // No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n\n## Few more examples about the usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { // No need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2019-03-19T14:50:39.954Z","updated":"2019-03-19T14:50:39.954Z","path":"docs/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjtfwbizz000tdwgp24fqpt4a","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a <strong>variable binding</strong>, <code>a</code>.</li>\n<li>We are <strong>referencing</strong> the value of <code>a</code>, <strong>from another variable binding</strong> <code>x</code>.<br>We have to make sure that <strong><code>a</code> lives until we stop using <code>x</code></strong>.</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetime\"><a href=\"#What-is-Lifetime\" class=\"headerlink\" title=\"What is Lifetime?\"></a>What is Lifetime?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason for <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong>, Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li><p>Input and output parameters with references should attach lifetimes after the <code>&amp;</code> sign.<br>ex. <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></p>\n</li>\n<li><p>After the function name, we should mention that the given lifetimes are generic types.<br>ex. <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// No inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// Single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, inputs can have different lifetimes 🔎\n// The output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after the <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future, it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // Only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // An fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; // A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; // a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { // No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-the-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-the-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about the usage of Rust lifetimes.\"></a>Few more examples about the usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a <strong>variable binding</strong>, <code>a</code>.</li>\n<li>We are <strong>referencing</strong> the value of <code>a</code>, <strong>from another variable binding</strong> <code>x</code>.<br>We have to make sure that <strong><code>a</code> lives until we stop using <code>x</code></strong>.</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetime\"><a href=\"#What-is-Lifetime\" class=\"headerlink\" title=\"What is Lifetime?\"></a>What is Lifetime?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason for <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong>, Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li><p>Input and output parameters with references should attach lifetimes after the <code>&amp;</code> sign.<br>ex. <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></p>\n</li>\n<li><p>After the function name, we should mention that the given lifetimes are generic types.<br>ex. <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></p>\n</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// No inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// Single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// Single input and output, both have the same lifetime\n// The output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, only one input and the output share same lifetime\n// The output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, both inputs and the output share same lifetime\n// The output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// Multiple inputs, inputs can have different lifetimes 🔎\n// The output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after the <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Single element\n// Data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// Multiple elements\n// Data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// Variant with a single element\n// Data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future, it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { // Only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // Only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { // Only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // An fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; // A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; // a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { // No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-the-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-the-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about the usage of Rust lifetimes.\"></a>Few more examples about the usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { // No need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Crates","_content":"\n💭 Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs`. This pattern is quite common on executable crates.\n\n```rust\n// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns `Hello, world!` String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ├── Cargo.toml\n └── src\n    ├── greetings.rs\n    ├── lib.rs\n    └── main.rs\n   \n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ Import `greetings` module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ├── Cargo.toml\n ├── greetings\n │  ├── Cargo.toml\n │  └── src\n │     └── lib.rs\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ├── Cargo.toml\n └── src\n    └── lib.rs\n   \n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to `Cargo.toml`. Otherwise, we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from another crate**.\n\n```rust\n// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on [crates.io](https://crates.io/). So we have to add only the crate name and a version string to **`Cargo.toml`** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/d4.crates.md","raw":"title: Crates\n---\n\n💭 Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs`. This pattern is quite common on executable crates.\n\n```rust\n// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns `Hello, world!` String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ├── Cargo.toml\n └── src\n    ├── greetings.rs\n    ├── lib.rs\n    └── main.rs\n   \n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ Import `greetings` module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ├── Cargo.toml\n ├── greetings\n │  ├── Cargo.toml\n │  └── src\n │     └── lib.rs\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ├── Cargo.toml\n └── src\n    └── lib.rs\n   \n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to `Cargo.toml`. Otherwise, we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from another crate**.\n\n```rust\n// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on [crates.io](https://crates.io/). So we have to add only the crate name and a version string to **`Cargo.toml`** and then run `cargo build` to fetch the dependencies and compile them.","date":"2019-03-19T14:50:39.956Z","updated":"2019-03-19T14:50:39.956Z","path":"docs/d4.crates.html","comments":1,"layout":"page","_id":"cjtfwbizz000udwgpeo7tcss8","content":"<p>💭 Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code>. This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns `Hello, world!` String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ├── Cargo.toml\n └── src\n    ├── greetings.rs\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ Import `greetings` module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ├── Cargo.toml\n ├── greetings\n │  ├── Cargo.toml\n │  └── src\n │     └── lib.rs\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ├── Cargo.toml\n └── src\n    └── lib.rs\n\n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to <code>Cargo.toml</code>. Otherwise, we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. So we have to add only the crate name and a version string to <strong><code>Cargo.toml</code></strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>💭 Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code>. This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns `Hello, world!` String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for `hello()`\n#[test] // Indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for `hello()`, Idiomatic way\n#[cfg(test)] // Only compiles when running tests\nmod tests { // Separates tests from code\n  use super::hello; // Import root `hello()` function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\nphrases\n ├── Cargo.toml\n └── src\n    ├── greetings.rs\n    ├── lib.rs\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ Import `greetings` module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\nphrases\n ├── Cargo.toml\n ├── greetings\n │  ├── Cargo.toml\n │  └── src\n │     └── lib.rs\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new test_crate_hello_world --lib\n\n// # It generates,\ntest_crate_hello_world\n ├── Cargo.toml\n └── src\n    └── lib.rs\n\n// # Think we modify following files,\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; `Hello, world!`\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to <code>Cargo.toml</code>. Otherwise, we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run,\ncargo new greetings\n\n// # It generates,\ngreetings\n ├── Cargo.toml\n └── src\n    └── main.rs\n\n// # Think we modify following files,\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>. So we have to add only the crate name and a version string to <strong><code>Cargo.toml</code></strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"},{"title":"Combinators","_content":"\n## What is a combinator?\n\n- One meaning of “combinator” is a more informal sense referring to the **combinator pattern**, a style of organizing libraries centered around the idea of combining things. Usually there is **some type T**, some **functions for constructing “primitive” values of type T**, and some “**combinators**” which can **combine values of type T** in various ways to **build up more complex values of type T**. The other definition is **\"function with no free variables\"**.\n__ [wiki.haskell.org](https://wiki.haskell.org/Combinator)\n\n- A combinator is **a function** which **builds program fragments from program fragments**; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. \n__ John Hughes—[Generalizing Monads to Arrows](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) via [Functional Programming Concepts](https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org)\n\nThe exact definition of \"combinators\" in Rust ecosystem is bit unclear. \n\n- `or()`, `and()`, `or_else()`, `and_then()` \n  ▸ **Combine two values of type T** and **return same type T**.\n\n- `filter()` for `Option` types\n  ▸ **Filter type T** by using a closure as a conditional function\n  ▸ **Return same type T**\n  \n- `map()`, `map_err()` \n  ▸ **Convert type T by applying a closure**. \n  ▸ The **data type of the value inside T can be changed**. \n  ex. `Some<&str>` can be converted to `Some<usize>` or `Err<&str>` to `Err<isize>` and etc.\n\n- `map_or()`, `map_or_else()`\n  ▸ **Transform type T by applying a closure** & **return the value inside type T**.\n  ▸ For **`None` and `Err`, a default value or another closure** is applied.\n\n- `ok_or()`, `ok_or_else()` for `Option` types\n  ▸ **Transform `Option` type into a `Result` type**.\n\n- `as_ref()`, `as_mut()` \n  ▸ **Transform type T into a reference or a mutable reference**.\n\n## or() and and()\n\nWhile combining two expressions, which return either `Option`/ `Result`\n- `or()`: If either one got `Some` or `Ok`, that value returns immediately.\n- `and()`: If both got `Some` or `Ok`, the value in the second expression returns. If either one got `None` or `Err` that value returns immediately.\n\n```rust\nfn main() {\n  let s1 = Some(\"some1\");\n  let s2 = Some(\"some2\");\n  let n: Option<&str> = None;\n\n  let o1: Result<&str, &str> = Ok(\"ok1\");\n  let o2: Result<&str, &str> = Ok(\"ok2\");\n  let e1: Result<&str, &str> = Err(\"error1\");\n  let e2: Result<&str, &str> = Err(\"error2\");\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n  \n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n```\n\n> 🔎 Rust nightly support [`xor()`](https://doc.rust-lang.org/std/option/enum.Option.html#method.xor) for `Option` types, which returns `Some` only if one expression got `Some`, but not both.\n\n## or_else()\n\nSimilar to `or()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // or_else with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = || Some(\"some2\"); // similar to: let fn_some = || -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n```\n\n## and_then()\n\nSimilar to `and()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // and_then with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = |_| Some(\"some2\"); // similar to: let fn_some = |_| -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n```\n\n## filter()\n\n> 💡 Usually in programming languages `filter` functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides [`filter()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `filter()` with `Option` types.\n\nThe same `Some` type is returned, only if we pass a `Some` value and the given closure returned true for it. `None` is returned, if `None` type passed or the closure returned false. The closure uses the value inside `Some` as an argument. Still Rust support `filter()` only for `Option` types.\n\n```rust\nfn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -> 3 is not even -> None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -> 6 is even -> Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -> no value -> None\n}\n```\n\n## map() and map_err()\n\n>💡 Usually in programming languages `map()` functions are used with arrays or iterators, **to apply a closure on each element** of the array or iterator. Rust also provides [`map()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `map()` with `Option` and `Result` types. \n\n- `map()` : Convert type T by applying a closure. **The data type of `Some` or `Ok` blocks can be changed** according to the return type of the closure. Convert `Option<T>` to `Option<U>`, `Result<T, E>` to `Result<U, E>`\n\n⭐ Via `map()`, only `Some` and `Ok` values are getting changed. No affect to the values inside `Err` (`None` doesn’t contain any value at all).\n\n```rust\nfn main() {\n    let s1 = Some(\"abcde\");\n    let s2 = Some(5);\n\n    let n1: Option<&str> = None;\n    let n2: Option<usize> = None;\n\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<usize, &str> = Ok(5);\n    \n    let e1: Result<&str, &str> = Err(\"abcde\");\n    let e2: Result<usize, &str> = Err(\"abcde\");\n    \n    let fn_character_count = |s: &str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n- `map_err()` for `Result` types : **The data type of `Err` blocks can be changed** according to the return type of the closure. Convert `Result<T, E>` to `Result<T, F>`.\n\n⭐ Via `map_err()`, only `Err` values are getting changed. No affect to the values inside `Ok`.\n\n```rust\nfn main() {\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<&str, isize> = Ok(\"abcde\");\n\n    let e1: Result<&str, &str> = Err(\"404\");\n    let e2: Result<&str, isize> = Err(404);\n\n    let fn_character_count = |s: &str| -> isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n## map_or() and map_or_else()\n\nHope you remember the functionality of [`unwrap_or()` and `unwrap_or_else()`](e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else) functions. These functions also bit similar to them. But `map_or()` and `map_or_else()` apply a closure on `Some` and `Ok` values and **return the value inside type T**.\n\n- `map_or()` : Support only for `Option` types (not supporting `Result`). Apply the closure to the value inside `Some` and return the output according to the closure. The given default value is returned for `None` types.\n\n```rust\nfn main() {\n    const V_DEFAULT: i8 = 1;\n    \n    let s = Some(10);\n    let n: Option<i8> = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n```\n\n- `map_or_else()` : Support for both `Option` and `Result` types (`Result` still nightly only). Similar to `map_or()` but should provide another closure instead a default value for the first parameter.\n\n⭐ `None` types doesn’t contain any value. So no need to pass anything to the closure as input with `Option` types. But `Err` types contain some value inside it. So default closure should able to read it as an input, while using this with `Result` types.\n\n```rust\n#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option<i8> = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n```\n\n## ok_or() and ok_or_else()\n\nAs mentioned earlier, `ok_or()`, `ok_or_else()` transform `Option` type into `Result` type. **`Some` to `Ok` and `None` to `Err`**.\n\n- `ok_or()` : A default `Err` message should pass as argument.\n\n```rust\nfn main() {\n    const ERR_DEFAULT: &str = \"error message\";\n\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -> Err(default)\n}\n```\n\n- `ok_or_else()` : Similar to `ok_or()`. A closure should be passed as the argument.\n\n```rust\nfn main() {\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n    let fn_err_message = || \"error message\";\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(\"error message\");\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -> Err(default)\n}\n```\n\n## as_ref() and as_mut()\n\n🔎 As mentioned earlier, these functions are used to **borrow type T as a reference or as a mutable reference**.\n\n- `as_ref()` : Convert `Option<T>` to `Option<&T>` and `Result<T, E>` to `Result<&T, &E>` \n- `as_mut()` : Converts `Option<T>` to `Option<&mut T>` and `Result<T, E>` to `Result<&mut T, &mut E>`\n","source":"docs/e6.combinators.md","raw":"title: Combinators\n---\n\n## What is a combinator?\n\n- One meaning of “combinator” is a more informal sense referring to the **combinator pattern**, a style of organizing libraries centered around the idea of combining things. Usually there is **some type T**, some **functions for constructing “primitive” values of type T**, and some “**combinators**” which can **combine values of type T** in various ways to **build up more complex values of type T**. The other definition is **\"function with no free variables\"**.\n__ [wiki.haskell.org](https://wiki.haskell.org/Combinator)\n\n- A combinator is **a function** which **builds program fragments from program fragments**; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. \n__ John Hughes—[Generalizing Monads to Arrows](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) via [Functional Programming Concepts](https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org)\n\nThe exact definition of \"combinators\" in Rust ecosystem is bit unclear. \n\n- `or()`, `and()`, `or_else()`, `and_then()` \n  ▸ **Combine two values of type T** and **return same type T**.\n\n- `filter()` for `Option` types\n  ▸ **Filter type T** by using a closure as a conditional function\n  ▸ **Return same type T**\n  \n- `map()`, `map_err()` \n  ▸ **Convert type T by applying a closure**. \n  ▸ The **data type of the value inside T can be changed**. \n  ex. `Some<&str>` can be converted to `Some<usize>` or `Err<&str>` to `Err<isize>` and etc.\n\n- `map_or()`, `map_or_else()`\n  ▸ **Transform type T by applying a closure** & **return the value inside type T**.\n  ▸ For **`None` and `Err`, a default value or another closure** is applied.\n\n- `ok_or()`, `ok_or_else()` for `Option` types\n  ▸ **Transform `Option` type into a `Result` type**.\n\n- `as_ref()`, `as_mut()` \n  ▸ **Transform type T into a reference or a mutable reference**.\n\n## or() and and()\n\nWhile combining two expressions, which return either `Option`/ `Result`\n- `or()`: If either one got `Some` or `Ok`, that value returns immediately.\n- `and()`: If both got `Some` or `Ok`, the value in the second expression returns. If either one got `None` or `Err` that value returns immediately.\n\n```rust\nfn main() {\n  let s1 = Some(\"some1\");\n  let s2 = Some(\"some2\");\n  let n: Option<&str> = None;\n\n  let o1: Result<&str, &str> = Ok(\"ok1\");\n  let o2: Result<&str, &str> = Ok(\"ok2\");\n  let e1: Result<&str, &str> = Err(\"error1\");\n  let e2: Result<&str, &str> = Err(\"error2\");\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n  \n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n```\n\n> 🔎 Rust nightly support [`xor()`](https://doc.rust-lang.org/std/option/enum.Option.html#method.xor) for `Option` types, which returns `Some` only if one expression got `Some`, but not both.\n\n## or_else()\n\nSimilar to `or()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // or_else with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = || Some(\"some2\"); // similar to: let fn_some = || -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n```\n\n## and_then()\n\nSimilar to `and()`. The only difference is, the second expression should be a **[closure](a7.functions.html#Closures)** which returns same type T.\n\n```rust\nfn main() {\n    // and_then with Option\n    let s1 = Some(\"some1\");\n    let s2 = Some(\"some2\");\n    let fn_some = |_| Some(\"some2\"); // similar to: let fn_some = |_| -> Option<&str> { Some(\"some2\") };\n\n    let n: Option<&str> = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result<&str, &str> = Ok(\"ok1\");\n    let o2: Result<&str, &str> = Ok(\"ok2\");\n    let fn_ok = |_| Ok(\"ok2\"); // similar to: let fn_ok = |_| -> Result<&str, &str> { Ok(\"ok2\") };\n\n    let e1: Result<&str, &str> = Err(\"error1\");\n    let e2: Result<&str, &str> = Err(\"error2\");\n    let fn_err = |_| Err(\"error2\");\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n```\n\n## filter()\n\n> 💡 Usually in programming languages `filter` functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides [`filter()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `filter()` with `Option` types.\n\nThe same `Some` type is returned, only if we pass a `Some` value and the given closure returned true for it. `None` is returned, if `None` type passed or the closure returned false. The closure uses the value inside `Some` as an argument. Still Rust support `filter()` only for `Option` types.\n\n```rust\nfn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -> 3 is not even -> None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -> 6 is even -> Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -> no value -> None\n}\n```\n\n## map() and map_err()\n\n>💡 Usually in programming languages `map()` functions are used with arrays or iterators, **to apply a closure on each element** of the array or iterator. Rust also provides [`map()` **as an iterator adaptor**](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map) to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of `map()` with `Option` and `Result` types. \n\n- `map()` : Convert type T by applying a closure. **The data type of `Some` or `Ok` blocks can be changed** according to the return type of the closure. Convert `Option<T>` to `Option<U>`, `Result<T, E>` to `Result<U, E>`\n\n⭐ Via `map()`, only `Some` and `Ok` values are getting changed. No affect to the values inside `Err` (`None` doesn’t contain any value at all).\n\n```rust\nfn main() {\n    let s1 = Some(\"abcde\");\n    let s2 = Some(5);\n\n    let n1: Option<&str> = None;\n    let n2: Option<usize> = None;\n\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<usize, &str> = Ok(5);\n    \n    let e1: Result<&str, &str> = Err(\"abcde\");\n    let e2: Result<usize, &str> = Err(\"abcde\");\n    \n    let fn_character_count = |s: &str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n- `map_err()` for `Result` types : **The data type of `Err` blocks can be changed** according to the return type of the closure. Convert `Result<T, E>` to `Result<T, F>`.\n\n⭐ Via `map_err()`, only `Err` values are getting changed. No affect to the values inside `Ok`.\n\n```rust\nfn main() {\n    let o1: Result<&str, &str> = Ok(\"abcde\");\n    let o2: Result<&str, isize> = Ok(\"abcde\");\n\n    let e1: Result<&str, &str> = Err(\"404\");\n    let e2: Result<&str, isize> = Err(404);\n\n    let fn_character_count = |s: &str| -> isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n```\n\n## map_or() and map_or_else()\n\nHope you remember the functionality of [`unwrap_or()` and `unwrap_or_else()`](e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else) functions. These functions also bit similar to them. But `map_or()` and `map_or_else()` apply a closure on `Some` and `Ok` values and **return the value inside type T**.\n\n- `map_or()` : Support only for `Option` types (not supporting `Result`). Apply the closure to the value inside `Some` and return the output according to the closure. The given default value is returned for `None` types.\n\n```rust\nfn main() {\n    const V_DEFAULT: i8 = 1;\n    \n    let s = Some(10);\n    let n: Option<i8> = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n```\n\n- `map_or_else()` : Support for both `Option` and `Result` types (`Result` still nightly only). Similar to `map_or()` but should provide another closure instead a default value for the first parameter.\n\n⭐ `None` types doesn’t contain any value. So no need to pass anything to the closure as input with `Option` types. But `Err` types contain some value inside it. So default closure should able to read it as an input, while using this with `Result` types.\n\n```rust\n#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option<i8> = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n```\n\n## ok_or() and ok_or_else()\n\nAs mentioned earlier, `ok_or()`, `ok_or_else()` transform `Option` type into `Result` type. **`Some` to `Ok` and `None` to `Err`**.\n\n- `ok_or()` : A default `Err` message should pass as argument.\n\n```rust\nfn main() {\n    const ERR_DEFAULT: &str = \"error message\";\n\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -> Err(default)\n}\n```\n\n- `ok_or_else()` : Similar to `ok_or()`. A closure should be passed as the argument.\n\n```rust\nfn main() {\n    let s = Some(\"abcde\");\n    let n: Option<&str> = None;\n    let fn_err_message = || \"error message\";\n\n    let o: Result<&str, &str> = Ok(\"abcde\");\n    let e: Result<&str, &str> = Err(\"error message\");\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -> Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -> Err(default)\n}\n```\n\n## as_ref() and as_mut()\n\n🔎 As mentioned earlier, these functions are used to **borrow type T as a reference or as a mutable reference**.\n\n- `as_ref()` : Convert `Option<T>` to `Option<&T>` and `Result<T, E>` to `Result<&T, &E>` \n- `as_mut()` : Converts `Option<T>` to `Option<&mut T>` and `Result<T, E>` to `Result<&mut T, &mut E>`\n","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e6.combinators.html","comments":1,"layout":"page","_id":"cjtfwbj00000vdwgpg6c74wnn","content":"<h2 id=\"What-is-a-combinator\"><a href=\"#What-is-a-combinator\" class=\"headerlink\" title=\"What is a combinator?\"></a>What is a combinator?</h2><ul>\n<li><p>One meaning of “combinator” is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing “primitive” values of type T</strong>, and some “<strong>combinators</strong>” which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>“function with no free variables”</strong>.<br>__ <a href=\"https://wiki.haskell.org/Combinator\" target=\"_blank\" rel=\"noopener\">wiki.haskell.org</a></p>\n</li>\n<li><p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand.<br>__ John Hughes—<a href=\"http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf\" target=\"_blank\" rel=\"noopener\">Generalizing Monads to Arrows</a> via <a href=\"https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org\" target=\"_blank\" rel=\"noopener\">Functional Programming Concepts</a></p>\n</li>\n</ul>\n<p>The exact definition of “combinators” in Rust ecosystem is bit unclear. </p>\n<ul>\n<li><p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code><br>▸ <strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</p>\n</li>\n<li><p><code>filter()</code> for <code>Option</code> types<br>▸ <strong>Filter type T</strong> by using a closure as a conditional function<br>▸ <strong>Return same type T</strong></p>\n</li>\n<li><p><code>map()</code>, <code>map_err()</code><br>▸ <strong>Convert type T by applying a closure</strong>.<br>▸ The <strong>data type of the value inside T can be changed</strong>.<br>ex. <code>Some&lt;&amp;str&gt;</code> can be converted to <code>Some&lt;usize&gt;</code> or <code>Err&lt;&amp;str&gt;</code> to <code>Err&lt;isize&gt;</code> and etc.</p>\n</li>\n<li><p><code>map_or()</code>, <code>map_or_else()</code><br>▸ <strong>Transform type T by applying a closure</strong> &amp; <strong>return the value inside type T</strong>.<br>▸ For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</p>\n</li>\n<li><p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types<br>▸ <strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</p>\n</li>\n<li><p><code>as_ref()</code>, <code>as_mut()</code><br>▸ <strong>Transform type T into a reference or a mutable reference</strong>.</p>\n</li>\n</ul>\n<h2 id=\"or-and-and\"><a href=\"#or-and-and\" class=\"headerlink\" title=\"or() and and()\"></a>or() and and()</h2><p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p>\n<ul>\n<li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li>\n<li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let s1 = Some(&quot;some1&quot;);\n  let s2 = Some(&quot;some2&quot;);\n  let n: Option&lt;&amp;str&gt; = None;\n\n  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n\n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n</code></pre>\n<blockquote>\n<p>🔎 Rust nightly support <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\" target=\"_blank\" rel=\"noopener\"><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p>\n</blockquote>\n<h2 id=\"or-else\"><a href=\"#or-else\" class=\"headerlink\" title=\"or_else()\"></a>or_else()</h2><p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // or_else with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n</code></pre>\n<h2 id=\"and-then\"><a href=\"#and-then\" class=\"headerlink\" title=\"and_then()\"></a>and_then()</h2><p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // and_then with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n</code></pre>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><blockquote>\n<p>💡 Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter\" target=\"_blank\" rel=\"noopener\"><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p>\n</blockquote>\n<p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &amp;i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None\n}\n</code></pre>\n<h2 id=\"map-and-map-err\"><a href=\"#map-and-map-err\" class=\"headerlink\" title=\"map() and map_err()\"></a>map() and map_err()</h2><blockquote>\n<p>💡 Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\" target=\"_blank\" rel=\"noopener\"><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types. </p>\n</blockquote>\n<ul>\n<li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code>, <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code></li>\n</ul>\n<p>⭐ Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn’t contain any value at all).</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(&quot;abcde&quot;);\n    let s2 = Some(5);\n\n    let n1: Option&lt;&amp;str&gt; = None;\n    let n2: Option&lt;usize&gt; = None;\n\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);\n    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);\n\n    let fn_character_count = |s: &amp;str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<ul>\n<li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code>.</li>\n</ul>\n<p>⭐ Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);\n    let e2: Result&lt;&amp;str, isize&gt; = Err(404);\n\n    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<h2 id=\"map-or-and-map-or-else\"><a href=\"#map-or-and-map-or-else\" class=\"headerlink\" title=\"map_or() and map_or_else()\"></a>map_or() and map_or_else()</h2><p>Hope you remember the functionality of <a href=\"e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else\"><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p>\n<ul>\n<li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const V_DEFAULT: i8 = 1;\n\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n</code></pre>\n<ul>\n<li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li>\n</ul>\n<p>⭐ <code>None</code> types doesn’t contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#![feature(result_map_or_else)] // enable unstable library feature &#39;result_map_or_else&#39; on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn&#39;t contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n</code></pre>\n<h2 id=\"ok-or-and-ok-or-else\"><a href=\"#ok-or-and-ok-or-else\" class=\"headerlink\" title=\"ok_or() and ok_or_else()\"></a>ok_or() and ok_or_else()</h2><p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p>\n<ul>\n<li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;\n\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)\n}\n</code></pre>\n<ul>\n<li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_err_message = || &quot;error message&quot;;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)\n}\n</code></pre>\n<h2 id=\"as-ref-and-as-mut\"><a href=\"#as-ref-and-as-mut\" class=\"headerlink\" title=\"as_ref() and as_mut()\"></a>as_ref() and as_mut()</h2><p>🔎 As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p>\n<ul>\n<li><code>as_ref()</code> : Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code> </li>\n<li><code>as_mut()</code> : Converts <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"What-is-a-combinator\"><a href=\"#What-is-a-combinator\" class=\"headerlink\" title=\"What is a combinator?\"></a>What is a combinator?</h2><ul>\n<li><p>One meaning of “combinator” is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing “primitive” values of type T</strong>, and some “<strong>combinators</strong>” which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>“function with no free variables”</strong>.<br>__ <a href=\"https://wiki.haskell.org/Combinator\" target=\"_blank\" rel=\"noopener\">wiki.haskell.org</a></p>\n</li>\n<li><p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand.<br>__ John Hughes—<a href=\"http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf\" target=\"_blank\" rel=\"noopener\">Generalizing Monads to Arrows</a> via <a href=\"https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org\" target=\"_blank\" rel=\"noopener\">Functional Programming Concepts</a></p>\n</li>\n</ul>\n<p>The exact definition of “combinators” in Rust ecosystem is bit unclear. </p>\n<ul>\n<li><p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code><br>▸ <strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</p>\n</li>\n<li><p><code>filter()</code> for <code>Option</code> types<br>▸ <strong>Filter type T</strong> by using a closure as a conditional function<br>▸ <strong>Return same type T</strong></p>\n</li>\n<li><p><code>map()</code>, <code>map_err()</code><br>▸ <strong>Convert type T by applying a closure</strong>.<br>▸ The <strong>data type of the value inside T can be changed</strong>.<br>ex. <code>Some&lt;&amp;str&gt;</code> can be converted to <code>Some&lt;usize&gt;</code> or <code>Err&lt;&amp;str&gt;</code> to <code>Err&lt;isize&gt;</code> and etc.</p>\n</li>\n<li><p><code>map_or()</code>, <code>map_or_else()</code><br>▸ <strong>Transform type T by applying a closure</strong> &amp; <strong>return the value inside type T</strong>.<br>▸ For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</p>\n</li>\n<li><p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types<br>▸ <strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</p>\n</li>\n<li><p><code>as_ref()</code>, <code>as_mut()</code><br>▸ <strong>Transform type T into a reference or a mutable reference</strong>.</p>\n</li>\n</ul>\n<h2 id=\"or-and-and\"><a href=\"#or-and-and\" class=\"headerlink\" title=\"or() and and()\"></a>or() and and()</h2><p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p>\n<ul>\n<li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li>\n<li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let s1 = Some(&quot;some1&quot;);\n  let s2 = Some(&quot;some2&quot;);\n  let n: Option&lt;&amp;str&gt; = None;\n\n  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n\n  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1\n  assert_eq!(s1.or(n), s1);  // Some or None = Some\n  assert_eq!(n.or(s1), s1);  // None or Some = Some\n  assert_eq!(n.or(n), n);    // None1 or None2 = None2\n\n  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1\n  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok\n  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok\n  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2\n\n  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2\n  assert_eq!(s1.and(n), n);   // Some and None = None\n  assert_eq!(n.and(s1), n);   // None and Some = None\n  assert_eq!(n.and(n), n);    // None1 and None2 = None1\n\n  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2\n  assert_eq!(o1.and(e1), e1); // Ok and Err = Err\n  assert_eq!(e1.and(o1), e1); // Err and Ok = Err\n  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1\n}\n</code></pre>\n<blockquote>\n<p>🔎 Rust nightly support <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\" target=\"_blank\" rel=\"noopener\"><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p>\n</blockquote>\n<h2 id=\"or-else\"><a href=\"#or-else\" class=\"headerlink\" title=\"or_else()\"></a>or_else()</h2><p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // or_else with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = || None;\n\n    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1\n    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some\n    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some\n    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2\n\n    // or_else with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1\n    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok\n    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok\n    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2\n}\n</code></pre>\n<h2 id=\"and-then\"><a href=\"#and-then\" class=\"headerlink\" title=\"and_then()\"></a>and_then()</h2><p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href=\"a7.functions.html#Closures\">closure</a></strong> which returns same type T.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    // and_then with Option\n    let s1 = Some(&quot;some1&quot;);\n    let s2 = Some(&quot;some2&quot;);\n    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };\n\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_none = |_| None;\n\n    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2\n    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None\n    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None\n    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1\n\n    // and_then with Result\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);\n    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);\n    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);\n    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);\n    let fn_err = |_| Err(&quot;error2&quot;);\n\n    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2\n    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err\n    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err\n    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1\n}\n</code></pre>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><blockquote>\n<p>💡 Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter\" target=\"_blank\" rel=\"noopener\"><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p>\n</blockquote>\n<p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(3);\n    let s2 = Some(6);\n    let n = None;\n\n    let fn_is_even = |x: &amp;i8| x % 2 == 0;\n\n    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None\n    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)\n    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None\n}\n</code></pre>\n<h2 id=\"map-and-map-err\"><a href=\"#map-and-map-err\" class=\"headerlink\" title=\"map() and map_err()\"></a>map() and map_err()</h2><blockquote>\n<p>💡 Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\" target=\"_blank\" rel=\"noopener\"><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types. </p>\n</blockquote>\n<ul>\n<li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code>, <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code></li>\n</ul>\n<p>⭐ Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn’t contain any value at all).</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s1 = Some(&quot;abcde&quot;);\n    let s2 = Some(5);\n\n    let n1: Option&lt;&amp;str&gt; = None;\n    let n2: Option&lt;usize&gt; = None;\n\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);\n    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);\n\n    let fn_character_count = |s: &amp;str| s.chars().count();\n\n    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2\n    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2\n\n    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<ul>\n<li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code>.</li>\n</ul>\n<p>⭐ Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);\n\n    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);\n    let e2: Result&lt;&amp;str, isize&gt; = Err(404);\n\n    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize\n\n    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2\n    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2\n}\n</code></pre>\n<h2 id=\"map-or-and-map-or-else\"><a href=\"#map-or-and-map-or-else\" class=\"headerlink\" title=\"map_or() and map_or_else()\"></a>map_or() and map_or_else()</h2><p>Hope you remember the functionality of <a href=\"e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else\"><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p>\n<ul>\n<li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const V_DEFAULT: i8 = 1;\n\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n    let fn_closure = |v: i8| v + 2;\n\n    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);\n    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);\n}\n</code></pre>\n<ul>\n<li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li>\n</ul>\n<p>⭐ <code>None</code> types doesn’t contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">#![feature(result_map_or_else)] // enable unstable library feature &#39;result_map_or_else&#39; on nightly\nfn main() {\n    let s = Some(10);\n    let n: Option&lt;i8&gt; = None;\n\n    let fn_closure = |v: i8| v + 2;\n    let fn_default = || 1; // None doesn&#39;t contain any value. So no need to pass anything to closure as input.\n\n    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);\n    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);\n\n    let o = Ok(10);\n    let e = Err(5);\n    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input\n\n    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);\n    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);\n}\n</code></pre>\n<h2 id=\"ok-or-and-ok-or-else\"><a href=\"#ok-or-and-ok-or-else\" class=\"headerlink\" title=\"ok_or() and ok_or_else()\"></a>ok_or() and ok_or_else()</h2><p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p>\n<ul>\n<li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;\n\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);\n\n    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)\n}\n</code></pre>\n<ul>\n<li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let s = Some(&quot;abcde&quot;);\n    let n: Option&lt;&amp;str&gt; = None;\n    let fn_err_message = || &quot;error message&quot;;\n\n    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);\n    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);\n\n    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)\n    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)\n}\n</code></pre>\n<h2 id=\"as-ref-and-as-mut\"><a href=\"#as-ref-and-as-mut\" class=\"headerlink\" title=\"as_ref() and as_mut()\"></a>as_ref() and as_mut()</h2><p>🔎 As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p>\n<ul>\n<li><code>as_ref()</code> : Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code> </li>\n<li><code>as_mut()</code> : Converts <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>\n</ul>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.png)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.png)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2019-01-19T16:53:20.797Z","updated":"2019-01-19T16:53:20.797Z","path":"docs/index.html","comments":1,"layout":"page","_id":"cjtfwbj01000wdwgpbpcltvgj","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.png\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.png\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"},{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by Node.js.","subtitle":"Learning Rust","lang":"zh-cn","_content":"ul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') 基础知识\n      p.intro-feature-desc 如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') 基础之上\n      p.intro-feature-desc Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') 难啃的部分\n      p.intro-feature-desc 所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') 开始你的项目\n      p.intro-feature-desc 模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。\n","source":"zh-cn/index.jade","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by Node.js.\nsubtitle: Learning Rust\nlang: zh-cn\n---\nul#intro-feature-list\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-street-view\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/a1.why_rust.html') 基础知识\n      p.intro-feature-desc 如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-road\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/b1.vectors.html') 基础之上\n      p.intro-feature-desc Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-plane\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/c1.ownership.html') 难啃的部分\n      p.intro-feature-desc 所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。\n  li.intro-feature-wrap\n    .intro-feature\n      .intro-feature-icon\n        i.fa.fa-space-shuttle\n      h3.intro-feature-title\n        a(href='/docs/zh-cn/d1.code_organization.html') 开始你的项目\n      p.intro-feature-desc 模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。\n","date":"2019-03-19T14:50:31.988Z","updated":"2019-03-19T14:50:31.988Z","path":"zh-cn/index.html","title":"","comments":1,"_id":"cjtfwbj03000xdwgp7jlemzhe","content":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">基础知识</a></h3><p class=\"intro-feature-desc\">如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">基础之上</a></h3><p class=\"intro-feature-desc\">Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">难啃的部分</a></h3><p class=\"intro-feature-desc\">所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">开始你的项目</a></h3><p class=\"intro-feature-desc\">模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。</p></div></li></ul>","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul id=\"intro-feature-list\"><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-street-view\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/a1.why_rust.html\">基础知识</a></h3><p class=\"intro-feature-desc\">如何安装，Hello World，Cargo，Crates，变量绑定，函数，原生数据类型，操作与控制流。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-road\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/b1.vectors.html\">基础之上</a></h3><p class=\"intro-feature-desc\">Vectors，结构体（Structs），枚举（Enums），范型（Generics），特性与特性实现（Impls & Traits）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-plane\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/c1.ownership.html\">难啃的部分</a></h3><p class=\"intro-feature-desc\">所有权（Ownership），所有权借用（Borrowing），生存期与生存期省略（Lifetimes & Lifetime Elision）。</p></div></li><li class=\"intro-feature-wrap\"><div class=\"intro-feature\"><div class=\"intro-feature-icon\"><i class=\"fa fa-space-shuttle\"></i></div><h3 class=\"intro-feature-title\"><a href=\"/docs/zh-cn/d1.code_organization.html\">开始你的项目</a></h3><p class=\"intro-feature-desc\">模块（Modules），代码箱（Crates），工作区（Workspaces），标准模块（std module）和预设上下文（Preludes）。</p></div></li></ul>"},{"title":"Custom Error Types","_content":"\nRust allow us to create our own `Err` types. We call them “*Custom Error Types*”.\n\n## Error trait\n\nAs you know **traits define the functionality a type must provide**. But we don’t need to define new traits for common functionalities always, because Rust **standard library provides some reusable traits** which can be implemented on our own types. While creating custom error types [`std::error::Error` trait](https://doc.rust-lang.org/std/error/trait.Error.html) help us to convert any type to an `Err` type.\n\n```rust\nuse std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n```\n\n> As we discussed under [traits inheritance](b5.impls_and_traits.html#Traits-inheritance), a trait can be inherited from another traits. `trait Error: Debug + Display` means `Error` trait inherits from `fmt::Debug` and `fmt::Display` traits.\n\n```rust\n// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n\npub trait Debug {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n```\n\n- `Display`\n  - How should the end user see this error as a message/ user-facing output.\n  - Usually print via `println!(\"{}\")` or `eprintln!(\"{}\")`\n\n- `Debug`\n  - How should display the `Err` while debugging/ programmer-facing output.\n  - Usually print via `println!(\"{:?}\")` or `eprintln!(\"{:?}\")`\n  - To pretty-print, `println!(\"{:#?}\")` or `eprintln!(\"{:#?}\")` can be used.\n\n- `source()`\n  - The lower-level source of this error, if any.\n  - Optional.\n\nFirst, let’s see how to implement `std::error::Error` trait on a simplest custom error type.\n\n```rust\nuse std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// 💡 In here, we use a simple \"unit struct\" to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"An Error Occurred, Please Try Again!\") // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{{ file: {}, line: {} }}\", file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // An Error Occurred, Please Try Again!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n```\n\nHope you understood the main points. Now, let’s see some custom error type with **an error code and an error message**.\n\n```rust\nuse std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"AppError {{ code: {}, message: {} }}\",\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n```\n\n⭐️ Rust standard library provides not only reusable traits and also it facilitates to **magically generate implementations for few traits** via `#[derive]` attribute. Rust support `derive` `std::fmt::Debug`, to provide a default format for debug messages. So we **can skip `std::fmt::Debug` implementation** for custom error types and use `#[derive(Debug)]` before `struct` declaration.\n\n> For a struct `#[derive(Debug)]` prints, the name of the `struct` , `{` , comma-separated list of each field’s name and debug value and `}`.\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: \"Page not found\"\n    //     }\n    // )\n}\n```\n\n\n## From trait\n\nWhen writing real programs, mostly we have to deal with different modules, different `std` and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, `std::convert::From`.\n\n```rust\n// traits inside Rust standard library core convert module/ std::convert\npub trait From<T>: Sized {\n  fn from(_: T) -> Self;\n}\n```\n\n> 💡 As you know, `String::from()` function is used to create a `String` from `&str` data type. Actually this also an implementation of `std::convert::From` trait.\n\nLet’s see how to implement `std::convert::From` trait on a custom error type.\n\n```rust\nuse std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let _file = File::open(\"nonexistent_file.txt\")?; // This generates an io::Error. But because of return type is Result<(), AppError>, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n```\n\nIn the above example, `File::open(“nonexistent.txt”)?` produces `std::io::Error`. But because of the return type is `Result<(), AppError>`, it converts to an `AppError`. Because of we are propagating the error from `main()` function, it prints the `Debug` representation of the `Err`.\n\nIn the above example we deal with only one `std` error type, `std::io::Error`. Let’s see some example which handles multiple `std` error types.\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from(\"parse\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open(\"hello_world.txt\")?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n\n// 02. If user doesn't have relevant permission to access hello_world.txt\nError: AppError { kind: \"io\", message: \"Permission denied (os error 13)\" }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: \"parse\", message: \"invalid digit found in string\" }\n```\n\n> 🔎 Search about the implementation of [`std::io::ErrorKind`](https://doc.rust-lang.org/std/io/enum.ErrorKind.html), to see how to organize error types further.","source":"docs/e7.custom_error_types.md","raw":"title: Custom Error Types\n---\n\nRust allow us to create our own `Err` types. We call them “*Custom Error Types*”.\n\n## Error trait\n\nAs you know **traits define the functionality a type must provide**. But we don’t need to define new traits for common functionalities always, because Rust **standard library provides some reusable traits** which can be implemented on our own types. While creating custom error types [`std::error::Error` trait](https://doc.rust-lang.org/std/error/trait.Error.html) help us to convert any type to an `Err` type.\n\n```rust\nuse std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n```\n\n> As we discussed under [traits inheritance](b5.impls_and_traits.html#Traits-inheritance), a trait can be inherited from another traits. `trait Error: Debug + Display` means `Error` trait inherits from `fmt::Debug` and `fmt::Display` traits.\n\n```rust\n// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n\npub trait Debug {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error>;\n}\n```\n\n- `Display`\n  - How should the end user see this error as a message/ user-facing output.\n  - Usually print via `println!(\"{}\")` or `eprintln!(\"{}\")`\n\n- `Debug`\n  - How should display the `Err` while debugging/ programmer-facing output.\n  - Usually print via `println!(\"{:?}\")` or `eprintln!(\"{:?}\")`\n  - To pretty-print, `println!(\"{:#?}\")` or `eprintln!(\"{:#?}\")` can be used.\n\n- `source()`\n  - The lower-level source of this error, if any.\n  - Optional.\n\nFirst, let’s see how to implement `std::error::Error` trait on a simplest custom error type.\n\n```rust\nuse std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// 💡 In here, we use a simple \"unit struct\" to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"An Error Occurred, Please Try Again!\") // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{{ file: {}, line: {} }}\", file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // An Error Occurred, Please Try Again!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n```\n\nHope you understood the main points. Now, let’s see some custom error type with **an error code and an error message**.\n\n```rust\nuse std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"AppError {{ code: {}, message: {} }}\",\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n```\n\n⭐️ Rust standard library provides not only reusable traits and also it facilitates to **magically generate implementations for few traits** via `#[derive]` attribute. Rust support `derive` `std::fmt::Debug`, to provide a default format for debug messages. So we **can skip `std::fmt::Debug` implementation** for custom error types and use `#[derive(Debug)]` before `struct` declaration.\n\n> For a struct `#[derive(Debug)]` prints, the name of the `struct` , `{` , comma-separated list of each field’s name and debug value and `}`.\n\n```rust\nuse std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let err_msg = match self.code {\n            404 => \"Sorry, Can not find the Page!\",\n            _ => \"Sorry, something is wrong! Please Try Again!\",\n        };\n\n        write!(f, \"{}\", err_msg)\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError {\n        code: 404,\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) => eprintln!(\"{}\", e), // Sorry, Can not find the Page!\n        _ => println!(\"No error\"),\n    }\n\n    eprintln!(\"{:?}\", produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(\"{:#?}\", produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: \"Page not found\"\n    //     }\n    // )\n}\n```\n\n\n## From trait\n\nWhen writing real programs, mostly we have to deal with different modules, different `std` and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, `std::convert::From`.\n\n```rust\n// traits inside Rust standard library core convert module/ std::convert\npub trait From<T>: Sized {\n  fn from(_: T) -> Self;\n}\n```\n\n> 💡 As you know, `String::from()` function is used to create a `String` from `&str` data type. Actually this also an implementation of `std::convert::From` trait.\n\nLet’s see how to implement `std::convert::From` trait on a custom error type.\n\n```rust\nuse std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let _file = File::open(\"nonexistent_file.txt\")?; // This generates an io::Error. But because of return type is Result<(), AppError>, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n```\n\nIn the above example, `File::open(“nonexistent.txt”)?` produces `std::io::Error`. But because of the return type is `Result<(), AppError>`, it converts to an `AppError`. Because of we are propagating the error from `main()` function, it prints the `Debug` representation of the `Err`.\n\nIn the above example we deal with only one `std` error type, `std::io::Error`. Let’s see some example which handles multiple `std` error types.\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from(\"io\"),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from(\"parse\"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open(\"hello_world.txt\")?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: \"io\", message: \"No such file or directory (os error 2)\" }\n\n// 02. If user doesn't have relevant permission to access hello_world.txt\nError: AppError { kind: \"io\", message: \"Permission denied (os error 13)\" }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: \"parse\", message: \"invalid digit found in string\" }\n```\n\n> 🔎 Search about the implementation of [`std::io::ErrorKind`](https://doc.rust-lang.org/std/io/enum.ErrorKind.html), to see how to organize error types further.","date":"2019-01-19T16:53:20.795Z","updated":"2019-01-19T16:53:20.795Z","path":"docs/e7.custom_error_types.html","comments":1,"layout":"page","_id":"cjtfwbj06000ydwgpfsuu6qyn","content":"<p>Rust allow us to create our own <code>Err</code> types. We call them “<em>Custom Error Types</em>”.</p>\n<h2 id=\"Error-trait\"><a href=\"#Error-trait\" class=\"headerlink\" title=\"Error trait\"></a>Error trait</h2><p>As you know <strong>traits define the functionality a type must provide</strong>. But we don’t need to define new traits for common functionalities always, because Rust <strong>standard library provides some reusable traits</strong> which can be implemented on our own types. While creating custom error types <a href=\"https://doc.rust-lang.org/std/error/trait.Error.html\" target=\"_blank\" rel=\"noopener\"><code>std::error::Error</code> trait</a> help us to convert any type to an <code>Err</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + &#39;static)&gt; { ... }\n}\n</code></pre>\n<blockquote>\n<p>As we discussed under <a href=\"b5.impls_and_traits.html#Traits-inheritance\">traits inheritance</a>, a trait can be inherited from another traits. <code>trait Error: Debug + Display</code> means <code>Error</code> trait inherits from <code>fmt::Debug</code> and <code>fmt::Display</code> traits.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n\npub trait Debug {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre>\n<ul>\n<li><p><code>Display</code></p>\n<ul>\n<li>How should the end user see this error as a message/ user-facing output.</li>\n<li>Usually print via <code>println!(&quot;{}&quot;)</code> or <code>eprintln!(&quot;{}&quot;)</code></li>\n</ul>\n</li>\n<li><p><code>Debug</code></p>\n<ul>\n<li>How should display the <code>Err</code> while debugging/ programmer-facing output.</li>\n<li>Usually print via <code>println!(&quot;{:?}&quot;)</code> or <code>eprintln!(&quot;{:?}&quot;)</code></li>\n<li>To pretty-print, <code>println!(&quot;{:#?}&quot;)</code> or <code>eprintln!(&quot;{:#?}&quot;)</code> can be used.</li>\n</ul>\n</li>\n<li><p><code>source()</code></p>\n<ul>\n<li>The lower-level source of this error, if any.</li>\n<li>Optional.</li>\n</ul>\n</li>\n</ul>\n<p>First, let’s see how to implement <code>std::error::Error</code> trait on a simplest custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// 💡 In here, we use a simple &quot;unit struct&quot; to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n</code></pre>\n<p>Hope you understood the main points. Now, let’s see some custom error type with <strong>an error code and an error message</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            &quot;AppError {{ code: {}, message: {} }}&quot;,\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n</code></pre>\n<p>⭐️ Rust standard library provides not only reusable traits and also it facilitates to <strong>magically generate implementations for few traits</strong> via <code>#[derive]</code> attribute. Rust support <code>derive</code> <code>std::fmt::Debug</code>, to provide a default format for debug messages. So we <strong>can skip <code>std::fmt::Debug</code> implementation</strong> for custom error types and use <code>#[derive(Debug)]</code> before <code>struct</code> declaration.</p>\n<blockquote>\n<p>For a struct <code>#[derive(Debug)]</code> prints, the name of the <code>struct</code> , <code>{</code> , comma-separated list of each field’s name and debug value and <code>}</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: &quot;Page not found&quot;\n    //     }\n    // )\n}\n</code></pre>\n<h2 id=\"From-trait\"><a href=\"#From-trait\" class=\"headerlink\" title=\"From trait\"></a>From trait</h2><p>When writing real programs, mostly we have to deal with different modules, different <code>std</code> and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, <code>std::convert::From</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core convert module/ std::convert\npub trait From&lt;T&gt;: Sized {\n  fn from(_: T) -&gt; Self;\n}\n</code></pre>\n<blockquote>\n<p>💡 As you know, <code>String::from()</code> function is used to create a <code>String</code> from <code>&amp;str</code> data type. Actually this also an implementation of <code>std::convert::From</code> trait.</p>\n</blockquote>\n<p>Let’s see how to implement <code>std::convert::From</code> trait on a custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n</code></pre>\n<p>In the above example, <code>File::open(“nonexistent.txt”)?</code> produces <code>std::io::Error</code>. But because of the return type is <code>Result&lt;(), AppError&gt;</code>, it converts to an <code>AppError</code>. Because of we are propagating the error from <code>main()</code> function, it prints the <code>Debug</code> representation of the <code>Err</code>.</p>\n<p>In the above example we deal with only one <code>std</code> error type, <code>std::io::Error</code>. Let’s see some example which handles multiple <code>std</code> error types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From&lt;num::ParseIntError&gt; for AppError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;parse&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n\n// 02. If user doesn&#39;t have relevant permission to access hello_world.txt\nError: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }\n</code></pre>\n<blockquote>\n<p>🔎 Search about the implementation of <a href=\"https://doc.rust-lang.org/std/io/enum.ErrorKind.html\" target=\"_blank\" rel=\"noopener\"><code>std::io::ErrorKind</code></a>, to see how to organize error types further.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Rust allow us to create our own <code>Err</code> types. We call them “<em>Custom Error Types</em>”.</p>\n<h2 id=\"Error-trait\"><a href=\"#Error-trait\" class=\"headerlink\" title=\"Error trait\"></a>Error trait</h2><p>As you know <strong>traits define the functionality a type must provide</strong>. But we don’t need to define new traits for common functionalities always, because Rust <strong>standard library provides some reusable traits</strong> which can be implemented on our own types. While creating custom error types <a href=\"https://doc.rust-lang.org/std/error/trait.Error.html\" target=\"_blank\" rel=\"noopener\"><code>std::error::Error</code> trait</a> help us to convert any type to an <code>Err</code> type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + &#39;static)&gt; { ... }\n}\n</code></pre>\n<blockquote>\n<p>As we discussed under <a href=\"b5.impls_and_traits.html#Traits-inheritance\">traits inheritance</a>, a trait can be inherited from another traits. <code>trait Error: Debug + Display</code> means <code>Error</code> trait inherits from <code>fmt::Debug</code> and <code>fmt::Display</code> traits.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core fmt module/ std::fmt\npub trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n\npub trait Debug {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre>\n<ul>\n<li><p><code>Display</code></p>\n<ul>\n<li>How should the end user see this error as a message/ user-facing output.</li>\n<li>Usually print via <code>println!(&quot;{}&quot;)</code> or <code>eprintln!(&quot;{}&quot;)</code></li>\n</ul>\n</li>\n<li><p><code>Debug</code></p>\n<ul>\n<li>How should display the <code>Err</code> while debugging/ programmer-facing output.</li>\n<li>Usually print via <code>println!(&quot;{:?}&quot;)</code> or <code>eprintln!(&quot;{:?}&quot;)</code></li>\n<li>To pretty-print, <code>println!(&quot;{:#?}&quot;)</code> or <code>eprintln!(&quot;{:#?}&quot;)</code> can be used.</li>\n</ul>\n</li>\n<li><p><code>source()</code></p>\n<ul>\n<li>The lower-level source of this error, if any.</li>\n<li>Optional.</li>\n</ul>\n</li>\n</ul>\n<p>First, let’s see how to implement <code>std::error::Error</code> trait on a simplest custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n// Custom error type; can be any type which defined in the current crate\n// 💡 In here, we use a simple &quot;unit struct&quot; to simplify the example\nstruct AppError;\n\n// Implement std::fmt::Display for AppError\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output\n    }\n}\n\n// Implement std::fmt::Debug for AppError\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output\n    }\n}\n\n// A sample function to produce an AppError Err\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError)\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n</code></pre>\n<p>Hope you understood the main points. Now, let’s see some custom error type with <strong>an error code and an error message</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\n// Different error messages according to AppError.code\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\n// A unique format for dubugging output\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            &quot;AppError {{ code: {}, message: {} }}&quot;,\n            self.code, self.message\n        )\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError { code: 404, message: Page not found }\n    // )\n}\n</code></pre>\n<p>⭐️ Rust standard library provides not only reusable traits and also it facilitates to <strong>magically generate implementations for few traits</strong> via <code>#[derive]</code> attribute. Rust support <code>derive</code> <code>std::fmt::Debug</code>, to provide a default format for debug messages. So we <strong>can skip <code>std::fmt::Debug</code> implementation</strong> for custom error types and use <code>#[derive(Debug)]</code> before <code>struct</code> declaration.</p>\n<blockquote>\n<p>For a struct <code>#[derive(Debug)]</code> prints, the name of the <code>struct</code> , <code>{</code> , comma-separated list of each field’s name and debug value and <code>}</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fmt;\n\n#[derive(Debug)] // derive std::fmt::Debug on AppError\nstruct AppError {\n    code: usize,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let err_msg = match self.code {\n            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,\n            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,\n        };\n\n        write!(f, &quot;{}&quot;, err_msg)\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        code: 404,\n        message: String::from(&quot;Page not found&quot;),\n    })\n}\n\nfn main() {\n    match produce_error() {\n        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!\n        _ =&gt; println!(&quot;No error&quot;),\n    }\n\n    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })\n\n    eprintln!(&quot;{:#?}&quot;, produce_error());\n    // Err(\n    //     AppError {\n    //         code: 404,\n    //         message: &quot;Page not found&quot;\n    //     }\n    // )\n}\n</code></pre>\n<h2 id=\"From-trait\"><a href=\"#From-trait\" class=\"headerlink\" title=\"From trait\"></a>From trait</h2><p>When writing real programs, mostly we have to deal with different modules, different <code>std</code> and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, <code>std::convert::From</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// traits inside Rust standard library core convert module/ std::convert\npub trait From&lt;T&gt;: Sized {\n  fn from(_: T) -&gt; Self;\n}\n</code></pre>\n<blockquote>\n<p>💡 As you know, <code>String::from()</code> function is used to create a <code>String</code> from <code>&amp;str</code> data type. Actually this also an implementation of <code>std::convert::From</code> trait.</p>\n</blockquote>\n<p>Let’s see how to implement <code>std::convert::From</code> trait on a custom error type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,    // type of the error\n    message: String, // error message\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError\n\n    Ok(())\n}\n\n\n// --------------- Run time error ---------------\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n</code></pre>\n<p>In the above example, <code>File::open(“nonexistent.txt”)?</code> produces <code>std::io::Error</code>. But because of the return type is <code>Result&lt;(), AppError&gt;</code>, it converts to an <code>AppError</code>. Because of we are propagating the error from <code>main()</code> function, it prints the <code>Debug</code> representation of the <code>Err</code>.</p>\n<p>In the above example we deal with only one <code>std</code> error type, <code>std::io::Error</code>. Let’s see some example which handles multiple <code>std</code> error types.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\n// Implement std::convert::From for AppError; from io::Error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;io&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\n// Implement std::convert::From for AppError; from num::ParseIntError\nimpl From&lt;num::ParseIntError&gt; for AppError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        AppError {\n            kind: String::from(&quot;parse&quot;),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -&gt; Result&lt;(), AppError&gt; {\n    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError\n\n    let mut content = String::new();\n    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError\n\n    let _number: usize;\n    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError\n\n    Ok(())\n}\n\n\n// --------------- Few possible run time errors ---------------\n\n// 01. If hello_world.txt is a nonexistent file\nError: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }\n\n// 02. If user doesn&#39;t have relevant permission to access hello_world.txt\nError: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }\n\n// 03. If hello_world.txt contains non-numeric content. ex Hello, world!\nError: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }\n</code></pre>\n<blockquote>\n<p>🔎 Search about the implementation of <a href=\"https://doc.rust-lang.org/std/io/enum.ErrorKind.html\" target=\"_blank\" rel=\"noopener\"><code>std::io::ErrorKind</code></a>, to see how to organize error types further.</p>\n</blockquote>\n"},{"title":"安装Rust","_content":"\n## Rustup\n想要在系统中安装Rust，有很多方法可以供您选择。此时官方推荐的安装方式是使用[Rustup](https://rustup.rs/)。\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup会通过官方的释放渠道下载并安装Rust。您可以轻松的在**stable, beta, and nightly**三个分支版本中进行切换，并有效的使其保持更新。这些通用平台上的二进制标准库，会使得在需要进行交叉编译变得简单起来。\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup会安装**`rustc`，`cargo`，`rustup`**和其他一些标准工具到Cargo的`bin` 目录下。在Unix中，它位于`$HOME/.cargo/bin`路径下，而Windows系统中，则位于`%USERPROFILE%\\.cargo\\bin`目录下。该目录也是当使用`cargo install`安装Rust程序和Cargo插件时的默认目标位置。\n\n> ⭐️ 如果你在使用**Microsoft Windows**操作系统，你需要安装**Visual C++ Build Tools** 2013或更高版本。推荐的安装途径是直接安装Visual C++ 2015 Build Tools，但这可能需要额外的3–4GB空间。\n\n### 适用于Mac和Linux用户\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### 适用于Windows用户\n从[www.rustup.rs](https://rustup.rs/)下载**`rustup-init.exe`**并加以执行\n\n💡 更多信息可以在[Rustup项目的Github仓库页面](https://github.com/rust-lang-nursery/rustup.rs)进行查阅\n\n完成Rust的安装之后，你可以在终端键入`rustc --version`或`rustc -V`来校验安装是否成功。\n","source":"docs/zh-cn/a2.installation.md","raw":"title: 安装Rust\n---\n\n## Rustup\n想要在系统中安装Rust，有很多方法可以供您选择。此时官方推荐的安装方式是使用[Rustup](https://rustup.rs/)。\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs) Rustup会通过官方的释放渠道下载并安装Rust。您可以轻松的在**stable, beta, and nightly**三个分支版本中进行切换，并有效的使其保持更新。这些通用平台上的二进制标准库，会使得在需要进行交叉编译变得简单起来。\n\n[📖](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup会安装**`rustc`，`cargo`，`rustup`**和其他一些标准工具到Cargo的`bin` 目录下。在Unix中，它位于`$HOME/.cargo/bin`路径下，而Windows系统中，则位于`%USERPROFILE%\\.cargo\\bin`目录下。该目录也是当使用`cargo install`安装Rust程序和Cargo插件时的默认目标位置。\n\n> ⭐️ 如果你在使用**Microsoft Windows**操作系统，你需要安装**Visual C++ Build Tools** 2013或更高版本。推荐的安装途径是直接安装Visual C++ 2015 Build Tools，但这可能需要额外的3–4GB空间。\n\n### 适用于Mac和Linux用户\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n### 适用于Windows用户\n从[www.rustup.rs](https://rustup.rs/)下载**`rustup-init.exe`**并加以执行\n\n💡 更多信息可以在[Rustup项目的Github仓库页面](https://github.com/rust-lang-nursery/rustup.rs)进行查阅\n\n完成Rust的安装之后，你可以在终端键入`rustc --version`或`rustc -V`来校验安装是否成功。\n","date":"2019-03-19T14:50:31.980Z","updated":"2019-03-19T14:50:31.980Z","path":"docs/zh-cn/a2.installation.html","comments":1,"layout":"page","_id":"cjtfwbj0m000zdwgpfvc6wd96","content":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>想要在系统中安装Rust，有很多方法可以供您选择。此时官方推荐的安装方式是使用<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>。</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup会通过官方的释放渠道下载并安装Rust。您可以轻松的在<strong>stable, beta, and nightly</strong>三个分支版本中进行切换，并有效的使其保持更新。这些通用平台上的二进制标准库，会使得在需要进行交叉编译变得简单起来。</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup会安装<strong><code>rustc</code>，<code>cargo</code>，<code>rustup</code></strong>和其他一些标准工具到Cargo的<code>bin</code> 目录下。在Unix中，它位于<code>$HOME/.cargo/bin</code>路径下，而Windows系统中，则位于<code>%USERPROFILE%\\.cargo\\bin</code>目录下。该目录也是当使用<code>cargo install</code>安装Rust程序和Cargo插件时的默认目标位置。</p>\n<blockquote>\n<p>⭐️ 如果你在使用<strong>Microsoft Windows</strong>操作系统，你需要安装<strong>Visual C++ Build Tools</strong> 2013或更高版本。推荐的安装途径是直接安装Visual C++ 2015 Build Tools，但这可能需要额外的3–4GB空间。</p>\n</blockquote>\n<h3 id=\"适用于Mac和Linux用户\"><a href=\"#适用于Mac和Linux用户\" class=\"headerlink\" title=\"适用于Mac和Linux用户\"></a>适用于Mac和Linux用户</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"适用于Windows用户\"><a href=\"#适用于Windows用户\" class=\"headerlink\" title=\"适用于Windows用户\"></a>适用于Windows用户</h3><p>从<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a>下载<strong><code>rustup-init.exe</code></strong>并加以执行</p>\n<p>💡 更多信息可以在<a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Rustup项目的Github仓库页面</a>进行查阅</p>\n<p>完成Rust的安装之后，你可以在终端键入<code>rustc --version</code>或<code>rustc -V</code>来校验安装是否成功。</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Rustup\"><a href=\"#Rustup\" class=\"headerlink\" title=\"Rustup\"></a>Rustup</h2><p>想要在系统中安装Rust，有很多方法可以供您选择。此时官方推荐的安装方式是使用<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">Rustup</a>。</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup会通过官方的释放渠道下载并安装Rust。您可以轻松的在<strong>stable, beta, and nightly</strong>三个分支版本中进行切换，并有效的使其保持更新。这些通用平台上的二进制标准库，会使得在需要进行交叉编译变得简单起来。</p>\n<p><a href=\"https://github.com/rust-lang-nursery/rustup.rs#installation\" target=\"_blank\" rel=\"noopener\">📖</a> Rustup会安装<strong><code>rustc</code>，<code>cargo</code>，<code>rustup</code></strong>和其他一些标准工具到Cargo的<code>bin</code> 目录下。在Unix中，它位于<code>$HOME/.cargo/bin</code>路径下，而Windows系统中，则位于<code>%USERPROFILE%\\.cargo\\bin</code>目录下。该目录也是当使用<code>cargo install</code>安装Rust程序和Cargo插件时的默认目标位置。</p>\n<blockquote>\n<p>⭐️ 如果你在使用<strong>Microsoft Windows</strong>操作系统，你需要安装<strong>Visual C++ Build Tools</strong> 2013或更高版本。推荐的安装途径是直接安装Visual C++ 2015 Build Tools，但这可能需要额外的3–4GB空间。</p>\n</blockquote>\n<h3 id=\"适用于Mac和Linux用户\"><a href=\"#适用于Mac和Linux用户\" class=\"headerlink\" title=\"适用于Mac和Linux用户\"></a>适用于Mac和Linux用户</h3><p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl https://sh.rustup.rs -sSf | sh\n</code></pre>\n<h3 id=\"适用于Windows用户\"><a href=\"#适用于Windows用户\" class=\"headerlink\" title=\"适用于Windows用户\"></a>适用于Windows用户</h3><p>从<a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener\">www.rustup.rs</a>下载<strong><code>rustup-init.exe</code></strong>并加以执行</p>\n<p>💡 更多信息可以在<a href=\"https://github.com/rust-lang-nursery/rustup.rs\" target=\"_blank\" rel=\"noopener\">Rustup项目的Github仓库页面</a>进行查阅</p>\n<p>完成Rust的安装之后，你可以在终端键入<code>rustc --version</code>或<code>rustc -V</code>来校验安装是否成功。</p>\n"},{"title":"为什么会有Rust?","_content":"\n## Rust的历史\nRust最初由Mozilla的员工**Graydon Hoare**作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。经过三年的锤炼与洗礼，2018年12月6日，Rust的第一个重要更新版本——Rust2018(v1.31)正式发布。\n\n## Rust愿景\nRust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust是一个年轻又现代的编程语言。它是一种**预编译语言**并使用[LLVM](https://en.wikipedia.org/wiki/LLVM)作为后盾。同时，Rust是一个**多范式编程语言**， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## 灵感来源\nRust在设计的过程中，从很多语言汲取了诸多灵感：\n\n* 抽象机器模型 - Abstract Machine Model : **C**\n* 数据类型 - Data types : **C, SML, OCaml, Lisp, Limbo**\n* 可选绑定 - Optional Bindings : **Swift**\n* 洁净宏 - Hygienic Macros : **Scheme**\n* 函数式编程 - Functional Programming : **Haskell, OCaml, F\\#**\n* 属性标签 - Attributes : **ECMA**-335\n* 内存模型与内存管理 - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* 类型模板 - Type Classes : **Haskell**\n* 代码箱 - Crate : Assembly in the **ECMA**-335 CLI model\n* 通道与并发 - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* 消息传递与线程失败处理 - Message passing and Thread failure : **Erlang**  \n\n以及其他。\n\n\nRust默认情况下**并不使用自动垃圾回收机制（GC)**。\n\nRust编译器在**编译阶段**会对代码做大量检查以尽量防止在C++代码中较为常见的[**可能的类型错误**](https://doc.rust-lang.org/error-index.html) 。\n","source":"docs/zh-cn/a1.why_rust.md","raw":"title: 为什么会有Rust?\n---\n\n## Rust的历史\nRust最初由Mozilla的员工**Graydon Hoare**作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。经过三年的锤炼与洗礼，2018年12月6日，Rust的第一个重要更新版本——Rust2018(v1.31)正式发布。\n\n## Rust愿景\nRust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。\n\n> \"Rust is a systems programming language focused on three goals: safety, speed, and concurrency.\"  \n> \\_\\_ Rust Documentation\n\nRust是一个年轻又现代的编程语言。它是一种**预编译语言**并使用[LLVM](https://en.wikipedia.org/wiki/LLVM)作为后盾。同时，Rust是一个**多范式编程语言**， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。\n\n> 🔎 One of Rust’s most unique and compelling features is [Ownership](c1.ownership.html), which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of [References and Borrowing](c2.borrowing.html). And it does automatic compile time memory management by checking the [Lifetimes](c3.lifetimes.html).\n\n## 灵感来源\nRust在设计的过程中，从很多语言汲取了诸多灵感：\n\n* 抽象机器模型 - Abstract Machine Model : **C**\n* 数据类型 - Data types : **C, SML, OCaml, Lisp, Limbo**\n* 可选绑定 - Optional Bindings : **Swift**\n* 洁净宏 - Hygienic Macros : **Scheme**\n* 函数式编程 - Functional Programming : **Haskell, OCaml, F\\#**\n* 属性标签 - Attributes : **ECMA**-335\n* 内存模型与内存管理 - Memory Model and Memory Management : **C++, ML Kit, Cyclone**\n* 类型模板 - Type Classes : **Haskell**\n* 代码箱 - Crate : Assembly in the **ECMA**-335 CLI model\n* 通道与并发 - Channels and Concurrency : **Newsqueak, Alef, Limbo**\n* 消息传递与线程失败处理 - Message passing and Thread failure : **Erlang**  \n\n以及其他。\n\n\nRust默认情况下**并不使用自动垃圾回收机制（GC)**。\n\nRust编译器在**编译阶段**会对代码做大量检查以尽量防止在C++代码中较为常见的[**可能的类型错误**](https://doc.rust-lang.org/error-index.html) 。\n","date":"2019-03-19T14:50:31.980Z","updated":"2019-03-19T14:50:31.980Z","path":"docs/zh-cn/a1.why_rust.html","comments":1,"layout":"page","_id":"cjtfwbj0n0010dwgpon449cpv","content":"<h2 id=\"Rust的历史\"><a href=\"#Rust的历史\" class=\"headerlink\" title=\"Rust的历史\"></a>Rust的历史</h2><p>Rust最初由Mozilla的员工<strong>Graydon Hoare</strong>作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。经过三年的锤炼与洗礼，2018年12月6日，Rust的第一个重要更新版本——Rust2018(v1.31)正式发布。</p>\n<h2 id=\"Rust愿景\"><a href=\"#Rust愿景\" class=\"headerlink\" title=\"Rust愿景\"></a>Rust愿景</h2><p>Rust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust是一个年轻又现代的编程语言。它是一种<strong>预编译语言</strong>并使用<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>作为后盾。同时，Rust是一个<strong>多范式编程语言</strong>， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"灵感来源\"><a href=\"#灵感来源\" class=\"headerlink\" title=\"灵感来源\"></a>灵感来源</h2><p>Rust在设计的过程中，从很多语言汲取了诸多灵感：</p>\n<ul>\n<li>抽象机器模型 - Abstract Machine Model : <strong>C</strong></li>\n<li>数据类型 - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>可选绑定 - Optional Bindings : <strong>Swift</strong></li>\n<li>洁净宏 - Hygienic Macros : <strong>Scheme</strong></li>\n<li>函数式编程 - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>属性标签 - Attributes : <strong>ECMA</strong>-335</li>\n<li>内存模型与内存管理 - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>类型模板 - Type Classes : <strong>Haskell</strong></li>\n<li>代码箱 - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>通道与并发 - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>消息传递与线程失败处理 - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>以及其他。</p>\n<p>Rust默认情况下<strong>并不使用自动垃圾回收机制（GC)</strong>。</p>\n<p>Rust编译器在<strong>编译阶段</strong>会对代码做大量检查以尽量防止在C++代码中较为常见的<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>可能的类型错误</strong></a> 。</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Rust的历史\"><a href=\"#Rust的历史\" class=\"headerlink\" title=\"Rust的历史\"></a>Rust的历史</h2><p>Rust最初由Mozilla的员工<strong>Graydon Hoare</strong>作为个人项目设计并开发。从2009年开始，Mozilla开始资助该项目，并于2010年正式发布。但是第一个稳定版本，Rust 1.0在2015年5月15日才正式放出。经过三年的锤炼与洗礼，2018年12月6日，Rust的第一个重要更新版本——Rust2018(v1.31)正式发布。</p>\n<h2 id=\"Rust愿景\"><a href=\"#Rust愿景\" class=\"headerlink\" title=\"Rust愿景\"></a>Rust愿景</h2><p>Rust的目标是为了建立高并发以及高度安全的系统。因此，Rust被设计用以同时提供速度和安全性。</p>\n<blockquote>\n<p>“Rust is a systems programming language focused on three goals: safety, speed, and concurrency.”<br>__ Rust Documentation</p>\n</blockquote>\n<p>Rust是一个年轻又现代的编程语言。它是一种<strong>预编译语言</strong>并使用<a href=\"https://en.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM</a>作为后盾。同时，Rust是一个<strong>多范式编程语言</strong>， 它融合了过程式编程、并发角色模型、面向对象编程以及纯函数式编程风格。也同样在静态和动态两种层面上支持范型编程和元编程等范式。</p>\n<blockquote>\n<p>🔎 One of Rust’s most unique and compelling features is <a href=\"c1.ownership.html\">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at the compiler time with the usage of <a href=\"c2.borrowing.html\">References and Borrowing</a>. And it does automatic compile time memory management by checking the <a href=\"c3.lifetimes.html\">Lifetimes</a>.</p>\n</blockquote>\n<h2 id=\"灵感来源\"><a href=\"#灵感来源\" class=\"headerlink\" title=\"灵感来源\"></a>灵感来源</h2><p>Rust在设计的过程中，从很多语言汲取了诸多灵感：</p>\n<ul>\n<li>抽象机器模型 - Abstract Machine Model : <strong>C</strong></li>\n<li>数据类型 - Data types : <strong>C, SML, OCaml, Lisp, Limbo</strong></li>\n<li>可选绑定 - Optional Bindings : <strong>Swift</strong></li>\n<li>洁净宏 - Hygienic Macros : <strong>Scheme</strong></li>\n<li>函数式编程 - Functional Programming : <strong>Haskell, OCaml, F#</strong></li>\n<li>属性标签 - Attributes : <strong>ECMA</strong>-335</li>\n<li>内存模型与内存管理 - Memory Model and Memory Management : <strong>C++, ML Kit, Cyclone</strong></li>\n<li>类型模板 - Type Classes : <strong>Haskell</strong></li>\n<li>代码箱 - Crate : Assembly in the <strong>ECMA</strong>-335 CLI model</li>\n<li>通道与并发 - Channels and Concurrency : <strong>Newsqueak, Alef, Limbo</strong></li>\n<li>消息传递与线程失败处理 - Message passing and Thread failure : <strong>Erlang</strong>  </li>\n</ul>\n<p>以及其他。</p>\n<p>Rust默认情况下<strong>并不使用自动垃圾回收机制（GC)</strong>。</p>\n<p>Rust编译器在<strong>编译阶段</strong>会对代码做大量检查以尽量防止在C++代码中较为常见的<a href=\"https://doc.rust-lang.org/error-index.html\" target=\"_blank\" rel=\"noopener\"><strong>可能的类型错误</strong></a> 。</p>\n"},{"title":"控制流","_content":"\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **在将if控制流作为表达式使用时，每个分支块所返回的值在类型上应保持一致**。\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // 匹配 16 时，返回 S\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\", // 以上均不匹配时，默认返回 Not Available\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped 此处没有用以默认返回的匹配\n    // 因为is_allowed的类型为boolean，在该例的模式匹配中，已穷尽了所有可能的匹配\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // 多值匹配可使用元组形式\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\" \n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; // 在rust中没有++或--操作符\n}\n\n// 使用break和continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// 外部break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { // 设置循环标签 outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //中断 outer_while循环\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(不包含10)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// 处理 arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 在每一个迭代中都会重新计算group.len()\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() 将数组转换为一迭代器\n  println!(\"Current Person : {}\", person);\n}\n```\n","source":"docs/zh-cn/a10.control_flows.md","raw":"title: 控制流\n---\n\n# if - else if - else\n\n```rust\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //⭐️no ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n\nlet is_below_eighteen = if team_size < 18 { true } else { false };\n```\n\n⭐️ **在将if控制流作为表达式使用时，每个分支块所返回的值在类型上应保持一致**。\n\n\n# match\n\n```rust\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // 匹配 16 时，返回 S\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\", // 以上均不匹配时，默认返回 Not Available\n};\nprintln!(\"{}\", tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped 此处没有用以默认返回的匹配\n    // 因为is_allowed的类型为boolean，在该例的模式匹配中，已穷尽了所有可能的匹配\n};\nprintln!(\"{}\", list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // 多值匹配可使用元组形式\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\" \n};\nprintln!(\"{}\", output); // Work hard\n```\n\n\n# while\n\n```rust\nlet mut a = 1;\nwhile a <= 10 {\n\tprintln!(\"Current value : {}\", a);\n\ta += 1; // 在rust中没有++或--操作符\n}\n\n// 使用break和continue\nlet mut b = 0;\nwhile b < 5 {\n\tif b == 0 {\n\t\tprintln!(\"Skip value : {}\", b);\n\t\tb += 1;\n\t\tcontinue;\n\t} else if b == 2 {\n\t\tprintln!(\"Break At : {}\", b);\n\t\tbreak;\n\t}\n\tprintln!(\"Current value : {}\", b);\n\tb += 1;\n}\n\n// 外部break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { // 设置循环标签 outer_while\n\tlet mut c2 = 1;\n\t'inner_while: while c2 < 6 {\n\t\tprintln!(\"Current Value : [{}][{}]\", c1, c2);\n\t\tif c1 == 2 && c2 == 2 { break 'outer_while; } //中断 outer_while循环\n\t\tc2 += 1;\n\t}\n\tc1 += 1;\n}\n```\n\n\n# loop\n\n```rust\nloop {\n\tprintln!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n\tif a == 0 {\n\t\tprintln!(\"Skip Value : {}\", a);\n\t\ta += 1;\n\t\tcontinue;\n\t} else if a == 2 {\n\t\tprintln!(\"Break At : {}\", a);\n\t\tbreak;\n\t}\n\tprintln!(\"Current Value : {}\", a);\n\ta += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n    \tbreak;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n```\n\n\n# for\n\n```rust\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(不包含10)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n\n// 处理 arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 👎 在每一个迭代中都会重新计算group.len()\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() 将数组转换为一迭代器\n  println!(\"Current Person : {}\", person);\n}\n```\n","date":"2019-03-21T03:40:47.670Z","updated":"2019-03-21T03:40:47.670Z","path":"docs/zh-cn/a10.control_flows.html","_id":"cjtfwbj0n0011dwgpcmbtjwrj","comments":1,"layout":"page","content":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>在将if控制流作为表达式使用时，每个分支块所返回的值在类型上应保持一致</strong>。</p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // 匹配 16 时，返回 S\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;, // 以上均不匹配时，默认返回 Not Available\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped 此处没有用以默认返回的匹配\n    // 因为is_allowed的类型为boolean，在该例的模式匹配中，已穷尽了所有可能的匹配\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // 多值匹配可使用元组形式\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot; \n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; // 在rust中没有++或--操作符\n}\n\n// 使用break和continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// 外部break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { // 设置循环标签 outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //中断 outer_while循环\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(不包含10)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// 处理 arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 在每一个迭代中都会重新计算group.len()\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() 将数组转换为一迭代器\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h1 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if - else if - else\"></a>if - else if - else</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Simplest Example\nlet team_size = 7;\nif team_size &lt; 5 {\n    println!(&quot;Small&quot;);\n} else if team_size &lt; 10 {\n    println!(&quot;Medium&quot;);\n} else {\n    println!(&quot;Large&quot;);\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size &lt; 5 {\n    team_size_in_text = &quot;Small&quot;;\n} else if team_size &lt; 10 {\n    team_size_in_text = &quot;Medium&quot;;\n} else {\n    team_size_in_text = &quot;Large&quot;;\n}\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size &lt; 5 {\n    &quot;Small&quot; //⭐️no ;\n} else if team_size &lt; 10 {\n    &quot;Medium&quot;\n} else {\n    &quot;Large&quot;\n};\nprintln!(&quot;Current team size : {}&quot;, team_size_in_text);\n\n\nlet is_below_eighteen = if team_size &lt; 18 { true } else { false };\n</code></pre>\n<p>⭐️ <strong>在将if控制流作为表达式使用时，每个分支块所返回的值在类型上应保持一致</strong>。</p>\n<h1 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 =&gt; &quot;S&quot;, // 匹配 16 时，返回 S\n    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18\n    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)\n    22 =&gt; &quot;XL&quot;,\n    _ =&gt; &quot;Not Available&quot;, // 以上均不匹配时，默认返回 Not Available\n};\nprintln!(&quot;{}&quot;, tshirt_size); // L\n\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true =&gt; &quot;Full&quot;,\n    false =&gt; &quot;Restricted&quot;\n    // no default/ _ condition can be skipped 此处没有用以默认返回的匹配\n    // 因为is_allowed的类型为boolean，在该例的模式匹配中，已穷尽了所有可能的匹配\n};\nprintln!(&quot;{}&quot;, list_type); // Restricted\n\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) { // 多值匹配可使用元组形式\n    (50, 50) =&gt; &quot;Full marks for both papers&quot;,\n    (50, _) =&gt; &quot;Full marks for paper A&quot;,\n    (_, 50) =&gt; &quot;Full marks for paper B&quot;,\n    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,\n    (_, _) =&gt; &quot;Work hard&quot; \n};\nprintln!(&quot;{}&quot;, output); // Work hard\n</code></pre>\n<h1 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 1;\nwhile a &lt;= 10 {\n    println!(&quot;Current value : {}&quot;, a);\n    a += 1; // 在rust中没有++或--操作符\n}\n\n// 使用break和continue\nlet mut b = 0;\nwhile b &lt; 5 {\n    if b == 0 {\n        println!(&quot;Skip value : {}&quot;, b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(&quot;Break At : {}&quot;, b);\n        break;\n    }\n    println!(&quot;Current value : {}&quot;, b);\n    b += 1;\n}\n\n// 外部break\nlet mut c1 = 1;\n&#39;outer_while: while c1 &lt; 6 { // 设置循环标签 outer_while\n    let mut c2 = 1;\n    &#39;inner_while: while c2 &lt; 6 {\n        println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n        if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_while; } //中断 outer_while循环\n        c2 += 1;\n    }\n    c1 += 1;\n}\n</code></pre>\n<h1 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">loop {\n    println!(&quot;Loop forever!&quot;);\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(&quot;Skip Value : {}&quot;, a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(&quot;Break At : {}&quot;, a);\n        break;\n    }\n    println!(&quot;Current Value : {}&quot;, a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n&#39;outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  &#39;inner_loop: loop {\n    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);\n    if b1 == 2 &amp;&amp; b2 == 2 {\n        break &#39;outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n}\n</code></pre>\n<h1 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h1><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(不包含10)\n  println!(&quot;Current value : {}&quot;, a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(&quot;Skip Value : {}&quot;, b);\n    continue;\n  } else if b == 2 {\n    println!(&quot;Break At : {}&quot;, b);\n    break;\n  }\n  println!(&quot;Current value : {}&quot;, b);\n}\n\n// Outer break\n&#39;outer_for: for c1 in 1..6 { //set label outer_for\n  &#39;inner_for: for c2 in 1..6 {\n    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);\n    if c1 == 2 &amp;&amp; c2 == 2 { break &#39;outer_for; } //kill outer_for\n  }\n}\n\n\n// 处理 arrays/vectors\nlet group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];\n\nfor n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 在每一个迭代中都会重新计算group.len()\n  println!(&quot;Current Person : {}&quot;, group[n]);\n}\n\nfor person in group.iter() { //👍 group.iter() 将数组转换为一迭代器\n  println!(&quot;Current Person : {}&quot;, person);\n}\n</code></pre>\n"},{"title":"Hello World","_content":"\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` 表示一个函数——function。main函数是每一个Rust程序的起点。\n`println!` 将一个文本输出到控制台，紧随的*!*表示这是一个[宏](https://doc.rust-lang.org/book/first-edition/macros.html)而非通常的函数。\n\n> 💡 Rust源文件应以.rs作为文件扩展名，如果你希望在文件名中包含多个词语，应遵循[蛇形命名](https://en.wikipedia.org/wiki/Snake_case)原则。\n\n- 将以上代码保存为`file.rs`，也可以为其他任何带有`.rs`扩展名的文件名。\n- 通过`rustc file.rs`命令对其进行编译。\n- 在Linux终端中键入`./file`或在Windows命令行中键入`file.exe`来执行该文件。\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/)是一个可以在线运行Rust代码的实验台。\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## println!的用法\n\n💯 println!宏有很丰富的使用方法，\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! 宏则用来生成一个格式化的字串\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","source":"docs/zh-cn/a3.hello_world.md","raw":"title: Hello World\n---\n\n## Hello, World!\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n`fn` 表示一个函数——function。main函数是每一个Rust程序的起点。\n`println!` 将一个文本输出到控制台，紧随的*!*表示这是一个[宏](https://doc.rust-lang.org/book/first-edition/macros.html)而非通常的函数。\n\n> 💡 Rust源文件应以.rs作为文件扩展名，如果你希望在文件名中包含多个词语，应遵循[蛇形命名](https://en.wikipedia.org/wiki/Snake_case)原则。\n\n- 将以上代码保存为`file.rs`，也可以为其他任何带有`.rs`扩展名的文件名。\n- 通过`rustc file.rs`命令对其进行编译。\n- 在Linux终端中键入`./file`或在Windows命令行中键入`file.exe`来执行该文件。\n\n## Rust Playground\n\n[Rust Playground](https://play.rust-lang.org/)是一个可以在线运行Rust代码的实验台。\n\n[![Rust Playground](images/rust_playground.png)](https://play.rust-lang.org/)\n\n## println!的用法\n\n💯 println!宏有很丰富的使用方法，\n\n```rust\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! 宏则用来生成一个格式化的字串\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n}\n```\n","date":"2019-03-19T14:50:31.981Z","updated":"2019-03-19T14:50:31.981Z","path":"docs/zh-cn/a3.hello_world.html","comments":1,"layout":"page","_id":"cjtfwbj0o0012dwgpxc888tol","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> 表示一个函数——function。main函数是每一个Rust程序的起点。<br><code>println!</code> 将一个文本输出到控制台，紧随的<em>!</em>表示这是一个<a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">宏</a>而非通常的函数。</p>\n<blockquote>\n<p>💡 Rust源文件应以.rs作为文件扩展名，如果你希望在文件名中包含多个词语，应遵循<a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">蛇形命名</a>原则。</p>\n</blockquote>\n<ul>\n<li>将以上代码保存为<code>file.rs</code>，也可以为其他任何带有<code>.rs</code>扩展名的文件名。</li>\n<li>通过<code>rustc file.rs</code>命令对其进行编译。</li>\n<li>在Linux终端中键入<code>./file</code>或在Windows命令行中键入<code>file.exe</code>来执行该文件。</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a>是一个可以在线运行Rust代码的实验台。</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"println-的用法\"><a href=\"#println-的用法\" class=\"headerlink\" title=\"println!的用法\"></a>println!的用法</h2><p>💯 println!宏有很丰富的使用方法，</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! 宏则用来生成一个格式化的字串\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello, World!\"></a>Hello, World!</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p><code>fn</code> 表示一个函数——function。main函数是每一个Rust程序的起点。<br><code>println!</code> 将一个文本输出到控制台，紧随的<em>!</em>表示这是一个<a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\" target=\"_blank\" rel=\"noopener\">宏</a>而非通常的函数。</p>\n<blockquote>\n<p>💡 Rust源文件应以.rs作为文件扩展名，如果你希望在文件名中包含多个词语，应遵循<a href=\"https://en.wikipedia.org/wiki/Snake_case\" target=\"_blank\" rel=\"noopener\">蛇形命名</a>原则。</p>\n</blockquote>\n<ul>\n<li>将以上代码保存为<code>file.rs</code>，也可以为其他任何带有<code>.rs</code>扩展名的文件名。</li>\n<li>通过<code>rustc file.rs</code>命令对其进行编译。</li>\n<li>在Linux终端中键入<code>./file</code>或在Windows命令行中键入<code>file.exe</code>来执行该文件。</li>\n</ul>\n<h2 id=\"Rust-Playground\"><a href=\"#Rust-Playground\" class=\"headerlink\" title=\"Rust Playground\"></a>Rust Playground</h2><p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust Playground</a>是一个可以在线运行Rust代码的实验台。</p>\n<p><a href=\"https://play.rust-lang.org/\" target=\"_blank\" rel=\"noopener\"><img src=\"images/rust_playground.png\" alt=\"Rust Playground\"></a></p>\n<h2 id=\"println-的用法\"><a href=\"#println-的用法\" class=\"headerlink\" title=\"println!的用法\"></a>println!的用法</h2><p>💯 println!宏有很丰富的使用方法，</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!\n    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!\n\n    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]\n    println!(&quot;{:#?}&quot;, [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // 🔎 format! 宏则用来生成一个格式化的字串\n    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);\n    println!(&quot;{}&quot;, x); // Hello, world!\n}\n</code></pre>\n"},{"title":"Cargo，Crates于基本的项目结构","_content":"\n## Cargo\n\nCargo是Rust内建的包管理器，主要可以用来：\n\n- 创建新项目：`cargo new`\n- 更新依赖项: `cargo update`\n- 打包项目: `cargo build`\n- 解析项目是否存在任何异常，但并不进行打包: `cargo check`\n- 打包并运行项目: `cargo run`  \n- 执行测试: `cargo test`  \n- 通过rustdoc生成文档: `cargo doc`\n\n除此之外还有一些Cargo的命令，主要在通过Cargo来发布crate包时使用。\n\n- `cargo login` : 获取一个API token\n- `cargo package` : 准备本地的crate以备上传至crates.io  \n- `cargo publish` : 准备本地的crate，并上传到crates.io\n\n## Crate\n\n⭐️ **一个crate代表一个代码包。Crates包可以通过[Cargo](https://crates.io/)进行分享。**\n\n\n一个crate包可以是一个可执行包或是一个库。也就是说，一个crate或是一个可执行项目，或是一个库。\n01.  `cargo new crate_name --bin` 或 `cargo new crate_name`: 生成一个**可执行项目**  \n02.  `cargo new crate_name --lib` : 生成一个**库**\n\n第一个命令会生成：\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\n第二个会生成：\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(大写c\\)存放了当Cargo用来编译您的项目所需的元信息。\n* **src**目录用来存放您的源代码。\n* 每个crate包会有一个暗示性的包入口。**main.rs**是二进制crate包的入口，而**lib.rs**则是crate库包的入口。\n\n> 💡 当需要使用`cargo build`或`cargo run`来编译一个二进制包时，可执行文件会被存放在**target/debug/**文件夹下。但当使用`cargo build --release`来打包一个生产释放包的时候，则会被存放在**target/release/**文件夹下。\n\n## Project Structure\n\n以下是[Cargo文档描述](http://doc.crates.io/guide.html#project-layout)中推荐的项目布局，\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- 源代码应放在`src`文件夹中。  \n- 默认的库入口文件为`src/lib.rs`。\n- 默认的可执行入口文件为`src/main.rs`。  \n- 其余的可执行文件可以放在`src/bin/*.rs`中。  \n- 集成测试文件可以放在`tests`文件夹中 \\(单元测试会放在每个文件自身中\\)。\n- 样例应放在`examples`目录中。\n- 压力测试应放在`benches`文件夹中。\n","source":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.md","raw":"title: Cargo，Crates于基本的项目结构\n---\n\n## Cargo\n\nCargo是Rust内建的包管理器，主要可以用来：\n\n- 创建新项目：`cargo new`\n- 更新依赖项: `cargo update`\n- 打包项目: `cargo build`\n- 解析项目是否存在任何异常，但并不进行打包: `cargo check`\n- 打包并运行项目: `cargo run`  \n- 执行测试: `cargo test`  \n- 通过rustdoc生成文档: `cargo doc`\n\n除此之外还有一些Cargo的命令，主要在通过Cargo来发布crate包时使用。\n\n- `cargo login` : 获取一个API token\n- `cargo package` : 准备本地的crate以备上传至crates.io  \n- `cargo publish` : 准备本地的crate，并上传到crates.io\n\n## Crate\n\n⭐️ **一个crate代表一个代码包。Crates包可以通过[Cargo](https://crates.io/)进行分享。**\n\n\n一个crate包可以是一个可执行包或是一个库。也就是说，一个crate或是一个可执行项目，或是一个库。\n01.  `cargo new crate_name --bin` 或 `cargo new crate_name`: 生成一个**可执行项目**  \n02.  `cargo new crate_name --lib` : 生成一个**库**\n\n第一个命令会生成：\n\n```\n├── Cargo.toml\n└── src\n    └── main.rs\n```\n\n第二个会生成：\n\n```\n├── Cargo.toml\n└── src\n    └── lib.rs\n```\n\n* **Cargo.toml**\\(大写c\\)存放了当Cargo用来编译您的项目所需的元信息。\n* **src**目录用来存放您的源代码。\n* 每个crate包会有一个暗示性的包入口。**main.rs**是二进制crate包的入口，而**lib.rs**则是crate库包的入口。\n\n> 💡 当需要使用`cargo build`或`cargo run`来编译一个二进制包时，可执行文件会被存放在**target/debug/**文件夹下。但当使用`cargo build --release`来打包一个生产释放包的时候，则会被存放在**target/release/**文件夹下。\n\n## Project Structure\n\n以下是[Cargo文档描述](http://doc.crates.io/guide.html#project-layout)中推荐的项目布局，\n\n```\n.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n```\n\n- 源代码应放在`src`文件夹中。  \n- 默认的库入口文件为`src/lib.rs`。\n- 默认的可执行入口文件为`src/main.rs`。  \n- 其余的可执行文件可以放在`src/bin/*.rs`中。  \n- 集成测试文件可以放在`tests`文件夹中 \\(单元测试会放在每个文件自身中\\)。\n- 样例应放在`examples`目录中。\n- 压力测试应放在`benches`文件夹中。\n","date":"2019-03-19T14:50:31.982Z","updated":"2019-03-19T14:50:31.982Z","path":"docs/zh-cn/a4.cargo,crates_and_basic_project_structure.html","comments":1,"layout":"page","_id":"cjtfwbj0o0013dwgpl29yr90t","content":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo是Rust内建的包管理器，主要可以用来：</p>\n<ul>\n<li>创建新项目：<code>cargo new</code></li>\n<li>更新依赖项: <code>cargo update</code></li>\n<li>打包项目: <code>cargo build</code></li>\n<li>解析项目是否存在任何异常，但并不进行打包: <code>cargo check</code></li>\n<li>打包并运行项目: <code>cargo run</code>  </li>\n<li>执行测试: <code>cargo test</code>  </li>\n<li>通过rustdoc生成文档: <code>cargo doc</code></li>\n</ul>\n<p>除此之外还有一些Cargo的命令，主要在通过Cargo来发布crate包时使用。</p>\n<ul>\n<li><code>cargo login</code> : 获取一个API token</li>\n<li><code>cargo package</code> : 准备本地的crate以备上传至crates.io  </li>\n<li><code>cargo publish</code> : 准备本地的crate，并上传到crates.io</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>一个crate代表一个代码包。Crates包可以通过<a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>进行分享。</strong></p>\n<p>一个crate包可以是一个可执行包或是一个库。也就是说，一个crate或是一个可执行项目，或是一个库。</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> 或 <code>cargo new crate_name</code>: 生成一个<strong>可执行项目</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : 生成一个<strong>库</strong></li>\n</ol>\n<p>第一个命令会生成：</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>第二个会生成：</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(大写c)存放了当Cargo用来编译您的项目所需的元信息。</li>\n<li><strong>src</strong>目录用来存放您的源代码。</li>\n<li>每个crate包会有一个暗示性的包入口。<strong>main.rs</strong>是二进制crate包的入口，而<strong>lib.rs</strong>则是crate库包的入口。</li>\n</ul>\n<blockquote>\n<p>💡 当需要使用<code>cargo build</code>或<code>cargo run</code>来编译一个二进制包时，可执行文件会被存放在<strong>target/debug/</strong>文件夹下。但当使用<code>cargo build --release</code>来打包一个生产释放包的时候，则会被存放在<strong>target/release/</strong>文件夹下。</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>以下是<a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo文档描述</a>中推荐的项目布局，</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>源代码应放在<code>src</code>文件夹中。  </li>\n<li>默认的库入口文件为<code>src/lib.rs</code>。</li>\n<li>默认的可执行入口文件为<code>src/main.rs</code>。  </li>\n<li>其余的可执行文件可以放在<code>src/bin/*.rs</code>中。  </li>\n<li>集成测试文件可以放在<code>tests</code>文件夹中 (单元测试会放在每个文件自身中)。</li>\n<li>样例应放在<code>examples</code>目录中。</li>\n<li>压力测试应放在<code>benches</code>文件夹中。</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h2><p>Cargo是Rust内建的包管理器，主要可以用来：</p>\n<ul>\n<li>创建新项目：<code>cargo new</code></li>\n<li>更新依赖项: <code>cargo update</code></li>\n<li>打包项目: <code>cargo build</code></li>\n<li>解析项目是否存在任何异常，但并不进行打包: <code>cargo check</code></li>\n<li>打包并运行项目: <code>cargo run</code>  </li>\n<li>执行测试: <code>cargo test</code>  </li>\n<li>通过rustdoc生成文档: <code>cargo doc</code></li>\n</ul>\n<p>除此之外还有一些Cargo的命令，主要在通过Cargo来发布crate包时使用。</p>\n<ul>\n<li><code>cargo login</code> : 获取一个API token</li>\n<li><code>cargo package</code> : 准备本地的crate以备上传至crates.io  </li>\n<li><code>cargo publish</code> : 准备本地的crate，并上传到crates.io</li>\n</ul>\n<h2 id=\"Crate\"><a href=\"#Crate\" class=\"headerlink\" title=\"Crate\"></a>Crate</h2><p>⭐️ <strong>一个crate代表一个代码包。Crates包可以通过<a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">Cargo</a>进行分享。</strong></p>\n<p>一个crate包可以是一个可执行包或是一个库。也就是说，一个crate或是一个可执行项目，或是一个库。</p>\n<ol>\n<li><code>cargo new crate_name --bin</code> 或 <code>cargo new crate_name</code>: 生成一个<strong>可执行项目</strong>  </li>\n<li><code>cargo new crate_name --lib</code> : 生成一个<strong>库</strong></li>\n</ol>\n<p>第一个命令会生成：</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── main.rs\n</code></pre><p>第二个会生成：</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>├── Cargo.toml\n└── src\n    └── lib.rs\n</code></pre><ul>\n<li><strong>Cargo.toml</strong>(大写c)存放了当Cargo用来编译您的项目所需的元信息。</li>\n<li><strong>src</strong>目录用来存放您的源代码。</li>\n<li>每个crate包会有一个暗示性的包入口。<strong>main.rs</strong>是二进制crate包的入口，而<strong>lib.rs</strong>则是crate库包的入口。</li>\n</ul>\n<blockquote>\n<p>💡 当需要使用<code>cargo build</code>或<code>cargo run</code>来编译一个二进制包时，可执行文件会被存放在<strong>target/debug/</strong>文件夹下。但当使用<code>cargo build --release</code>来打包一个生产释放包的时候，则会被存放在<strong>target/release/</strong>文件夹下。</p>\n</blockquote>\n<h2 id=\"Project-Structure\"><a href=\"#Project-Structure\" class=\"headerlink\" title=\"Project Structure\"></a>Project Structure</h2><p>以下是<a href=\"http://doc.crates.io/guide.html#project-layout\" target=\"_blank\" rel=\"noopener\">Cargo文档描述</a>中推荐的项目布局，</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>.\n├── Cargo.lock\n├── Cargo.toml\n├── benches\n│   └── large-input.rs\n├── examples\n│   └── simple.rs\n├── src\n│   ├── bin\n│   │   └── another_executable.rs\n│   ├── lib.rs\n│   └── main.rs\n└── tests\n    └── some-integration-tests.rs\n</code></pre><ul>\n<li>源代码应放在<code>src</code>文件夹中。  </li>\n<li>默认的库入口文件为<code>src/lib.rs</code>。</li>\n<li>默认的可执行入口文件为<code>src/main.rs</code>。  </li>\n<li>其余的可执行文件可以放在<code>src/bin/*.rs</code>中。  </li>\n<li>集成测试文件可以放在<code>tests</code>文件夹中 (单元测试会放在每个文件自身中)。</li>\n<li>样例应放在<code>examples</code>目录中。</li>\n<li>压力测试应放在<code>benches</code>文件夹中。</li>\n</ul>\n"},{"title":"代码注释与文档","_content":"\n## 注释\n\n```rust\n// 单行注释\n/* 块注释\n```\n\n同时也支持嵌套的块注释\n\n💡 **通常来说，会尽量避免使用块注释，而采用多个行注释。**\n\n## 文档注释\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","source":"docs/zh-cn/a5.comments_and_documenting_the_code.md","raw":"title: 代码注释与文档\n---\n\n## 注释\n\n```rust\n// 单行注释\n/* 块注释\n```\n\n同时也支持嵌套的块注释\n\n💡 **通常来说，会尽量避免使用块注释，而采用多个行注释。**\n\n## 文档注释\n\n```rust\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n```\n\nDoc comments support Markdown notations. Using `cargo doc`, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.\n\n```rust\n/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n```\n\nAs you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.\n\n💡 **Only use //! to write crate and module-level documentation, nothing else. When using `mod` blocks, use /// outside of the block.**\n\n## Doc Attributes\n\nWe can also use **doc attributes** for documenting the code.\n\n> 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general, free-form **metadatum** that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.\n\nHere, for instance, each comment is equivalent to relevant data attributes.\n\n```rust\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"]\n```\n","date":"2019-03-19T14:50:45.775Z","updated":"2019-03-19T14:50:45.775Z","path":"docs/zh-cn/a5.comments_and_documenting_the_code.html","comments":1,"layout":"page","_id":"cjtfwbj0p0014dwgpau34wx3w","content":"<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 单行注释\n/* 块注释\n</code></pre>\n<p>同时也支持嵌套的块注释</p>\n<p>💡 <strong>通常来说，会尽量避免使用块注释，而采用多个行注释。</strong></p>\n<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 单行注释\n/* 块注释\n</code></pre>\n<p>同时也支持嵌套的块注释</p>\n<p>💡 <strong>通常来说，会尽量避免使用块注释，而采用多个行注释。</strong></p>\n<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/\n</code></pre>\n<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// This module contains tests\nmod test {\n    // ...\n}\n\n\nmod test {\n    //! This module contains tests\n\n    // ...\n}\n</code></pre>\n<p>As you can see both use to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>\n<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>\n<h2 id=\"Doc-Attributes\"><a href=\"#Doc-Attributes\" class=\"headerlink\" title=\"Doc Attributes\"></a>Doc Attributes</h2><p>We can also use <strong>doc attributes</strong> for documenting the code.</p>\n<blockquote>\n<p>🔎 An <a href=\"https://doc.rust-lang.org/reference.html#attributes\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>\n</blockquote>\n<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">/// Foo\n#[doc=&quot;Foo&quot;]\n\n//! Foo\n#![doc=&quot;Foo&quot;]\n</code></pre>\n"},{"title":"变量绑定，常量与静态 Variable bindings, Constants & Statics","_content":"\n⭐️ 在Rust中，变量**默认是不可变（immutable）的**，所以称之为**变量绑定**。如果需要使其具有可变性（mutable），可以使用关键字`mut`。\n\n⭐️ Rust是一个**静态类型**语言，它会在编译时，检查数据的类型。但是它**不强制你在声明变量绑定时一定要输入数据类型**。在未显式声明类型时，编译器将会检查使用者的类型，并设置一个适当的类型给它。但是**常量和静态变量则必须有显式类型声明**。类型声明应在变量名加冒号(:)后出现。\n\n* ### 变量绑定\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### 常量\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### 静态变量\n\n```rust\nstatic N: i32 = 5;\n```\n\n关键字**let**可以用在绑定表达式上。我们可以将一个变量名绑定给某个值或某个函数。此外，因为let表达式的左侧是一个“模式(pattern)”，所以你可以将多个变量名绑定给一组值或函数的值。\n\n关键字**const**被用来定义常量。它将在整个程序的运行生命里一直存在于一个固定的内存地址中。**static**关键字用来定义一个被认为有“全局变量”意义的类型。对于每个值来说，仅有一个实例，而且该实例**在内存上的地址固定**。\n\n💡 **尽量使用常量**，而不是静态变量。只有在极少的情况下，你需要你的“常量”有一个固定的内存地址。此外，常量在使用中会进行一些优化，这些优化不仅会在你的crate包中进行，也会惠及下游使用你的crate包的项目。\n\n💡 通常来说，静态部分通常都在代码文件的最前面，在函数之外。\n","source":"docs/zh-cn/a6.variable_bindings,constants_and_statics.md","raw":"title: 变量绑定，常量与静态 Variable bindings, Constants & Statics\n---\n\n⭐️ 在Rust中，变量**默认是不可变（immutable）的**，所以称之为**变量绑定**。如果需要使其具有可变性（mutable），可以使用关键字`mut`。\n\n⭐️ Rust是一个**静态类型**语言，它会在编译时，检查数据的类型。但是它**不强制你在声明变量绑定时一定要输入数据类型**。在未显式声明类型时，编译器将会检查使用者的类型，并设置一个适当的类型给它。但是**常量和静态变量则必须有显式类型声明**。类型声明应在变量名加冒号(:)后出现。\n\n* ### 变量绑定\n\n```rust\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n```\n\n* ### 常量\n\n```rust\nconst N: i32 = 5;\n```\n\n* ### 静态变量\n\n```rust\nstatic N: i32 = 5;\n```\n\n关键字**let**可以用在绑定表达式上。我们可以将一个变量名绑定给某个值或某个函数。此外，因为let表达式的左侧是一个“模式(pattern)”，所以你可以将多个变量名绑定给一组值或函数的值。\n\n关键字**const**被用来定义常量。它将在整个程序的运行生命里一直存在于一个固定的内存地址中。**static**关键字用来定义一个被认为有“全局变量”意义的类型。对于每个值来说，仅有一个实例，而且该实例**在内存上的地址固定**。\n\n💡 **尽量使用常量**，而不是静态变量。只有在极少的情况下，你需要你的“常量”有一个固定的内存地址。此外，常量在使用中会进行一些优化，这些优化不仅会在你的crate包中进行，也会惠及下游使用你的crate包的项目。\n\n💡 通常来说，静态部分通常都在代码文件的最前面，在函数之外。\n","date":"2019-03-19T15:02:29.771Z","updated":"2019-03-19T15:02:29.771Z","path":"docs/zh-cn/a6.variable_bindings,constants_and_statics.html","_id":"cjtfwbj0p0015dwgpz58n4je6","comments":1,"layout":"page","content":"<p>⭐️ 在Rust中，变量<strong>默认是不可变（immutable）的</strong>，所以称之为<strong>变量绑定</strong>。如果需要使其具有可变性（mutable），可以使用关键字<code>mut</code>。</p>\n<p>⭐️ Rust是一个<strong>静态类型</strong>语言，它会在编译时，检查数据的类型。但是它<strong>不强制你在声明变量绑定时一定要输入数据类型</strong>。在未显式声明类型时，编译器将会检查使用者的类型，并设置一个适当的类型给它。但是<strong>常量和静态变量则必须有显式类型声明</strong>。类型声明应在变量名加冒号(:)后出现。</p>\n<ul>\n<li><h3 id=\"变量绑定\"><a href=\"#变量绑定\" class=\"headerlink\" title=\"变量绑定\"></a>变量绑定</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>关键字<strong>let</strong>可以用在绑定表达式上。我们可以将一个变量名绑定给某个值或某个函数。此外，因为let表达式的左侧是一个“模式(pattern)”，所以你可以将多个变量名绑定给一组值或函数的值。</p>\n<p>关键字<strong>const</strong>被用来定义常量。它将在整个程序的运行生命里一直存在于一个固定的内存地址中。<strong>static</strong>关键字用来定义一个被认为有“全局变量”意义的类型。对于每个值来说，仅有一个实例，而且该实例<strong>在内存上的地址固定</strong>。</p>\n<p>💡 <strong>尽量使用常量</strong>，而不是静态变量。只有在极少的情况下，你需要你的“常量”有一个固定的内存地址。此外，常量在使用中会进行一些优化，这些优化不仅会在你的crate包中进行，也会惠及下游使用你的crate包的项目。</p>\n<p>💡 通常来说，静态部分通常都在代码文件的最前面，在函数之外。</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ 在Rust中，变量<strong>默认是不可变（immutable）的</strong>，所以称之为<strong>变量绑定</strong>。如果需要使其具有可变性（mutable），可以使用关键字<code>mut</code>。</p>\n<p>⭐️ Rust是一个<strong>静态类型</strong>语言，它会在编译时，检查数据的类型。但是它<strong>不强制你在声明变量绑定时一定要输入数据类型</strong>。在未显式声明类型时，编译器将会检查使用者的类型，并设置一个适当的类型给它。但是<strong>常量和静态变量则必须有显式类型声明</strong>。类型声明应在变量名加冒号(:)后出现。</p>\n<ul>\n<li><h3 id=\"变量绑定\"><a href=\"#变量绑定\" class=\"headerlink\" title=\"变量绑定\"></a>变量绑定</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6;\n</code></pre>\n<ul>\n<li><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">const N: i32 = 5;\n</code></pre>\n<ul>\n<li><h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5;\n</code></pre>\n<p>关键字<strong>let</strong>可以用在绑定表达式上。我们可以将一个变量名绑定给某个值或某个函数。此外，因为let表达式的左侧是一个“模式(pattern)”，所以你可以将多个变量名绑定给一组值或函数的值。</p>\n<p>关键字<strong>const</strong>被用来定义常量。它将在整个程序的运行生命里一直存在于一个固定的内存地址中。<strong>static</strong>关键字用来定义一个被认为有“全局变量”意义的类型。对于每个值来说，仅有一个实例，而且该实例<strong>在内存上的地址固定</strong>。</p>\n<p>💡 <strong>尽量使用常量</strong>，而不是静态变量。只有在极少的情况下，你需要你的“常量”有一个固定的内存地址。此外，常量在使用中会进行一些优化，这些优化不仅会在你的crate包中进行，也会惠及下游使用你的crate包的项目。</p>\n<p>💡 通常来说，静态部分通常都在代码文件的最前面，在函数之外。</p>\n"},{"title":"函数 - Functions","_content":"\n* 函数以 `fn` 关键字标记声明。\n* 当使用 **参数**时，你 **必须声明数据类型**。\n* 默认情况下，函数会 **返回一个空元组()**。 如果你需要返回一个值，**返回值类型需要在跟在‘->’符号后指定**\n\n### 第一个函数 - Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### 传参\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### 使用返回值\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 // 不要跟随分号;, 表示该行为一个表达式，并返回 a+1 的值\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // 也可以使用返回语句 return a+2; 但这不是一个好的实践\n    // 仅在条件性返回时使用return语句，在最终表达式中则不需要使用。\n}\n\n// ⭐️ 函数指针，可以作为一种数据类型被传递和使用\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; // 同上，包含着类型说明\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a7.functions.md","raw":"title: 函数 - Functions\n---\n\n* 函数以 `fn` 关键字标记声明。\n* 当使用 **参数**时，你 **必须声明数据类型**。\n* 默认情况下，函数会 **返回一个空元组()**。 如果你需要返回一个值，**返回值类型需要在跟在‘->’符号后指定**\n\n### 第一个函数 - Hello world\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n### 传参\n\n```rust\nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n```\n\n### 使用返回值\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1 // 不要跟随分号;, 表示该行为一个表达式，并返回 a+1 的值\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; // 也可以使用返回语句 return a+2; 但这不是一个好的实践\n    // 仅在条件性返回时使用return语句，在最终表达式中则不需要使用。\n}\n\n// ⭐️ 函数指针，可以作为一种数据类型被传递和使用\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; // 同上，包含着类型说明\nlet c = b(5); //6\n```\n","date":"2019-03-19T15:14:43.968Z","updated":"2019-03-19T15:14:43.968Z","path":"docs/zh-cn/a7.functions.html","_id":"cjtfwbj0r0016dwgpvoesav9t","comments":1,"layout":"page","content":"<ul>\n<li>函数以 <code>fn</code> 关键字标记声明。</li>\n<li>当使用 <strong>参数</strong>时，你 <strong>必须声明数据类型</strong>。</li>\n<li>默认情况下，函数会 <strong>返回一个空元组()</strong>。 如果你需要返回一个值，<strong>返回值类型需要在跟在‘-&gt;’符号后指定</strong></li>\n</ul>\n<h3 id=\"第一个函数-Hello-world\"><a href=\"#第一个函数-Hello-world\" class=\"headerlink\" title=\"第一个函数 - Hello world\"></a>第一个函数 - Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"传参\"><a href=\"#传参\" class=\"headerlink\" title=\"传参\"></a>传参</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"使用返回值\"><a href=\"#使用返回值\" class=\"headerlink\" title=\"使用返回值\"></a>使用返回值</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 // 不要跟随分号;, 表示该行为一个表达式，并返回 a+1 的值\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // 也可以使用返回语句 return a+2; 但这不是一个好的实践\n    // 仅在条件性返回时使用return语句，在最终表达式中则不需要使用。\n}\n\n// ⭐️ 函数指针，可以作为一种数据类型被传递和使用\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; // 同上，包含着类型说明\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li>函数以 <code>fn</code> 关键字标记声明。</li>\n<li>当使用 <strong>参数</strong>时，你 <strong>必须声明数据类型</strong>。</li>\n<li>默认情况下，函数会 <strong>返回一个空元组()</strong>。 如果你需要返回一个值，<strong>返回值类型需要在跟在‘-&gt;’符号后指定</strong></li>\n</ul>\n<h3 id=\"第一个函数-Hello-world\"><a href=\"#第一个函数-Hello-world\" class=\"headerlink\" title=\"第一个函数 - Hello world\"></a>第一个函数 - Hello world</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<h3 id=\"传参\"><a href=\"#传参\" class=\"headerlink\" title=\"传参\"></a>传参</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn print_sum(a: i8, b: i8) {\n    println!(&quot;sum is: {}&quot;, a + b);\n}\n</code></pre>\n<h3 id=\"使用返回值\"><a href=\"#使用返回值\" class=\"headerlink\" title=\"使用返回值\"></a>使用返回值</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1 // 不要跟随分号;, 表示该行为一个表达式，并返回 a+1 的值\n}\n\nfn plus_two(a: i32) -&gt; i32 {\n    return a + 2; // 也可以使用返回语句 return a+2; 但这不是一个好的实践\n    // 仅在条件性返回时使用return语句，在最终表达式中则不需要使用。\n}\n\n// ⭐️ 函数指针，可以作为一种数据类型被传递和使用\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -&gt; i32 = plus_one; // 同上，包含着类型说明\nlet c = b(5); //6\n</code></pre>\n"},{"title":"基础数据类型 - Primitive Data Types","_content":"\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ rust是强类型语言，bool类型不可以使用 TRUE, FALSE 或 1, 0 来替代\n```\n\n\n- ## char\n一个独立的Unicode标量\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ 不是 \"x\"，使用单引号包裹\n// 出于对Unicode的支持，char并不是单字节数据类型，每个char会占用4个字节\n```\n\n\n- ## i8, i16, i32, i64, i128\n固定尺寸（bit位数）有符号的整数类型(+/-)\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 每一类型的最大和最小值，取值范围为 **-2ⁿ⁻¹ 到 2ⁿ⁻¹-1**。你可以使用 **min_value()** 和 **max_value()** 方法来获取每个整型的最小与最大值，如：i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\n固定尺寸（bit位数）无符号非负整型\n\n| 数据类型   | 最小值 | 最大值                                 |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡非负整型取值范围从**0**至**2ⁿ-1**。同样地，你也可以使用**min_value()**和**max_value()**来寻找每个整型类型的最小和最大值，如：u8::max_value();\n\n\n- ## isize, usize\n同指针尺寸的带符号整型/非负整形\n\n该类型的实际占用bit位数取决于运行程序的计算机架构。默认情况下，在32位计算机上，该类型占用32位，在64位平台上则占用64位。\n\n> 🔎 更多内容可以查看Rust程序中的[交叉编译](https://github.com/rust-lang/rustup.rs#cross-compilation)和[Supported Tiers](https://forge.rust-lang.org/platform-support.html)等章节。\n\n\n- ## f32, f64\n内存占用为32和64位的浮点数（小数）\n\nRust遵循IEEE二进制浮点数算法标准。其中`f32`类型类似于其他语言中的float(**单精度浮点数**)，而`f64`则类似于其他语言中的double(**双精度浮点数**)。\n\n💡 在当前的情况下，推荐避免使用f32类型数据，除非你希望高度节省程序的内存使用，或者要运行你程序的目标设备不支持64位，或目标设备对32位程序进行了特殊优化。\n\n\n- ## 数组 - arrays\n固定尺寸的包含同质数据的有序数据容器。\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /空数组\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ 默认情况下，数组是**不可变(immutable)**的。并且，即使**带有`mut`关键字，也只能修改数组中的元素，而元素数量也是不可更改的**。\n\n> 🔎 如果你在寻找一个动态的/可增的数组，你可以使用**Vec**类型。Vector类型可以包含任意数量的元素，但仍要保持所有元素的类型统一。\n\n\n- ## 元组 - tuples\n固定大小的有序的同质/非同质数据所组成的列表。\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", 下划线 _ 意味着忽略该位置关联的元素\n\nlet g = (0,); // 单元素元组\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ 元组在默认情况下同样是**不可变**的，**即使使用了`mut`关键字，元组的元素数量也不可更改。同样地，如果你需要修改一个元素的值，新的值应该与元组中旧有的值拥有同一数据类型**。\n\n\n- ## 切片 - slice\n指向其他数据结构的可变尺寸的引用类型\n\n在某些场景下你可能需要获取或传递某个数组或其他数据类型的一部分。除了完整的将原始数据进行拷贝传递以外，Rust允许创建或传递一个指向原始数据的片段的视图/引用，这个引用既可以是可变的也可以是不可变的。 \n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];// 原始数组\n\nlet b: &[i32] = &a; // 完整的原始数组切片\nlet c = &a[0..4]; // 原始数组从第0个元素到第4个元素（不包含）的切片\nlet d = &a[..]; // 完整的原始数组切片\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\n不定尺寸的Unicode字串切片，由UTF-8字符组成的序列\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str 一个静态字串切片\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️  str是一个**不可变/静态的已分配内存的切片**，这个切片指向在内存中某处存有的一个**未知长度的UTF-8序列**。 **&str**用来借用并分配整个数列给一个特定的向变量绑定。\n\n> 🔎 一个[字串类型 - String](https://doc.rust-lang.org/std/string/struct.String.html)是一个在**堆 - heap**中进行分配的字串。这个字串是可增的UTF-8序列。字串类型通常由一个字串切片调用**to_string()**方法转换而来，也可由String类型的静态方法**String::from()**对字串切片进行转换而得到。如：`“Hello”.to_string();`或`String::from(\"Hello\");`\n\n💡 通常来说，在需要获取**所有权**时，你会使用到**String类型**，而在你仅需要**对一个字串执行借用**时，可以直接使用 **`&str`**。\n\n- ## functions\n正如我们在函数一节提到过的，`b` 是一个指向函数`plus_one()`的指针.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","source":"docs/zh-cn/a8.primitive_data_types.md","raw":"title: 基础数据类型 - Primitive Data Types\n---\n\n- ## bool\ntrue or false\n\n```rust\nlet x = true;\nlet y: bool = false;\n\n// ⭐️ rust是强类型语言，bool类型不可以使用 TRUE, FALSE 或 1, 0 来替代\n```\n\n\n- ## char\n一个独立的Unicode标量\n\n```rust\nlet x = 'x';\nlet y = '😎';\n\n// ⭐️ 不是 \"x\"，使用单引号包裹\n// 出于对Unicode的支持，char并不是单字节数据类型，每个char会占用4个字节\n```\n\n\n- ## i8, i16, i32, i64, i128\n固定尺寸（bit位数）有符号的整数类型(+/-)\n\n| DATA TYPE | MIN                                      | MAX                                     |\n| --------- | ---------------------------------------- | --------------------------------------- |\n| i8        | -128                                     | 127                                     |\n| i16       | -32768                                   | 32767                                   |\n| i32       | -2147483648                              | 2147483647                              |\n| i64       | -9223372036854775808                     | 9223372036854775807                     |\n| i128      | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |\n\n💡 每一类型的最大和最小值，取值范围为 **-2ⁿ⁻¹ 到 2ⁿ⁻¹-1**。你可以使用 **min_value()** 和 **max_value()** 方法来获取每个整型的最小与最大值，如：i8::min_value();\n\n\n- ## u8, u16, u32, u64, u128\n固定尺寸（bit位数）无符号非负整型\n\n| 数据类型   | 最小值 | 最大值                                 |\n| --------- | --- | --------------------------------------- |\n| u8        | 0   | 255                                     |\n| u16       | 0   | 65535                                   |\n| u32       | 0   | 4294967295                              |\n| u64       | 0   | 18446744073709551615                    |\n| u128      | 0   | 340282366920938463463374607431768211455 |\n\n💡非负整型取值范围从**0**至**2ⁿ-1**。同样地，你也可以使用**min_value()**和**max_value()**来寻找每个整型类型的最小和最大值，如：u8::max_value();\n\n\n- ## isize, usize\n同指针尺寸的带符号整型/非负整形\n\n该类型的实际占用bit位数取决于运行程序的计算机架构。默认情况下，在32位计算机上，该类型占用32位，在64位平台上则占用64位。\n\n> 🔎 更多内容可以查看Rust程序中的[交叉编译](https://github.com/rust-lang/rustup.rs#cross-compilation)和[Supported Tiers](https://forge.rust-lang.org/platform-support.html)等章节。\n\n\n- ## f32, f64\n内存占用为32和64位的浮点数（小数）\n\nRust遵循IEEE二进制浮点数算法标准。其中`f32`类型类似于其他语言中的float(**单精度浮点数**)，而`f64`则类似于其他语言中的double(**双精度浮点数**)。\n\n💡 在当前的情况下，推荐避免使用f32类型数据，除非你希望高度节省程序的内存使用，或者要运行你程序的目标设备不支持64位，或目标设备对32位程序进行了特殊优化。\n\n\n- ## 数组 - arrays\n固定尺寸的包含同质数据的有序数据容器。\n\n```rust\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -> [] /空数组\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n```\n\n⭐️ 默认情况下，数组是**不可变(immutable)**的。并且，即使**带有`mut`关键字，也只能修改数组中的元素，而元素数量也是不可更改的**。\n\n> 🔎 如果你在寻找一个动态的/可增的数组，你可以使用**Vec**类型。Vector类型可以包含任意数量的元素，但仍要保持所有元素的类型统一。\n\n\n- ## 元组 - tuples\n固定大小的有序的同质/非同质数据所组成的列表。\n\n```rust\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", 下划线 _ 意味着忽略该位置关联的元素\n\nlet g = (0,); // 单元素元组\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\")\n```\n\n⭐️ 元组在默认情况下同样是**不可变**的，**即使使用了`mut`关键字，元组的元素数量也不可更改。同样地，如果你需要修改一个元素的值，新的值应该与元组中旧有的值拥有同一数据类型**。\n\n\n- ## 切片 - slice\n指向其他数据结构的可变尺寸的引用类型\n\n在某些场景下你可能需要获取或传递某个数组或其他数据类型的一部分。除了完整的将原始数据进行拷贝传递以外，Rust允许创建或传递一个指向原始数据的片段的视图/引用，这个引用既可以是可变的也可以是不可变的。 \n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];// 原始数组\n\nlet b: &[i32] = &a; // 完整的原始数组切片\nlet c = &a[0..4]; // 原始数组从第0个元素到第4个元素（不包含）的切片\nlet d = &a[..]; // 完整的原始数组切片\n\nlet e = &a[1..3]; //[2, 3]\nlet f = &a[1..]; //[2, 3, 4]\nlet g = &a[..3]; //[1, 2, 3]\n```\n\n\n- ## str\n不定尺寸的Unicode字串切片，由UTF-8字符组成的序列\n\n```rust\nlet a = \"Hello, world.\"; //a: &'static str 一个静态字串切片\nlet b: &str = \"こんにちは, 世界!\";\n```\n\n⭐️  str是一个**不可变/静态的已分配内存的切片**，这个切片指向在内存中某处存有的一个**未知长度的UTF-8序列**。 **&str**用来借用并分配整个数列给一个特定的向变量绑定。\n\n> 🔎 一个[字串类型 - String](https://doc.rust-lang.org/std/string/struct.String.html)是一个在**堆 - heap**中进行分配的字串。这个字串是可增的UTF-8序列。字串类型通常由一个字串切片调用**to_string()**方法转换而来，也可由String类型的静态方法**String::from()**对字串切片进行转换而得到。如：`“Hello”.to_string();`或`String::from(\"Hello\");`\n\n💡 通常来说，在需要获取**所有权**时，你会使用到**String类型**，而在你仅需要**对一个字串执行借用**时，可以直接使用 **`&str`**。\n\n- ## functions\n正如我们在函数一节提到过的，`b` 是一个指向函数`plus_one()`的指针.\n\n```rust\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6\n```\n","date":"2019-03-21T02:41:48.177Z","updated":"2019-03-21T02:41:48.177Z","path":"docs/zh-cn/a8.primitive_data_types.html","_id":"cjtfwbj0s0017dwgp1vc8zh7b","comments":1,"layout":"page","content":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ rust是强类型语言，bool类型不可以使用 TRUE, FALSE 或 1, 0 来替代\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>一个独立的Unicode标量</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ 不是 &quot;x&quot;，使用单引号包裹\n// 出于对Unicode的支持，char并不是单字节数据类型，每个char会占用4个字节\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>固定尺寸（bit位数）有符号的整数类型(+/-)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 每一类型的最大和最小值，取值范围为 <strong>-2ⁿ⁻¹ 到 2ⁿ⁻¹-1</strong>。你可以使用 <strong>min_value()</strong> 和 <strong>max_value()</strong> 方法来获取每个整型的最小与最大值，如：i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>固定尺寸（bit位数）无符号非负整型</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>最小值</th>\n<th>最大值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡非负整型取值范围从<strong>0</strong>至<strong>2ⁿ-1</strong>。同样地，你也可以使用<strong>min_value()</strong>和<strong>max_value()</strong>来寻找每个整型类型的最小和最大值，如：u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>同指针尺寸的带符号整型/非负整形</li>\n</ul>\n<p>该类型的实际占用bit位数取决于运行程序的计算机架构。默认情况下，在32位计算机上，该类型占用32位，在64位平台上则占用64位。</p>\n<blockquote>\n<p>🔎 更多内容可以查看Rust程序中的<a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">交叉编译</a>和<a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a>等章节。</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>内存占用为32和64位的浮点数（小数）</li>\n</ul>\n<p>Rust遵循IEEE二进制浮点数算法标准。其中<code>f32</code>类型类似于其他语言中的float(<strong>单精度浮点数</strong>)，而<code>f64</code>则类似于其他语言中的double(<strong>双精度浮点数</strong>)。</p>\n<p>💡 在当前的情况下，推荐避免使用f32类型数据，除非你希望高度节省程序的内存使用，或者要运行你程序的目标设备不支持64位，或目标设备对32位程序进行了特殊优化。</p>\n<ul>\n<li><h2 id=\"数组-arrays\"><a href=\"#数组-arrays\" class=\"headerlink\" title=\"数组 - arrays\"></a>数组 - arrays</h2>固定尺寸的包含同质数据的有序数据容器。</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /空数组\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ 默认情况下，数组是<strong>不可变(immutable)</strong>的。并且，即使<strong>带有<code>mut</code>关键字，也只能修改数组中的元素，而元素数量也是不可更改的</strong>。</p>\n<blockquote>\n<p>🔎 如果你在寻找一个动态的/可增的数组，你可以使用<strong>Vec</strong>类型。Vector类型可以包含任意数量的元素，但仍要保持所有元素的类型统一。</p>\n</blockquote>\n<ul>\n<li><h2 id=\"元组-tuples\"><a href=\"#元组-tuples\" class=\"headerlink\" title=\"元组 - tuples\"></a>元组 - tuples</h2>固定大小的有序的同质/非同质数据所组成的列表。</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, 下划线 _ 意味着忽略该位置关联的元素\n\nlet g = (0,); // 单元素元组\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ 元组在默认情况下同样是<strong>不可变</strong>的，<strong>即使使用了<code>mut</code>关键字，元组的元素数量也不可更改。同样地，如果你需要修改一个元素的值，新的值应该与元组中旧有的值拥有同一数据类型</strong>。</p>\n<ul>\n<li><h2 id=\"切片-slice\"><a href=\"#切片-slice\" class=\"headerlink\" title=\"切片 - slice\"></a>切片 - slice</h2>指向其他数据结构的可变尺寸的引用类型</li>\n</ul>\n<p>在某些场景下你可能需要获取或传递某个数组或其他数据类型的一部分。除了完整的将原始数据进行拷贝传递以外，Rust允许创建或传递一个指向原始数据的片段的视图/引用，这个引用既可以是可变的也可以是不可变的。 </p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];// 原始数组\n\nlet b: &amp;[i32] = &amp;a; // 完整的原始数组切片\nlet c = &amp;a[0..4]; // 原始数组从第0个元素到第4个元素（不包含）的切片\nlet d = &amp;a[..]; // 完整的原始数组切片\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>不定尺寸的Unicode字串切片，由UTF-8字符组成的序列</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str 一个静态字串切片\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️  str是一个<strong>不可变/静态的已分配内存的切片</strong>，这个切片指向在内存中某处存有的一个<strong>未知长度的UTF-8序列</strong>。 <strong>&amp;str</strong>用来借用并分配整个数列给一个特定的向变量绑定。</p>\n<blockquote>\n<p>🔎 一个<a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">字串类型 - String</a>是一个在<strong>堆 - heap</strong>中进行分配的字串。这个字串是可增的UTF-8序列。字串类型通常由一个字串切片调用<strong>to_string()</strong>方法转换而来，也可由String类型的静态方法<strong>String::from()</strong>对字串切片进行转换而得到。如：<code>“Hello”.to_string();</code>或<code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 通常来说，在需要获取<strong>所有权</strong>时，你会使用到<strong>String类型</strong>，而在你仅需要<strong>对一个字串执行借用</strong>时，可以直接使用 <strong><code>&amp;str</code></strong>。</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>正如我们在函数一节提到过的，<code>b</code> 是一个指向函数<code>plus_one()</code>的指针.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<ul>\n<li><h2 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h2>true or false</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = true;\nlet y: bool = false;\n\n// ⭐️ rust是强类型语言，bool类型不可以使用 TRUE, FALSE 或 1, 0 来替代\n</code></pre>\n<ul>\n<li><h2 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char\"></a>char</h2>一个独立的Unicode标量</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let x = &#39;x&#39;;\nlet y = &#39;😎&#39;;\n\n// ⭐️ 不是 &quot;x&quot;，使用单引号包裹\n// 出于对Unicode的支持，char并不是单字节数据类型，每个char会占用4个字节\n</code></pre>\n<ul>\n<li><h2 id=\"i8-i16-i32-i64-i128\"><a href=\"#i8-i16-i32-i64-i128\" class=\"headerlink\" title=\"i8, i16, i32, i64, i128\"></a>i8, i16, i32, i64, i128</h2>固定尺寸（bit位数）有符号的整数类型(+/-)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>DATA TYPE</th>\n<th>MIN</th>\n<th>MAX</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i8</td>\n<td>-128</td>\n<td>127</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>-32768</td>\n<td>32767</td>\n</tr>\n<tr>\n<td>i32</td>\n<td>-2147483648</td>\n<td>2147483647</td>\n</tr>\n<tr>\n<td>i64</td>\n<td>-9223372036854775808</td>\n<td>9223372036854775807</td>\n</tr>\n<tr>\n<td>i128</td>\n<td>-170141183460469231731687303715884105728</td>\n<td>170141183460469231731687303715884105727</td>\n</tr>\n</tbody>\n</table>\n<p>💡 每一类型的最大和最小值，取值范围为 <strong>-2ⁿ⁻¹ 到 2ⁿ⁻¹-1</strong>。你可以使用 <strong>min_value()</strong> 和 <strong>max_value()</strong> 方法来获取每个整型的最小与最大值，如：i8::min_value();</p>\n<ul>\n<li><h2 id=\"u8-u16-u32-u64-u128\"><a href=\"#u8-u16-u32-u64-u128\" class=\"headerlink\" title=\"u8, u16, u32, u64, u128\"></a>u8, u16, u32, u64, u128</h2>固定尺寸（bit位数）无符号非负整型</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>最小值</th>\n<th>最大值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u8</td>\n<td>0</td>\n<td>255</td>\n</tr>\n<tr>\n<td>u16</td>\n<td>0</td>\n<td>65535</td>\n</tr>\n<tr>\n<td>u32</td>\n<td>0</td>\n<td>4294967295</td>\n</tr>\n<tr>\n<td>u64</td>\n<td>0</td>\n<td>18446744073709551615</td>\n</tr>\n<tr>\n<td>u128</td>\n<td>0</td>\n<td>340282366920938463463374607431768211455</td>\n</tr>\n</tbody>\n</table>\n<p>💡非负整型取值范围从<strong>0</strong>至<strong>2ⁿ-1</strong>。同样地，你也可以使用<strong>min_value()</strong>和<strong>max_value()</strong>来寻找每个整型类型的最小和最大值，如：u8::max_value();</p>\n<ul>\n<li><h2 id=\"isize-usize\"><a href=\"#isize-usize\" class=\"headerlink\" title=\"isize, usize\"></a>isize, usize</h2>同指针尺寸的带符号整型/非负整形</li>\n</ul>\n<p>该类型的实际占用bit位数取决于运行程序的计算机架构。默认情况下，在32位计算机上，该类型占用32位，在64位平台上则占用64位。</p>\n<blockquote>\n<p>🔎 更多内容可以查看Rust程序中的<a href=\"https://github.com/rust-lang/rustup.rs#cross-compilation\" target=\"_blank\" rel=\"noopener\">交叉编译</a>和<a href=\"https://forge.rust-lang.org/platform-support.html\" target=\"_blank\" rel=\"noopener\">Supported Tiers</a>等章节。</p>\n</blockquote>\n<ul>\n<li><h2 id=\"f32-f64\"><a href=\"#f32-f64\" class=\"headerlink\" title=\"f32, f64\"></a>f32, f64</h2>内存占用为32和64位的浮点数（小数）</li>\n</ul>\n<p>Rust遵循IEEE二进制浮点数算法标准。其中<code>f32</code>类型类似于其他语言中的float(<strong>单精度浮点数</strong>)，而<code>f64</code>则类似于其他语言中的double(<strong>双精度浮点数</strong>)。</p>\n<p>💡 在当前的情况下，推荐避免使用f32类型数据，除非你希望高度节省程序的内存使用，或者要运行你程序的目标设备不支持64位，或目标设备对32位程序进行了特殊优化。</p>\n<ul>\n<li><h2 id=\"数组-arrays\"><a href=\"#数组-arrays\" class=\"headerlink\" title=\"数组 - arrays\"></a>数组 - arrays</h2>固定尺寸的包含同质数据的有序数据容器。</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /空数组\nlet d: [i32; 3] = [1, 2, 3];\n\nlet e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];\n\nprintln!(&quot;{:?}&quot;, a); //[1, 2, 3]\nprintln!(&quot;{:#?}&quot;, a);\n//  [\n//      1,\n//      2,\n//      3\n//  ]\n</code></pre>\n<p>⭐️ 默认情况下，数组是<strong>不可变(immutable)</strong>的。并且，即使<strong>带有<code>mut</code>关键字，也只能修改数组中的元素，而元素数量也是不可更改的</strong>。</p>\n<blockquote>\n<p>🔎 如果你在寻找一个动态的/可增的数组，你可以使用<strong>Vec</strong>类型。Vector类型可以包含任意数量的元素，但仍要保持所有元素的类型统一。</p>\n</blockquote>\n<ul>\n<li><h2 id=\"元组-tuples\"><a href=\"#元组-tuples\" class=\"headerlink\" title=\"元组 - tuples\"></a>元组 - tuples</h2>固定大小的有序的同质/非同质数据所组成的列表。</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = (1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;);\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = &#39;a&#39;, a.4 = &quot;Hello, world!&quot;\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, 下划线 _ 意味着忽略该位置关联的元素\n\nlet g = (0,); // 单元素元组\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(&quot;{:?}&quot;, a); //(1, 1.5, true, &#39;a&#39;, &quot;Hello, world!&quot;)\n</code></pre>\n<p>⭐️ 元组在默认情况下同样是<strong>不可变</strong>的，<strong>即使使用了<code>mut</code>关键字，元组的元素数量也不可更改。同样地，如果你需要修改一个元素的值，新的值应该与元组中旧有的值拥有同一数据类型</strong>。</p>\n<ul>\n<li><h2 id=\"切片-slice\"><a href=\"#切片-slice\" class=\"headerlink\" title=\"切片 - slice\"></a>切片 - slice</h2>指向其他数据结构的可变尺寸的引用类型</li>\n</ul>\n<p>在某些场景下你可能需要获取或传递某个数组或其他数据类型的一部分。除了完整的将原始数据进行拷贝传递以外，Rust允许创建或传递一个指向原始数据的片段的视图/引用，这个引用既可以是可变的也可以是不可变的。 </p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a: [i32; 4] = [1, 2, 3, 4];// 原始数组\n\nlet b: &amp;[i32] = &amp;a; // 完整的原始数组切片\nlet c = &amp;a[0..4]; // 原始数组从第0个元素到第4个元素（不包含）的切片\nlet d = &amp;a[..]; // 完整的原始数组切片\n\nlet e = &amp;a[1..3]; //[2, 3]\nlet f = &amp;a[1..]; //[2, 3, 4]\nlet g = &amp;a[..3]; //[1, 2, 3]\n</code></pre>\n<ul>\n<li><h2 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h2>不定尺寸的Unicode字串切片，由UTF-8字符组成的序列</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str 一个静态字串切片\nlet b: &amp;str = &quot;こんにちは, 世界!&quot;;\n</code></pre>\n<p>⭐️  str是一个<strong>不可变/静态的已分配内存的切片</strong>，这个切片指向在内存中某处存有的一个<strong>未知长度的UTF-8序列</strong>。 <strong>&amp;str</strong>用来借用并分配整个数列给一个特定的向变量绑定。</p>\n<blockquote>\n<p>🔎 一个<a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" target=\"_blank\" rel=\"noopener\">字串类型 - String</a>是一个在<strong>堆 - heap</strong>中进行分配的字串。这个字串是可增的UTF-8序列。字串类型通常由一个字串切片调用<strong>to_string()</strong>方法转换而来，也可由String类型的静态方法<strong>String::from()</strong>对字串切片进行转换而得到。如：<code>“Hello”.to_string();</code>或<code>String::from(&quot;Hello&quot;);</code></p>\n</blockquote>\n<p>💡 通常来说，在需要获取<strong>所有权</strong>时，你会使用到<strong>String类型</strong>，而在你仅需要<strong>对一个字串执行借用</strong>时，可以直接使用 <strong><code>&amp;str</code></strong>。</p>\n<ul>\n<li><h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2>正如我们在函数一节提到过的，<code>b</code> 是一个指向函数<code>plus_one()</code>的指针.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn plus_one(a: i32) -&gt; i32 {\n    a + 1\n}\n\nlet b: fn(i32) -&gt; i32 = plus_one;\nlet c = b(5); //6\n</code></pre>\n"},{"title":"操作符","_content":"\n## 数学运算操作符\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 操作符 **+** 也被用来进行数列和字符串的连接**\n\n\n## 比较操作符\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## 逻辑运算操作符\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 对于整型来说，! 操作符会在整型的内存表示上对每一个独立bit取反。\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## 比特位操作符\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (内存值左移两位，末尾用0补足 -> '01'+'00' -> 100)\nlet g = a >> a; //0  (内存值右移两位，最末两位截断，左侧用0补足 -> o̶1̶ -> 0)\n```\n\n\n## 赋值运算符与符合赋值运算符\n\n操作符`=`用来为变量分配一个表达式（一个值或者一个function声明），也可以用来为一个类型标识分配类型定义。符合赋值操作符是由`+ - * / % & | ^ << >>`等操作符中的其中一员与赋值操作符`=`结合而成的.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## 类型转换操作符\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## 借用与解引用操作符\n& &mut *\n\n操作符 **& 或 &mut** 作为借用操作符使用，用以临时取得某变量的所有权，而*****操作符则用以在使用的过程中**解引Dereferencing**。\n\n> 🔎 更多信息可以参考[所有权 - Ownership](c1.ownership.html), [借用 - Borrowing](c2.borrowing.html) & [生命周期 - Lifetimes](c3.lifetimes.html)等章节。\n","source":"docs/zh-cn/a9.operators.md","raw":"title: 操作符\n---\n\n## 数学运算操作符\n** + - * / %**\n\n```rust\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n```\n\n> 💡 操作符 **+** 也被用来进行数列和字符串的连接**\n\n\n## 比较操作符\n== != < > <= >=\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// 🔎\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true\n```\n\n\n## 逻辑运算操作符\n! && ||\n\n```rust\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true\n```\n\n> 🔎 对于整型来说，! 操作符会在整型的内存表示上对每一个独立bit取反。\n\n```rust\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n```\n\n\n## 比特位操作符\n& | ^ << >>\n\n```rust\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (内存值左移两位，末尾用0补足 -> '01'+'00' -> 100)\nlet g = a >> a; //0  (内存值右移两位，最末两位截断，左侧用0补足 -> o̶1̶ -> 0)\n```\n\n\n## 赋值运算符与符合赋值运算符\n\n操作符`=`用来为变量分配一个表达式（一个值或者一个function声明），也可以用来为一个类型标识分配类型定义。符合赋值操作符是由`+ - * / % & | ^ << >>`等操作符中的其中一员与赋值操作符`=`结合而成的.\n\n```rust\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101̶0̶ -> 10 -> 2\n```\n\n\n## 类型转换操作符\nas\n\n```rust\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5\n```\n\n\n## 借用与解引用操作符\n& &mut *\n\n操作符 **& 或 &mut** 作为借用操作符使用，用以临时取得某变量的所有权，而*****操作符则用以在使用的过程中**解引Dereferencing**。\n\n> 🔎 更多信息可以参考[所有权 - Ownership](c1.ownership.html), [借用 - Borrowing](c2.borrowing.html) & [生命周期 - Lifetimes](c3.lifetimes.html)等章节。\n","date":"2019-03-21T03:16:34.549Z","updated":"2019-03-21T03:16:34.549Z","path":"docs/zh-cn/a9.operators.html","_id":"cjtfwbj0s0018dwgp6ej4s072","comments":1,"layout":"page","content":"<h2 id=\"数学运算操作符\"><a href=\"#数学运算操作符\" class=\"headerlink\" title=\"数学运算操作符\"></a>数学运算操作符</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 操作符 <strong>+</strong> 也被用来进行数列和字符串的连接**</p>\n</blockquote>\n<h2 id=\"比较操作符\"><a href=\"#比较操作符\" class=\"headerlink\" title=\"比较操作符\"></a>比较操作符</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"逻辑运算操作符\"><a href=\"#逻辑运算操作符\" class=\"headerlink\" title=\"逻辑运算操作符\"></a>逻辑运算操作符</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 对于整型来说，! 操作符会在整型的内存表示上对每一个独立bit取反。</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"比特位操作符\"><a href=\"#比特位操作符\" class=\"headerlink\" title=\"比特位操作符\"></a>比特位操作符</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (内存值左移两位，末尾用0补足 -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (内存值右移两位，最末两位截断，左侧用0补足 -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"赋值运算符与符合赋值运算符\"><a href=\"#赋值运算符与符合赋值运算符\" class=\"headerlink\" title=\"赋值运算符与符合赋值运算符\"></a>赋值运算符与符合赋值运算符</h2><p>操作符<code>=</code>用来为变量分配一个表达式（一个值或者一个function声明），也可以用来为一个类型标识分配类型定义。符合赋值操作符是由<code>+ - * / % &amp; | ^ &lt;&lt; &gt;&gt;</code>等操作符中的其中一员与赋值操作符<code>=</code>结合而成的.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"类型转换操作符\"><a href=\"#类型转换操作符\" class=\"headerlink\" title=\"类型转换操作符\"></a>类型转换操作符</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"借用与解引用操作符\"><a href=\"#借用与解引用操作符\" class=\"headerlink\" title=\"借用与解引用操作符\"></a>借用与解引用操作符</h2><p>&amp; &amp;mut *</p>\n<p>操作符 <strong>&amp; 或 &amp;mut</strong> 作为借用操作符使用，用以临时取得某变量的所有权，而<strong>*</strong>操作符则用以在使用的过程中<strong>解引Dereferencing</strong>。</p>\n<blockquote>\n<p>🔎 更多信息可以参考<a href=\"c1.ownership.html\">所有权 - Ownership</a>, <a href=\"c2.borrowing.html\">借用 - Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">生命周期 - Lifetimes</a>等章节。</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"数学运算操作符\"><a href=\"#数学运算操作符\" class=\"headerlink\" title=\"数学运算操作符\"></a>数学运算操作符</h2><p><strong> + - * / %</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // ⭐️ 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5\n</code></pre>\n<blockquote>\n<p>💡 操作符 <strong>+</strong> 也被用来进行数列和字符串的连接**</p>\n</blockquote>\n<h2 id=\"比较操作符\"><a href=\"#比较操作符\" class=\"headerlink\" title=\"比较操作符\"></a>比较操作符</h2><p>== != &lt; &gt; &lt;= &gt;=</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a &lt; b; //true\nlet f = a &gt; b; //false\nlet g = a &lt;= a; //true\nlet h = a &gt;= a; //true\n\n// 🔎\nlet i = true &gt; false; //true\nlet j = &#39;a&#39; &gt; &#39;A&#39;; //true\n</code></pre>\n<h2 id=\"逻辑运算操作符\"><a href=\"#逻辑运算操作符\" class=\"headerlink\" title=\"逻辑运算操作符\"></a>逻辑运算操作符</h2><p>! &amp;&amp; ||</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a &amp;&amp; b; //false\nlet e = a || b; //true\n</code></pre>\n<blockquote>\n<p>🔎 对于整型来说，! 操作符会在整型的内存表示上对每一个独立bit取反。</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2\n</code></pre>\n<h2 id=\"比特位操作符\"><a href=\"#比特位操作符\" class=\"headerlink\" title=\"比特位操作符\"></a>比特位操作符</h2><p>&amp; | ^ &lt;&lt; &gt;&gt;</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 1;\nlet b = 2;\n\nlet c = a &amp; b; //0  (01 &amp;&amp; 10 -&gt; 00)\nlet d = a | b; //3  (01 || 10 -&gt; 11)\nlet e = a ^ b; //3  (01 != 10 -&gt; 11)\nlet f = a &lt;&lt; b; //4  (内存值左移两位，末尾用0补足 -&gt; &#39;01&#39;+&#39;00&#39; -&gt; 100)\nlet g = a &gt;&gt; a; //0  (内存值右移两位，最末两位截断，左侧用0补足 -&gt; o̶1̶ -&gt; 0)\n</code></pre>\n<h2 id=\"赋值运算符与符合赋值运算符\"><a href=\"#赋值运算符与符合赋值运算符\" class=\"headerlink\" title=\"赋值运算符与符合赋值运算符\"></a>赋值运算符与符合赋值运算符</h2><p>操作符<code>=</code>用来为变量分配一个表达式（一个值或者一个function声明），也可以用来为一个类型标识分配类型定义。符合赋值操作符是由<code>+ - * / % &amp; | ^ &lt;&lt; &gt;&gt;</code>等操作符中的其中一员与赋值操作符<code>=</code>结合而成的.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2\na |= 5; //010 || 101 -&gt; 111 -&gt; 7\na ^= 2; //111 != 010 -&gt; 101 -&gt; 5\na &lt;&lt;= 1; //&#39;101&#39;+&#39;0&#39; -&gt; 1010 -&gt; 10\na &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2\n</code></pre>\n<h2 id=\"类型转换操作符\"><a href=\"#类型转换操作符\" class=\"headerlink\" title=\"类型转换操作符\"></a>类型转换操作符</h2><p>as</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let a = 15;\nlet b = (a as f64) / 2.0; //7.5\n</code></pre>\n<h2 id=\"借用与解引用操作符\"><a href=\"#借用与解引用操作符\" class=\"headerlink\" title=\"借用与解引用操作符\"></a>借用与解引用操作符</h2><p>&amp; &amp;mut *</p>\n<p>操作符 <strong>&amp; 或 &amp;mut</strong> 作为借用操作符使用，用以临时取得某变量的所有权，而<strong>*</strong>操作符则用以在使用的过程中<strong>解引Dereferencing</strong>。</p>\n<blockquote>\n<p>🔎 更多信息可以参考<a href=\"c1.ownership.html\">所有权 - Ownership</a>, <a href=\"c2.borrowing.html\">借用 - Borrowing</a> &amp; <a href=\"c3.lifetimes.html\">生命周期 - Lifetimes</a>等章节。</p>\n</blockquote>\n"},{"title":"Structs","_content":"\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","source":"docs/zh-cn/b2.structs.md","raw":"title: Structs\n---\n\n⭐️ Structs are used to **encapsulate related properties** into one unified datatype.\n\n💡 By convention, the name of the struct starts with a capital letter and follows **CamelCase**.\n\nThere are 3 variants of structs,  \n1. **C-like structs**\n  * one or more comma separated name:value pairs\n  * brace-enclosed  list\n  * similar to classes \\(without its methods\\) in OOP languages\n  * because fields have names, we can access them through dot notation\n\n2. **Tuple structs**\n  * one or more comma separated values\n  * parenthesized list like tuples\n  * looks like a named tuples\n\n3. **Unit structs**\n  * a struct with no members at all\n  * it defines a new type but it resembles an empty tuple, \\(\\)\n  * rarely in use,  useful with generics\n\n⭐️ When regarding OOP in Rust, attributes and methods are placed separately on **structs** and **traits**. Structs contain only attributes, traits contain only methods. They are getting connected via **impls**.\n\n>💡More complex examples can be found on [impls & traits](b5.impls_and_traits.html), [lifetimes](c3.lifetimes.html) and [modules](d3.modules.html) sections.\n\n## C-like structs\n\n```rust\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n```\n\n## Tuple structs\n\n⭐️ When a tuple struct  has only one element, we call it **new type pattern**. Because it helps to create a new type.\n\n```rust\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n}\n```\n\n## Unit structs\n\nThis is rarely useful on its own, but in combination with other features it can become useful.\n\n> [📖](https://doc.rust-lang.org/book/first-edition/structs.html) ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.\n\n```rust\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b2.structs.html","comments":1,"layout":"page","_id":"cjtfwbj0t0019dwgpb7flqj20","content":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified datatype.</p>\n<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>\n<p>There are 3 variants of structs,  </p>\n<ol>\n<li><p><strong>C-like structs</strong></p>\n<ul>\n<li>one or more comma separated name:value pairs</li>\n<li>brace-enclosed  list</li>\n<li>similar to classes (without its methods) in OOP languages</li>\n<li>because fields have names, we can access them through dot notation</li>\n</ul>\n</li>\n<li><p><strong>Tuple structs</strong></p>\n<ul>\n<li>one or more comma separated values</li>\n<li>parenthesized list like tuples</li>\n<li>looks like a named tuples</li>\n</ul>\n</li>\n<li><p><strong>Unit structs</strong></p>\n<ul>\n<li>a struct with no members at all</li>\n<li>it defines a new type but it resembles an empty tuple, ()</li>\n<li>rarely in use,  useful with generics</li>\n</ul>\n</li>\n</ol>\n<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>\n<blockquote>\n<p>💡More complex examples can be found on <a href=\"b5.impls_and_traits.html\">impls &amp; traits</a>, <a href=\"c3.lifetimes.html\">lifetimes</a> and <a href=\"d3.modules.html\">modules</a> sections.</p>\n</blockquote>\n<h2 id=\"C-like-structs\"><a href=\"#C-like-structs\" class=\"headerlink\" title=\"C-like structs\"></a>C-like structs</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing its fields using dot notation\n  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn&#39;t support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions &amp; accessing its fields\n  let midnightblue = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -&gt; Color {\n    Color {red: 25, green: 25, blue: 112}\n}\n</code></pre>\n<h2 id=\"Tuple-structs\"><a href=\"#Tuple-structs\" class=\"headerlink\" title=\"Tuple structs\"></a>Tuple structs</h2><p>⭐️ When a tuple struct  has only one element, we call it <strong>new type pattern</strong>. Because it helps to create a new type.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km\n}\n</code></pre>\n<h2 id=\"Unit-structs\"><a href=\"#Unit-structs\" class=\"headerlink\" title=\"Unit structs\"></a>Unit structs</h2><p>This is rarely useful on its own, but in combination with other features it can become useful.</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/structs.html\" target=\"_blank\" rel=\"noopener\">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Electron;\n\nfn main() {\n  let x = Electron;\n}\n</code></pre>\n"},{"title":"Vectors","_content":"\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","source":"docs/zh-cn/b1.vectors.md","raw":"title: Vectors\n---\n\nIf you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of **a re-sizable array** but **all elements must be in the same type**.\n\n⭐️ It’s a generic type, written as **`Vec<T>`** . T can have any type, ex. The type of a Vec of i32s is `Vec<i32>`. Also, Vectors always allocate their data in dynamically allocated heap.\n\n### Create empty vector\n\n```rust\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n```\n\n### Create with data types\n\n```rust\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n```\n\n### Access and change data\n\n```rust\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n```\n\n⭐️ Mainly a vector represent 3 things,\n- a **pointer** to the data\n- **No of elements** currently have(**length**)\n- **capacity** (Amount of space allocated for any future elements). \n\nIf the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::**with_capacity** whenever it’s possible.\n\n> 💡 **String** data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.\n\n\n💯 Vectors can be used with iterators in three ways,\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b1.vectors.html","comments":1,"layout":"page","_id":"cjtfwbj0t001adwgpslrthp7r","content":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>If you remember, array is a  fixed-size list of elements, of same data type. Even with mut, its element count can not be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>\n<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in dynamically allocated heap.</p>\n<h3 id=\"Create-empty-vector\"><a href=\"#Create-empty-vector\" class=\"headerlink\" title=\"Create empty vector\"></a>Create empty vector</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n</code></pre>\n<h3 id=\"Create-with-data-types\"><a href=\"#Create-with-data-types\" class=\"headerlink\" title=\"Create with data types\"></a>Create with data types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut a2: Vec&lt;i32&gt; = Vec::new();\nlet mut b2: Vec&lt;i32&gt; = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n</code></pre>\n<h3 id=\"Access-and-change-data\"><a href=\"#Access-and-change-data\" class=\"headerlink\" title=\"Access and change data\"></a>Access and change data</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can&#39;t assign values this way, index out of bounds\nprintln!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec&lt;i32&gt; = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n\n// 🔎 Capacity and reallocation\nlet mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);\nprintln!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11);\n</code></pre>\n<p>⭐️ Mainly a vector represent 3 things,</p>\n<ul>\n<li>a <strong>pointer</strong> to the data</li>\n<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>\n<li><strong>capacity</strong> (Amount of space allocated for any future elements). </li>\n</ul>\n<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>\n<blockquote>\n<p>💡 <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>\n</blockquote>\n<p>💯 Vectors can be used with iterators in three ways,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">let mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &amp;v {\n    println!(&quot;A reference to {}&quot;, i);\n}\n\nfor i in &amp;mut v {\n    println!(&quot;A mutable reference to {}&quot;, i);\n}\n\nfor i in v {\n    println!(&quot;Take ownership of the vector and its element {}&quot;, i);\n}\n</code></pre>\n"},{"title":"Generics","_content":"\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","source":"docs/zh-cn/b4.generics.md","raw":"title: Generics\n---\n\n> [📖](https://doc.rust-lang.org/beta/book/first-edition/generics.html) Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.\n\n💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, **instead x : u8** we use **x : T** . but we have to inform to the compiler that T is a generic type(can be any type) by adding `<T>` at first.\n\n### Generalizing functions\n\n```rust\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n```\n\n### Generalizing structs\n\n```rust\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n```\n\n### Generalizing enums\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n> ⭐️ Above [Option](https://doc.rust-lang.org/std/option/index.html) and [Result](https://doc.rust-lang.org/std/result/index.html) types are kind of special generic types which are already defined in Rust’s standard library. \n  * An **optional value** can have either **Some** value or no value/ **None**.\n  * A **result** can represent either success/ **Ok** or failure/ **Err**\n\n #### Usages of Option\n \n```rust\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//💭 Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\";\n    match get_id_by_username(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n}\n```\n\n #### Usages of Result\n \n> [📖](https://doc.rust-lang.org/book/first-edition/error-handling.html) The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.\n\n```rust\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n}\n```\n\n\n> 🔎 Many useful methods have been implemented around Option and Result types. More information can be found on [std::option::Option](https://doc.rust-lang.org/std/option/enum.Option.html) and [std::result::Result](https://doc.rust-lang.org/std/result/enum.Result.html) pages on Rust doc.\n\n⭐️ Also **more practical examples** of options & results can be found on [Error Handling](https://doc.rust-lang.org/book/first-edition/error-handling.html) section in  Rust doc.\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/b4.generics.html","comments":1,"layout":"page","_id":"cjtfwbj0u001bdwgpsqvdxo62","content":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://doc.rust-lang.org/beta/book/first-edition/generics.html\" target=\"_blank\" rel=\"noopener\">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>\n</blockquote>\n<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>\n<h3 id=\"Generalizing-functions\"><a href=\"#Generalizing-functions\" class=\"headerlink\" title=\"Generalizing functions\"></a>Generalizing functions</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things&lt;T, U&gt;(x: T, y: U) { // multiple types\n}\n</code></pre>\n<h3 id=\"Generalizing-structs\"><a href=\"#Generalizing-structs\" class=\"headerlink\" title=\"Generalizing structs\"></a>Generalizing structs</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Point&lt;T&gt; {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// 🔎 When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl&lt;T&gt; Point&lt;T&gt; {\n</code></pre>\n<h3 id=\"Generalizing-enums\"><a href=\"#Generalizing-enums\" class=\"headerlink\" title=\"Generalizing enums\"></a>Generalizing enums</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n<blockquote>\n<p>⭐️ Above <a href=\"https://doc.rust-lang.org/std/option/index.html\" target=\"_blank\" rel=\"noopener\">Option</a> and <a href=\"https://doc.rust-lang.org/std/result/index.html\" target=\"_blank\" rel=\"noopener\">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>\n<ul>\n<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>\n<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"Usages-of-Option\"><a href=\"#Usages-of-Option\" class=\"headerlink\" title=\"Usages of Option\"></a>Usages of Option</h4><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//💭 So on above function, instead of setting return type as usize\n// set return type as Option&lt;usize&gt;\n//Instead of return userId, return Some(userId)\n// else None (💡remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option&lt;Person&gt;,\n}\n\n//💭 Instead of assignee: Person, we use Option&lt;Person&gt;\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = &quot;anonymous&quot;;\n    match get_id_by_username(username) {\n        None =&gt; println!(&quot;User not found&quot;),\n        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)\n    }\n}\n</code></pre>\n<h4 id=\"Usages-of-Result\"><a href=\"#Usages-of-Result\" class=\"headerlink\" title=\"Usages of Result\"></a>Usages of Result</h4><blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {\n  //if the file is not found on the system, return error\n    return Err(&quot;File can not be found!&quot;)\n  //else, count and return the word count\n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//💭 on above function,\n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = &quot;file_a&quot;;\n    match get_word_count_from_file(file_name) {\n        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),\n        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)\n    }\n}\n</code></pre>\n<blockquote>\n<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" target=\"_blank\" rel=\"noopener\">std::option::Option</a> and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\" rel=\"noopener\">std::result::Result</a> pages on Rust doc.</p>\n</blockquote>\n<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html\" target=\"_blank\" rel=\"noopener\">Error Handling</a> section in  Rust doc.</p>\n"},{"title":"Impls & Traits","_content":"\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","source":"docs/zh-cn/b5.impls_and_traits.md","raw":"title: Impls & Traits\n---\n\n💡 When we discussed about **C-like structs**, I mentioned that those are **similar to classes** in OOP languages, **but without their methods**. **impls** are **used to define methods** for Rust structs and enums.\n\n💡 **Traits** are kind of **similar to interfaces** in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.\n\n⭐️️ But traits **can also include default implementations of methods**. Default methods can be overriden when implementing types.\n\n### Impls without traits\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n```\n\n### Impls & traits, without default methods\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n```\n\n### Impls, traits & default methods\n\n```rust\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n```\n\n⭐️ As you can see methods take a **special first parameter**, the type itself. It can be **either self, &self, or &mut self**; self if it’s a value on the stack (taking ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.\n\n### Impls with Associated functions\n\nSome other languages support **static methods**. At such times, we **call a function directly** through the class without creating an object. In Rust, we call them Associated Functions. we use **::**  instead of . when calling them from struct.\nex. Person::new(“Elon Musk Jr”);\n\n\n```rust\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n```\n\n### Traits with generics\n\n```rust\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 {\n        //...\n    }\n    impl From<u8> for u32{\n        //...\n    }\n    \n//should specify after the trait name like generic functions\n```\n\n### Traits inheritance\n\n```rust\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    }\n```\n\n### Trait objects\n\n🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’\n\n> [🅆](https://en.wikipedia.org/wiki/Dynamic_dispatch) **Dynamic dispatch** is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.\n\n\n```rust\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n}\n```\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/b5.impls_and_traits.html","comments":1,"layout":"page","_id":"cjtfwbj0u001cdwgpivlw7oqm","content":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages, <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>\n<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>\n<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overriden when implementing types.</p>\n<h3 id=\"Impls-without-traits\"><a href=\"#Impls-without-traits\" class=\"headerlink\" title=\"Impls without traits\"></a>Impls without traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: &quot;Rafael&quot;.to_string(),\n        last_name: &quot;Nadal&quot;.to_string(),\n    };\n\n    println!(&quot;Player 01: {}&quot;, player_1.full_name());\n}\n\n// ⭐️ Implementation must appear in the same crate as the self type\n\n// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n</code></pre>\n<h3 id=\"Impls-amp-traits-without-default-methods\"><a href=\"#Impls-amp-traits-without-default-methods\" class=\"headerlink\" title=\"Impls &amp; traits, without default methods\"></a>Impls &amp; traits, without default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&amp;self) -&gt; String;\n}\n\nimpl FullName for Player {\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: &quot;Roger&quot;.to_string(),\n        last_name: &quot;Federer&quot;.to_string(),\n    };\n\n    println!(&quot;Player 02: {}&quot;, player_2.full_name());\n}\n\n// 🔎 Other than functions, traits can contain constants and types\n</code></pre>\n<h3 id=\"Impls-traits-amp-default-methods\"><a href=\"#Impls-traits-amp-default-methods\" class=\"headerlink\" title=\"Impls, traits &amp; default methods\"></a>Impls, traits &amp; default methods</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Foo {\n    fn bar(&amp;self);\n    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }\n}\n</code></pre>\n<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>\n<h3 id=\"Impls-with-Associated-functions\"><a href=\"#Impls-with-Associated-functions\" class=\"headerlink\" title=\"Impls with Associated functions\"></a>Impls with Associated functions</h3><p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from struct.<br>ex. Person::new(“Elon Musk Jr”);</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -&gt; Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&amp;self) -&gt; String {\n        format!(&quot;{} {}&quot;, self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();\n    println!(&quot;Player: {}&quot;, player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// 🔎 Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name()\n// calls, we can use a single statement with Method Chaining.\n// ex. player.add_points(2).get_point_count();\n</code></pre>\n<h3 id=\"Traits-with-generics\"><a href=\"#Traits-with-generics\" class=\"headerlink\" title=\"Traits with generics\"></a>Traits with generics</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n    impl From&lt;u8&gt; for u16 {\n        //...\n    }\n    impl From&lt;u8&gt; for u32{\n        //...\n    }\n\n//should specify after the trait name like generic functions\n</code></pre>\n<h3 id=\"Traits-inheritance\"><a href=\"#Traits-inheritance\" class=\"headerlink\" title=\"Traits inheritance\"></a>Traits inheritance</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait Person {\n    fn full_name(&amp;self) -&gt; String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&amp;self) -&gt; String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&amp;self) -&gt; f64;\n    }\n</code></pre>\n<h3 id=\"Trait-objects\"><a href=\"#Trait-objects\" class=\"headerlink\" title=\"Trait objects\"></a>Trait objects</h3><p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_dispatch\" target=\"_blank\" rel=\"noopener\">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">trait GetSound {\n    fn get_sound(&amp;self) -&gt; String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&amp;self) -&gt; String {\n            self.sound.clone()\n        }\n    }\n\n\nfn make_sound&lt;T: GetSound&gt;(t: &amp;T) {\n    println!(&quot;{}!&quot;, t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };\n    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };\n\n    make_sound(&amp;kitty); // Meow!\n    make_sound(&amp;the_bell); // Ding Dong!\n}\n</code></pre>\n"},{"title":"Enums","_content":"\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","source":"docs/zh-cn/b3.enums.md","raw":"title: Enums\n---\n\n⭐️ An **enum** is a single type. It contains **variants**, which are possible values of the enum at a given time. For example,\n\n```rust\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n```\n\n⭐️ Variants can be accessed through :: notation , ex. Day::Sunday\n\n⭐️ Each enum **variant** can have,\n* no data (unit variant)\n* unnamed ordered data (tuple variant)\n* named data (struct variant)\n\n\n```rust\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =>\n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) =>\n      println!(\"Error : {}\", msg)\n  }\n}\n```\n","date":"2019-03-19T14:50:31.983Z","updated":"2019-03-19T14:50:31.983Z","path":"docs/zh-cn/b3.enums.html","comments":1,"layout":"page","_id":"cjtfwbj0u001ddwgppvexglti","content":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants\n</code></pre>\n<p>⭐️ Variants can be accessed through :: notation , ex. Day::Sunday</p>\n<p>⭐️ Each enum <strong>variant</strong> can have,</p>\n<ul>\n<li>no data (unit variant)</li>\n<li>unnamed ordered data (tuple variant)</li>\n<li>named data (struct variant)</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">enum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success =&gt;\n      println!(&quot;Form Submitted correctly&quot;),\n    FlashMessage::Warning {category, message} =&gt; //Destructure, should use same field names\n      println!(&quot;Warning : {} - {}&quot;, category, message),\n    FlashMessage::Error(msg) =&gt;\n      println!(&quot;Error : {}&quot;, msg)\n  }\n}\n</code></pre>\n"},{"title":"Ownership","_content":"\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","source":"docs/zh-cn/c1.ownership.md","raw":"title: Ownership\n---\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n}\n```\n\nIn the above examples, we are just trying to **assign the value of ‘a’ to ‘b’** . Almost the same code in both code blocks, but having **two different data types**. And the second one gives an error. This is because of the **Ownership**.\n\n\n## What is ownership?\n\n⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of data can only have **one owner at a time**. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves **memory safety**.\n\n> [Ownership \\(noun\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> The act, state, or right of possessing something.\n\n## Copy types & move types\n⭐️ **When assigning** a variable binding to another variable binding **or when passing it to a function**\\(Without referencing\\), if its data type is a\n\n1. **Copy Type**\n   * Bound resources are **made a copy and assign** or pass it to the function.\n   * The ownership state of the original bindings are set to **“copied” state**.\n   * **Mostly Primitive types**\n2. **Move type**\n   * Bound resources are **moved** to the new variable binding and we **can not access the original variable binding** anymore.\n   * The ownership state of the original bindings are set to **“moved” state**.\n   * **Non-primitive types**\n\n> 🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) , it has a 'copy semantics'.\n\n\n💡 **So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.**\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/c1.ownership.html","comments":1,"layout":"page","_id":"cjtfwbj0v001edwgpo6qfondt","content":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`\n}\n</code></pre>\n<p>In the above examples, we are just trying to <strong>assign the value of ‘a’ to ‘b’</strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>\n<h2 id=\"What-is-ownership\"><a href=\"#What-is-ownership\" class=\"headerlink\" title=\"What is ownership?\"></a>What is ownership?</h2><p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>\n<blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Ownership (noun)</a><br>The act, state, or right of possessing something.</p>\n</blockquote>\n<h2 id=\"Copy-types-amp-move-types\"><a href=\"#Copy-types-amp-move-types\" class=\"headerlink\" title=\"Copy types &amp; move types\"></a>Copy types &amp; move types</h2><p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>\n<ol>\n<li><strong>Copy Type</strong><ul>\n<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>\n<li>The ownership state of the original bindings are set to <strong>“copied” state</strong>.</li>\n<li><strong>Mostly Primitive types</strong></li>\n</ul>\n</li>\n<li><strong>Move type</strong><ul>\n<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>\n<li>The ownership state of the original bindings are set to <strong>“moved” state</strong>.</li>\n<li><strong>Non-primitive types</strong></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href=\"https://doc.rust-lang.org/core/marker/trait.Copy.html\" target=\"_blank\" rel=\"noopener\"><strong>core::marker::Copy trait</strong></a> , it has a ‘copy semantics’.</p>\n</blockquote>\n<p>💡 <strong>So in the above second example, ownership of the Vec object moves to “b” and “a” doesn’t have any ownership to access the resource.</strong></p>\n"},{"title":"Borrowing","_content":"\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","source":"docs/zh-cn/c2.borrowing.md","raw":"title: Borrowing\n---\n\nIn real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.\n\n## What is Borrowing?\n\n> [Borrow \\(verb\\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  \n> To receive something with the promise of returning it.\n\n## Shared & Mutable borrowings\n\n⭐️ There are two types of Borrowing,\n\n1. **Shared Borrowing** `(&T)`\n\n   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.\n\n2. **Mutable Borrowing** `(&mut T)`\n\n   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.\n\n## Rules for borrowings\n\nThere are very important rules regarding borrowing,\n\n1. One piece of data can be borrowed **either** as a shared borrow **or** as a mutable borrow **at a given time. But not both at the same time**.\n\n2. Borrowing **applies for both copy types and move types**.\n\n3. The concept of **Liveness** ↴\n\n```rust\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n}\n```\n\n💡 Let’s see how to use shared and mutable borrowings in examples.\n\n### Examples for Shared Borrowing\n\n```rust\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n}\n```\n\n### Examples for Mutable Borrowing\n\n```rust\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n}\n```\n","date":"2019-03-19T14:50:31.984Z","updated":"2019-03-19T14:50:31.984Z","path":"docs/zh-cn/c2.borrowing.html","comments":1,"layout":"page","_id":"cjtfwbj0v001fdwgppxt1rnoy","content":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>\n<h2 id=\"What-is-Borrowing\"><a href=\"#What-is-Borrowing\" class=\"headerlink\" title=\"What is Borrowing?\"></a>What is Borrowing?</h2><blockquote>\n<p><a href=\"https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf\" target=\"_blank\" rel=\"noopener\">Borrow (verb)</a><br>To receive something with the promise of returning it.</p>\n</blockquote>\n<h2 id=\"Shared-amp-Mutable-borrowings\"><a href=\"#Shared-amp-Mutable-borrowings\" class=\"headerlink\" title=\"Shared &amp; Mutable borrowings\"></a>Shared &amp; Mutable borrowings</h2><p>⭐️ There are two types of Borrowing,</p>\n<ol>\n<li><p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>\n<ul>\n<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Rules-for-borrowings\"><a href=\"#Rules-for-borrowings\" class=\"headerlink\" title=\"Rules for borrowings\"></a>Rules for borrowings</h2><p>There are very important rules regarding borrowing,</p>\n<ol>\n<li><p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>\n</li>\n<li><p>Borrowing <strong>applies for both copy types and move types</strong>.</p>\n</li>\n<li><p>The concept of <strong>Liveness</strong> ↴</p>\n</li>\n</ol>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n                   //  ⁝\n  // some code     //  ⁝\n  // some code     //  ⁝\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n  // some code\n\n  println!(&quot;{:?}&quot;, a); // trying to access a as a shared borrow, so giving error\n}                  //  &amp;mut borrow of a ends here\n\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &amp;mut a;  //  &amp;mut borrow of a starts here\n    // any other code\n  }                  //  &amp;mut borrow of a ends here\n\n  println!(&quot;{:?}&quot;, a); // allow to borrow a as a shared borrow\n}\n</code></pre>\n<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>\n<h3 id=\"Examples-for-Shared-Borrowing\"><a href=\"#Examples-for-Shared-Borrowing\" class=\"headerlink\" title=\"Examples for Shared Borrowing\"></a>Examples for Shared Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let a = [1, 2, 3];\n    let b = &amp;a;\n    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1\n}\n\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&amp;a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    a[0]\n}\n</code></pre>\n<h3 id=\"Examples-for-Mutable-Borrowing\"><a href=\"#Examples-for-Mutable-Borrowing\" class=\"headerlink\" title=\"Examples for Mutable Borrowing\"></a>Examples for Mutable Borrowing</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    let mut a = [1, 2, 3];\n    let b = &amp;mut a;\n    b[0] = 4;\n    println!(&quot;{:?}&quot;, b); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &amp;mut a;\n        b[0] = 4;\n    }\n\n    println!(&quot;{:?}&quot;, a); // [4, 2, 3]\n}\n\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&amp;mut a);\n\n    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    a[0] = 4;\n    a[0]\n}\n</code></pre>\n"},{"title":"Functions","_content":"\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","source":"docs/zh-cn/d2.functions.md","raw":"title: Functions\n---\n\nFunctions are the first line of organization in any program.\n\n```rust\nfn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(\"Hello!\");\n}\n\nfn ask_location() {\n  println!(\"Where are you from?\");\n}\n```\n\nWe can add unit tests in the same file.\n\n```rust\nfn main() {\n    greet();\n}\n\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(\"Hello, world!\", greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n```\n\n> 💭 An [attribute](https://doc.rust-lang.org/reference/attributes.html) is a general, free-form **metadatum** that is interpreted according to name, convention, and language and compiler version.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d2.functions.html","comments":1,"layout":"page","_id":"cjtfwbj0w001gdwgpgro3j6o2","content":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Functions are the first line of organization in any program.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greet(); //do one thing\n  ask_location(); //do another thing\n}\n\nfn greet() {\n  println!(&quot;Hello!&quot;);\n}\n\nfn ask_location() {\n  println!(&quot;Where are you from?&quot;);\n}\n</code></pre>\n<p>We can add unit tests in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n    greet();\n}\n\nfn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[test] // test attribute indicates, this is a test function\nfn test_greet() {\n    assert_eq!(&quot;Hello, world!&quot;, greet())\n}\n\n// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. \n// cfg(test) module compiles only when running tests. We discuss more about this in next section.\n</code></pre>\n<blockquote>\n<p>💭 An <a href=\"https://doc.rust-lang.org/reference/attributes.html\" target=\"_blank\" rel=\"noopener\">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>\n</blockquote>\n"},{"title":"Code Organization","_content":"\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","source":"docs/zh-cn/d1.code_organization.md","raw":"title: Code Organization\n---\n\nWhen a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.\n\n1. ### Functions\n2. ### Modules\n\n  Can be mapped to a,\n  \n  - **Inline module**\n  - **File** \n  - **Directory hierarchy**\n  \n3. ### Crates\n\n  Can be mapped to a, \n  - **lib.rs file on the same executable crate**\n  - **Dependency crate specified on Cargo.toml**\n    \n    Can be specified from,\n    \n    - **path**\n    - **git repository**\n    - **crates.io**\n4. ### Workspaces\n\n  Helps to manage multiple crates as a single project.\n\n\nLet’s discuss one by one.\n\n> 💡 To make examples more simpler, we use a simple function which prints `“Hello, world!”`. But regarding writing testable codes, always try to return the `String` from the function and print it when calling it, instead printing the String inside the function.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d1.code_organization.html","comments":1,"layout":"page","_id":"cjtfwbj0w001hdwgpj48l8ct0","content":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>\n<ol>\n<li><h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3></li>\n<li><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Can be mapped to a,</p>\n<ul>\n<li><strong>Inline module</strong></li>\n<li><strong>File</strong> </li>\n<li><strong>Directory hierarchy</strong></li>\n</ul>\n</li>\n<li><h3 id=\"Crates\"><a href=\"#Crates\" class=\"headerlink\" title=\"Crates\"></a>Crates</h3><p>Can be mapped to a, </p>\n<ul>\n<li><strong>lib.rs file on the same executable crate</strong></li>\n<li><p><strong>Dependency crate specified on Cargo.toml</strong></p>\n<p>Can be specified from,</p>\n<ul>\n<li><strong>path</strong></li>\n<li><strong>git repository</strong></li>\n<li><strong>crates.io</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Workspaces\"><a href=\"#Workspaces\" class=\"headerlink\" title=\"Workspaces\"></a>Workspaces</h3><p>Helps to manage multiple crates as a single project.</p>\n</li>\n</ol>\n<p>Let’s discuss one by one.</p>\n<blockquote>\n<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead printing the String inside the function.</p>\n</blockquote>\n"},{"title":"Modules","_content":"\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","source":"docs/zh-cn/d3.modules.md","raw":"title: Modules\n---\n\n## 01. In same file\n\nRelated code and data are grouped into a module and stored in the same file.\n\n```rust\nfn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nModules can also be nested.\n\n```rust\nfn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n```\n\nPrivate functions can be called from the same module or from a child module.\n\n```rust\n// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n  \n  fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(\"Hello, world!\");\n  }\n  \n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n```\n\n> 💡 `self` keyword is used to refer same module, while `super` keyword is used to refer parent module. Also, `super` keyword can be used to access root functions from inside a module.\n\n```rust\nfn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(\"Hello, world!\");\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n```\n\n> 🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.\n\n```rust\nfn greet() -> String {\n    \"Hello, world!\".to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(\"Hello, world!\", greet());\n    }\n}\n```\n\n## 02. In different file, same directory\n\n```rust\n// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nIf we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\n## 03. In different file, different directory\n\n`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.\n\n```rust\n// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(\"Hello, world!\");\n}\n```\n\nAgain, If we wrap file content with a `mod` declaration, it will act as a nested module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(\"Hello, world!\");\n  }\n}\n```\n\nOther files in the directory module act as sub-modules for `mod.rs`.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import `greetings` module as a public module.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\n> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.\n\n```rust\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n```\n\nThis allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/d3.modules.html","comments":1,"layout":"page","_id":"cjtfwbj0x001idwgp1lbn689i","content":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<h2 id=\"01-In-same-file\"><a href=\"#01-In-same-file\" class=\"headerlink\" title=\"01. In same file\"></a>01. In same file</h2><p>Related code and data are grouped into a module and stored in the same file.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n   greetings::hello();\n}\n\nmod greetings {\n  // ⭐️ By default, everything inside a module is private\n  pub fn hello() { // ⭐️ So function has to be public to access from outside\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Modules can also be nested.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() { \n  phrases::greetings::hello();\n}\n\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n</code></pre>\n<p>Private functions can be called from the same module or from a child module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. Calling private functions of the same module\nfn main() {\n  phrases::greet();\n}\n\nmod phrases {\n  pub fn greet() {\n    hello(); //or self::hello();\n  }\n\n  fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n\n// 02. Calling private functions of the parent module\nfn main() {\n  phrases::greetings::hello();\n}\n\nmod phrases {\n  fn private_fn() {\n    println!(&quot;Hello, world!&quot;);\n  }\n\n  pub mod greetings {\n    pub fn hello() {\n      super::private_fn();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 <code>self</code> keyword is used to refer same module, while <code>super</code> keyword is used to refer parent module. Also, <code>super</code> keyword can be used to access root functions from inside a module.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn main() {\n  greetings::hello();\n}\n\nfn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\nmod greetings {\n  pub fn hello() {\n    super::hello();\n  }\n}\n</code></pre>\n<blockquote>\n<p>🔎 When writing tests it’s a good practice to write tests inside a test module because of they compile only when running tests.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greet() -&gt; String {\n    &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)] // only compiles when running tests\nmod tests {\n    use super::greet; // import root greet function\n\n    #[test]\n    fn test_greet() {\n        assert_eq!(&quot;Hello, world!&quot;, greet());\n    }\n}\n</code></pre>\n<h2 id=\"02-In-different-file-same-directory\"><a href=\"#02-In-different-file-same-directory\" class=\"headerlink\" title=\"02. In different file, same directory\"></a>02. In different file, same directory</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings; // import greetings module\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings.rs\n// ⭐️ no need to wrap the code with a mod declaration. File itself acts as a module.\npub fn hello() { // function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<h2 id=\"03-In-different-file-different-directory\"><a href=\"#03-In-different-file-different-directory\" class=\"headerlink\" title=\"03. In different file, different directory\"></a>03. In different file, different directory</h2><p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod greetings;\n\nfn main() {\n  greetings::hello();\n}\n\n// ↳ greetings/mod.rs\npub fn hello() { // ⭐️ function has to be public to access from outside\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings { // ⭐️ module has to be public to access from outside\n  pub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n  }\n}\n</code></pre>\n<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n  phrases::hello()\n}\n\n// ↳ phrases/mod.rs\nmod greetings;\n\npub fn hello() {\n  greetings::hello()\n}\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import <code>greetings</code> module as a public module.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;  // ⭐️ `pub mod` instead `mod`\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<blockquote>\n<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //you can call hello() directly from phrases\n}\n</code></pre>\n<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>\n"},{"title":"Workspaces","_content":"\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","source":"docs/zh-cn/d5.workspaces.md","raw":"title: Workspaces\n---\n\nWhen the code base is getting larger, you might need to work with **multiple crates on the same project**. Rust supports this via Workspaces. You can **analyze (`cargo check`), build, run tests or generate docs for all crates** at once by running `cargo` commands from the project root.\n\n⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a **shared build directory** under the project root, while running `cargo build` from the project root.\n\nLet's create a library crate with a simple hello world function and a binary crate which uses the library crate.\n\nAssume we run,\n```bash\nmkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n```\n\nThat generates,\n```\ngreetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n```\n\nWe have to modify following files,\n```rust\n// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    \"lib\",\n    \"examples/hello\"\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"../../lib\" }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n💡 On Linux and Mac, you can run `cargo` commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the `greetings` directory, even you run `(cd examples/hello && cargo run)` your working directory will be kept  as same in `greetings` folder.\n\n> 🔎 [rust-lang/rust source folder](https://github.com/rust-lang/rust/tree/master/src) is a good example for a workspace.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d5.workspaces.html","comments":1,"layout":"page","_id":"cjtfwbj0x001jdwgpnea4964y","content":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>\n<p>⭐️ When working on multiple crates same time, there is a higher possibility to having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>\n<p>Let’s create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>\n<p>Assume we run,</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">mkdir greetings\ntouch greetings/Cargo.toml\ncargo new greetings/lib --lib\ncargo new greetings/examples/hello\n</code></pre>\n<p>That generates,</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>greetings\n├── Cargo.toml\n├── examples\n│  └── hello\n│     ├── Cargo.toml\n│     └── src\n│        └── main.rs\n└── lib\n   ├── Cargo.toml\n   └── src\n      └── lib.rs\n</code></pre><p>We have to modify following files,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 01. greetings/Cargo.toml to mark as a workspace and to add members\n[workspace]\nmembers = [\n    &quot;lib&quot;,\n    &quot;examples/hello&quot;\n]\n\n// 02.1 greetings/lib/Cargo.toml to change the package name to greetings\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\n\n// 02.2 greetings/lib/src/lib.rs to add a simple hello world function\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03.1 greetings/examples/hello/Cargo.toml to add greetings lib as a dependency\n[package]\nname = &quot;hello&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;../../lib&quot; }\n\n// 03.2 greetings/examples/hello/src/main.rs to import greetings lib and call its hello world function\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>\n<blockquote>\n<p>🔎 <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\">rust-lang/rust source folder</a> is a good example for a workspace.</p>\n</blockquote>\n"},{"title":"Use","_content":"\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","source":"docs/zh-cn/d6.use.md","raw":"title: Use\n---\n\nLet's see the main usages of `use` keyword.\n\n\n## 01. Bind a full path to a new name\n\nMainly `use` keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.\n\n```rust\n// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(\"Hello, world!\");\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n```\n\n\n## 02. Import elements to scope\n\nAnother common usage of `use` is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.\n\n```rust\nfn hello() -> String {\n  \"Hello, world!\".to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n    \n  #[test]\n  fn test_hello() {\n    assert_eq!(\"Hello, world!\", hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n```\n\n> 💡 By default, `use` declarations use absolute paths, starting from the crate root. But `self` and `super` declarations make that path relative to the current module.\n\nSame way `use` keyword is used to import the elements of other crates including `std` , Rust’s [Standard Library](https://github.com/rust-lang/rust/tree/master/src/libstd).\n\n```rust\n// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(\"empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(\"some_dir\").expect(\"Can not create the directry!\");\n    File::create(\"some_dir/empty.txt\").expect(\"Can not create the file!\");\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(\"src/hello.txt\").expect(\"file not found\");\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n```\n\n> We **don’t need** to use `extern crate std;` when using `std` library. We will discuss more about this under Standard Library section.\n\n💡 `use` statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.\n\n\n## 03. Re-exporting\n\nAnother special case is `pub use`. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called **re-exporting**.\n\n```rust\n// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(\"Hello, world!\");\n}\n```\n\nThis pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d6.use.html","comments":1,"layout":"page","_id":"cjtfwbj0x001kdwgpw5nz7rmn","content":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>Let’s see the main usages of <code>use</code> keyword.</p>\n<h2 id=\"01-Bind-a-full-path-to-a-new-name\"><a href=\"#01-Bind-a-full-path-to-a-new-name\" class=\"headerlink\" title=\"01. Bind a full path to a new name\"></a>01. Bind a full path to a new name</h2><p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So user doesn’t want to repeat the full path each time.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Initial code without use keyword --\nmod phrases { \n  pub mod greetings { \n    pub fn hello() { \n      println!(&quot;Hello, world!&quot;);\n    }\n  }\n}\n\nfn main() { \n  phrases::greetings::hello(); // using full path\n}\n\n\n// -- Usage of use keyword --\n// 01. create alias for module\nuse phrases::greetings;\nfn main() { \n  greetings::hello();\n}\n\n// 02. create alias for module elements\nuse phrases::greetings::hello;\nfn main() { \n  hello();\n}\n\n// 03. customize names with as keyword\nuse phrases::greetings::hello as greet;\nfn main() { \n  greet();\n}\n</code></pre>\n<h2 id=\"02-Import-elements-to-scope\"><a href=\"#02-Import-elements-to-scope\" class=\"headerlink\" title=\"02. Import elements to scope\"></a>02. Import elements to scope</h2><p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also bit similar to creating alias and using it instead of using the full path.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn hello() -&gt; String {\n  &quot;Hello, world!&quot;.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n  use super::hello; //import hello() into scope\n\n  #[test]\n  fn test_hello() {\n    assert_eq!(&quot;Hello, world!&quot;, hello()); //if not using above use statement, we can run same via super::hello()\n  }\n}\n</code></pre>\n<blockquote>\n<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>\n</blockquote>\n<p>Same way <code>use</code> keyword is used to import the elements of other crates including <code>std</code> , Rust’s <a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">Standard Library</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- 01. importing elements --\nuse std::fs::File;\n\nfn main() {\n    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 02. importing module and elements--\nstd::fs::{self, File} //use std::fs; use std::fs::File;\n\nfn main() {\n    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);\n    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);\n}\n\n\n// -- 03. importing multiple elements\nuse std::fs::File;\nuse std::io::{BufReader, BufRead}; //use std::io::BufReader; use std::io::BufRead;\n\nfn main() {\n    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);\n    let buf_reader = BufReader::new(file);\n\n    for line in buf_reader.lines() {\n        println!(&quot;{}&quot;, line.unwrap());\n    }\n}\n</code></pre>\n<blockquote>\n<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using <code>std</code> library. We will discuss more about this under Standard Library section.</p>\n</blockquote>\n<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>\n<h2 id=\"03-Re-exporting\"><a href=\"#03-Re-exporting\" class=\"headerlink\" title=\"03. Re-exporting\"></a>03. Re-exporting</h2><p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// ↳ main.rs\nmod phrases;\n\nfn main() {\n    phrases::hello(); //not directly map\n}\n\n// ↳ phrases/mod.rs\npub mod greetings;\n\npub use self::greetings::hello; //re-export greetings::hello to phrases\n\n// ↳ phrases/greetings.rs\npub fn hello() {\n  println!(&quot;Hello, world!&quot;);\n}\n</code></pre>\n<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users, because users don’t need to know/follow whole directory map of the elements of the library while working with them.</p>\n"},{"title":"Overview","_content":"\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","source":"docs/zh-cn/index.md","raw":"title: Overview\n---\n\nThis is based on the posts I wrote on **Medium**, https://medium.com/learning-rust\n\n[![Rust Playground](images/learning_rust_medium.jpg)](https://medium.com/learning-rust)\n\n> 🐣 I am a **Sri Lankan** 🇱🇰 Web Developer who lives in **Vietnam** 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.","date":"2019-03-19T14:50:31.987Z","updated":"2019-03-19T14:50:31.987Z","path":"docs/zh-cn/index.html","comments":1,"layout":"page","_id":"cjtfwbj0y001ldwgp8tmzjjcy","content":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>This is based on the posts I wrote on <strong>Medium</strong>, <a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\">https://medium.com/learning-rust</a></p>\n<p><a href=\"https://medium.com/learning-rust\" target=\"_blank\" rel=\"noopener\"><img src=\"images/learning_rust_medium.jpg\" alt=\"Rust Playground\"></a></p>\n<blockquote>\n<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>\n</blockquote>\n"},{"title":"Standard Library, Primitives and Preludes","_content":"\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","source":"docs/zh-cn/d7.std_primitives_and_preludes.md","raw":"title: Standard Library, Primitives and Preludes\n---\n\n⭐️ In Rust, language elements are implemented by not only **`std` library** crate but also **compiler** as well. Examples,\n- **[Primitives](https://doc.rust-lang.org/std/#primitives)** : Defined by the compiler and methods are implemented by `std` library directly on primitives.\n- **[Standard Macros](https://doc.rust-lang.org/std/#macros)** : Defined by both compiler and `std`\n\n**`std`** library has been has divided into **[modules](https://doc.rust-lang.org/std/#modules)**, according to the main areas each covered.\n\n⭐️ While primitives are implemented by the **compiler**, the standard library implements **most useful methods** directly on the primitive types. But some **rarely useful language elements** of some primitives are stored on relevant **`std` modules**. This is why you can see `char`, `str` and integer types on both [primitives](https://doc.rust-lang.org/std/#primitives) and [`std` modules](https://doc.rust-lang.org/std/#modules).\n\n\n## Primitives\n\n```rust\n// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n```\n\n## Standard Macros\n\n```rust\n// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n```\n\n## Std Modules\n\n```rust\n// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n```\n\n> 🔎 When examine [Rust’s source code](https://github.com/rust-lang/rust), you can see that [`src` directory](https://github.com/rust-lang/rust/tree/master/src) is a **workspace**. Even though its having many library crates, by examine [root Cargo.toml](https://github.com/rust-lang/rust/blob/master/src/Cargo.toml) file you can easily identify that main crates are **[rustc](https://github.com/rust-lang/rust/tree/master/src/rustc)**(compiler) and **[libstd](https://github.com/rust-lang/rust/tree/master/src/libstd)** (std). In libstd/lib.rs std modules have been **re-exported** via `pub use` and the original location of most of std modules is [`src/libcore`](https://github.com/rust-lang/rust/tree/master/src/libcore).\n\n**Few important `std` modules are,**\n- `std::io` - Core **I/O** functionality \n- `std::fs` - **Filesystem** specific functionality\n- `std::path` - **Cross platform path** specific functionality\n- `std::env` - **Process’s environment** related functionality\n- `std::mem` - **Memory** related functionality\n- `std::net` - **TCP/UDP** communication\n- `std::os` - **OS** specific functionality\n- `std::thread` - Native **threads** specific functionality\n- `std::collections` - Core **Collection types**\n\n> 💯 Refer [Rust Standard Library Documentation](https://doc.rust-lang.org/std/) for more details.\n\n\n## Preludes\n\nEven though Rust `std` contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the **smallest list of things which require for almost every single Rust program**. These are called **[preludes](https://doc.rust-lang.org/std/prelude/)**. They import only,\n\n```rust\n// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n```\n\n> Preludes have been imported explicitly on [`libstd/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353) and the whole list can be seen on [`libstd/prelude/v1.rs`](https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs).\n\n⭐️ So technically, Rust inserts,\n- `extern crate std;` : into the **crate root of every crate**\n- `use std::prelude::v1::*;` : into **every module**\n  So you don’t need to import these each time.\n\n\nThe concept of preludes is quite common on Rust libraries. Even some modules inside `std` crate (ex.libstd/io) and many libraries (ex. [diesel](https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151)) are having their own `prelude` modules.\n\n⭐️ But **preludes** are used to **create a single place to import all important components** which are **required while using the library**. They **do not load automatically** unless you imported them manually. Only `std::prelude` imports automatically in every Rust programs.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d7.std_primitives_and_preludes.html","comments":1,"layout":"page","_id":"cjtfwbj0z001mdwgpb9lzlbnv","content":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>\n<ul>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">Primitives</a></strong> : Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>\n<li><strong><a href=\"https://doc.rust-lang.org/std/#macros\" target=\"_blank\" rel=\"noopener\">Standard Macros</a></strong> : Defined by both compiler and <code>std</code></li>\n</ul>\n<p><strong><code>std</code></strong> library has been has divided into <strong><a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\">modules</a></strong>, according to the main areas each covered.</p>\n<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href=\"https://doc.rust-lang.org/std/#primitives\" target=\"_blank\" rel=\"noopener\">primitives</a> and <a href=\"https://doc.rust-lang.org/std/#modules\" target=\"_blank\" rel=\"noopener\"><code>std</code> modules</a>.</p>\n<h2 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Primitives : Defined by the compiler and methods are directly implemented by std\nbool, char, slice, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32, u64, u128, usize\n\nf32, f64\n\narray, tuple\n\npointer, fn, reference\n</code></pre>\n<h2 id=\"Standard-Macros\"><a href=\"#Standard-Macros\" class=\"headerlink\" title=\"Standard Macros\"></a>Standard Macros</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Standard Macros also defined by both compiler and std\nprint, println, eprint, eprintln\nformat, format_args\nwrite, writeln\n\nconcat, concat_idents, stringify //concat_idents : nightly-only experimental API\n\ninclude, include_bytes, include_str\n\nassert, assert_eq, assert_ne\ndebug_assert, debug_assert_eq, debug_assert_ne\n\ntry, panic, compile_error, unreachable, unimplemented\n\nfile, line, column, module_path\nenv, option_env\ncfg\n\nselect, thread_local //select : nightly-only experimental API\n\nvec\n</code></pre>\n<h2 id=\"Std-Modules\"><a href=\"#Std-Modules\" class=\"headerlink\" title=\"Std Modules\"></a>Std Modules</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// std modules\nchar, str\n\ni8, i16, i32, i64, i128, isize\nu8, u16, u32 ,u64, u128, usize\nf32, f64\nnum\n\nvec, slice, hash, heap, collections // heap : nightly-only experimental API\n\nstring, ascii, fmt\n\ndefault\n\nmarker, clone, convert, cmp, iter\n\nops, ffi\n\noption, result, panic, error\n\nio\nfs, path\nmem, thread, sync\nprocess, env\nnet\ntime\nos\n\nptr, boxed, borrow, cell, any, rc\n\nprelude\n\nintrinsics // intrinsics : nightly-only experimental API\nraw // raw : nightly-only experimental API\n</code></pre>\n<blockquote>\n<p>🔎 When examine <a href=\"https://github.com/rust-lang/rust\" target=\"_blank\" rel=\"noopener\">Rust’s source code</a>, you can see that <a href=\"https://github.com/rust-lang/rust/tree/master/src\" target=\"_blank\" rel=\"noopener\"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though its having many library crates, by examine <a href=\"https://github.com/rust-lang/rust/blob/master/src/Cargo.toml\" target=\"_blank\" rel=\"noopener\">root Cargo.toml</a> file you can easily identify that main crates are <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/rustc\" target=\"_blank\" rel=\"noopener\">rustc</a></strong>(compiler) and <strong><a href=\"https://github.com/rust-lang/rust/tree/master/src/libstd\" target=\"_blank\" rel=\"noopener\">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of std modules is <a href=\"https://github.com/rust-lang/rust/tree/master/src/libcore\" target=\"_blank\" rel=\"noopener\"><code>src/libcore</code></a>.</p>\n</blockquote>\n<p><strong>Few important <code>std</code> modules are,</strong></p>\n<ul>\n<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>\n<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>\n<li><code>std::path</code> - <strong>Cross platform path</strong> specific functionality</li>\n<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>\n<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>\n<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>\n<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>\n<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>\n<li><code>std::collections</code> - Core <strong>Collection types</strong></li>\n</ul>\n<blockquote>\n<p>💯 Refer <a href=\"https://doc.rust-lang.org/std/\" target=\"_blank\" rel=\"noopener\">Rust Standard Library Documentation</a> for more details.</p>\n</blockquote>\n<h2 id=\"Preludes\"><a href=\"#Preludes\" class=\"headerlink\" title=\"Preludes\"></a>Preludes</h2><p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and every thing of std library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href=\"https://doc.rust-lang.org/std/prelude/\" target=\"_blank\" rel=\"noopener\">preludes</a></strong>. They import only,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// Reexported core operators\npub use marker::{Copy, Send, Sized, Sync};\npub use ops::{Drop, Fn, FnMut, FnOnce};\n\n// Reexported functions\npub use mem::drop;\n\n// Reexported types and traits\npub use boxed::Box;\npub use borrow::ToOwned;\npub use clone::Clone;\npub use cmp::{PartialEq, PartialOrd, Eq, Ord};\npub use convert::{AsRef, AsMut, Into, From};\npub use default::Default;\npub use iter::{Iterator, Extend, IntoIterator};\npub use iter::{DoubleEndedIterator, ExactSizeIterator};\npub use option::Option::{self, Some, None};\npub use result::Result::{self, Ok, Err};\npub use slice::SliceConcatExt;\npub use string::{String, ToString};\npub use vec::Vec;\n</code></pre>\n<blockquote>\n<p>Preludes have been imported explicitly on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353\" target=\"_blank\" rel=\"noopener\"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs\" target=\"_blank\" rel=\"noopener\"><code>libstd/prelude/v1.rs</code></a>.</p>\n</blockquote>\n<p>⭐️ So technically, Rust inserts,</p>\n<ul>\n<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>\n<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong><br>So you don’t need to import these each time.</li>\n</ul>\n<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.libstd/io) and many libraries (ex. <a href=\"https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L151\" target=\"_blank\" rel=\"noopener\">diesel</a>) are having their own <code>prelude</code> modules.</p>\n<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>\n"},{"title":"Lifetimes","_content":"\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","source":"docs/zh-cn/c3.lifetimes.md","raw":"title: Lifetimes\n---\n\nWhen we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.\n\nThink,\n\n* We have a variable binding, “**a**”.\n* We are referencing the value of “a”, from another variable binding “**x**”.\n  We have to make sure that “a” **lives** until we stop using “x”\n\n> 🔎 **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**\\(GC\\), a form of **Automatic Memory Management**\\(AMM\\). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**\\(ARC\\).\n\n## What is Lifetimes?\n\nIn Rust,\n\n* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.\n* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content.\n* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.\n* ⭐ ️But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.\n\nLifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.\n\n> * Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.\n> * Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.\n> * Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.\n\n## Usage\n\nLifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.\n\nWhen using references,\n\n### 01. On Function Declaration\n\n* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)`\n* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`\n\n```rust\n// no inputs, return a reference\nfn function<'a>() -> &'a str {}\n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}\n```\n\n### 02. On Struct or Enum Declaration\n\n* Elements with references should attach lifetimes after `&` sign.\n* After the name of the struct or enum, we should mention that the given lifetimes are generic types.\n\n```rust\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> {\n    Variant(&'a Type)\n}\n```\n\n### 03. With Impls and Traits\n\n```rust\nstruct Struct<'a> {\n    x: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn function<'a>(&self) -> &'a str {\n            self.x\n        }\n    }\n\n\nstruct Struct<'a> {\n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> {\n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a>\n```\n\n### 04. With Generic Types\n\n```rust\n// 🔎\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }\n```\n\n## Lifetime Elision\n\nAs I mentioned earlier, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime Elision**.\n\n💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.\n\nLifetime annotations of `fn` definitions can be elided  \nif its **parameter list** has either,\n\n* **only one input parameter passes by reference**.\n* a parameter with **either** `&self` **or** **&mut self** reference.\n\n```rust\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\n\nstruct Player<'a> {\n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n}\n```\n\n> 💡 In the Lifetime Elision process of fn definitions,\n>\n> * Each parameter passes by reference is got a distinct lifetime annotation.\n>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`\n> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.\n>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`\n> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →\n>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`\n> * For all other cases, we have to write lifetime annotations manually.\n\n## `'static` Annotations\n\n`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.\n\n```rust\nstatic N: i32 = 5; //A constant with 'static lifetime\n\nlet a = \"Hello, world.\"; //a: &'static str\n\n\nfn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ \n\t\"Hello, world!\"\n}\n```\n\n## Few more examples about usage of Rust lifetimes.\n\n```rust\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\n\nstruct Person<'a> {\n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n}\n```\n","date":"2019-03-19T14:50:31.985Z","updated":"2019-03-19T14:50:31.985Z","path":"docs/zh-cn/c3.lifetimes.html","comments":1,"layout":"page","_id":"cjtfwbj1g001ndwgpcqw8rwdc","content":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.</p>\n<p>Think,</p>\n<ul>\n<li>We have a variable binding, “<strong>a</strong>”.</li>\n<li>We are referencing the value of “a”, from another variable binding “<strong>x</strong>”.<br>We have to make sure that “a” <strong>lives</strong> until we stop using “x”</li>\n</ul>\n<blockquote>\n<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>\n</blockquote>\n<h2 id=\"What-is-Lifetimes\"><a href=\"#What-is-Lifetimes\" class=\"headerlink\" title=\"What is Lifetimes?\"></a>What is Lifetimes?</h2><p>In Rust,</p>\n<ul>\n<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>\n<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>\n<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>\n<li>⭐ ️But because of lifetime annotations make <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>\n</ul>\n<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason of having <strong>slower compilation times</strong> in Rust.</p>\n<blockquote>\n<ul>\n<li>Unlike C and C++, <strong>usually</strong> Rust doesn’t explicitly drop values at all.</li>\n<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>\n<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>\n</ul>\n</blockquote>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>&#39;a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>\n<p>When using references,</p>\n<h3 id=\"01-On-Function-Declaration\"><a href=\"#01-On-Function-Declaration\" class=\"headerlink\" title=\"01. On Function Declaration\"></a>01. On Function Declaration</h3><ul>\n<li>Input and output parameters with references should attach lifetimes after <code>&amp;</code> sign. ex <code>..(x: &amp;&#39;a str)</code> , <code>..(x: &amp;&#39;a mut str)</code></li>\n<li>After the function name, we should mention that the given lifetimes are generic types. ex <code>fn foo&lt;&#39;a&gt;(..)</code> , <code>fn foo&lt;&#39;a, &#39;b&gt;(..)</code></li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// no inputs, return a reference\nfn function&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {}\n\n// single input\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {}\n\n// multiple inputs. inputs can have diffent lifetimes 🔎\n// output should live at least as long as x exists\nfn function&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str {}\n</code></pre>\n<h3 id=\"02-On-Struct-or-Enum-Declaration\"><a href=\"#02-On-Struct-or-Enum-Declaration\" class=\"headerlink\" title=\"02. On Struct or Enum Declaration\"></a>02. On Struct or Enum Declaration</h3><ul>\n<li>Elements with references should attach lifetimes after <code>&amp;</code> sign.</li>\n<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// single element\n// data of x should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum&lt;&#39;a&gt; {\n    Variant(&amp;&#39;a Type)\n}\n</code></pre>\n<h3 id=\"03-With-Impls-and-Traits\"><a href=\"#03-With-Impls-and-Traits\" class=\"headerlink\" title=\"03. With Impls and Traits\"></a>03. With Impls and Traits</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">struct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn function&lt;&#39;a&gt;(&amp;self) -&gt; &amp;&#39;a str {\n            self.x\n        }\n    }\n\n\nstruct Struct&lt;&#39;a&gt; {\n    x: &amp;&#39;a str,\n    y: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Struct&lt;&#39;a&gt; {\n        fn new(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; Struct&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n\n// 🔎\nimpl&lt;&#39;a&gt; Trait&lt;&#39;a&gt; for Type\nimpl&lt;&#39;a&gt; Trait for Type&lt;&#39;a&gt;\n</code></pre>\n<h3 id=\"04-With-Generic-Types\"><a href=\"#04-With-Generic-Types\" class=\"headerlink\" title=\"04. With Generic Types\"></a>04. With Generic Types</h3><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// 🔎\nfn function&lt;F&gt;(f: F) where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type)\nstruct Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { x: F }\nenum Enum&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { Variant(F) }\nimpl&lt;F&gt; Struct&lt;F&gt; where for&lt;&#39;a&gt; F: FnOnce(&amp;&#39;a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }\n</code></pre>\n<h2 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h2><p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>\n<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future it will support for <code>impl</code> headers as well.</p>\n<p>Lifetime annotations of <code>fn</code> definitions can be elided<br>if its <strong>parameter list</strong> has either,</p>\n<ul>\n<li><strong>only one input parameter passes by reference</strong>.</li>\n<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>\n</ul>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn triple(x: &amp;u64) -&gt; u64 { //only one input parameter passes by reference\n    x * 3\n}\n\n\nfn filter(x: u8, y: &amp;str) -&gt; &amp;str { // only one input parameter passes by reference\n    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }\n}\n\n\nstruct Player&lt;&#39;a&gt; {\n    id: u8,\n    name: &amp;&#39;a str\n}\n    impl&lt;&#39;a&gt; Player&lt;&#39;a&gt; { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &amp;str) -&gt; Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&amp;self) -&gt; String { // a fn definition with &amp;self (or &amp;mut self) reference\n            format!(&quot;{}: {}&quot;, self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, &quot;Serena Williams&quot;);\n    let player1_heading_text = player1.heading_text()\n    println!(&quot;{}&quot;, player1_heading_text);\n}\n</code></pre>\n<blockquote>\n<p>💡 In the Lifetime Elision process of fn definitions,</p>\n<ul>\n<li>Each parameter passes by reference is got a distinct lifetime annotation.<br>  ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str)</code></li>\n<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.<br>  ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;&#39;a&gt;(x: i32, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></li>\n<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.<br>  ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →<br>  <code>impl&lt;&#39;a&gt; Impl&lt;&#39;a&gt;{ fn function(&amp;&#39;a self, x: &amp;&#39;b str) -&gt; &amp;&#39;a str {} }</code></li>\n<li>For all other cases, we have to write lifetime annotations manually.</li>\n</ul>\n</blockquote>\n<h2 id=\"39-static-Annotations\"><a href=\"#39-static-Annotations\" class=\"headerlink\" title=\"&#39;static Annotations\"></a><code>&#39;static</code> Annotations</h2><p><code>&#39;static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">static N: i32 = 5; //A constant with &#39;static lifetime\n\nlet a = &quot;Hello, world.&quot;; //a: &amp;&#39;static str\n\n\nfn index() -&gt; &amp;&#39;static str { //No need to mention &lt;&#39;static&gt; ; fn index ̶&lt;̶&#39;̶s̶t̶a̶t̶i̶c̶&gt;̶ \n    &quot;Hello, world!&quot;\n}\n</code></pre>\n<h2 id=\"Few-more-examples-about-usage-of-Rust-lifetimes\"><a href=\"#Few-more-examples-about-usage-of-Rust-lifetimes\" class=\"headerlink\" title=\"Few more examples about usage of Rust lifetimes.\"></a>Few more examples about usage of Rust lifetimes.</h2><p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">fn greeting&lt;&#39;a&gt;() -&gt; &amp;&#39;a str {\n  &quot;Hi!&quot;\n}\n\n\nfn fullname&lt;&#39;a&gt;(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; String {\n  format!(&quot;{} {}&quot;, fname, lname)\n}\n\n\nstruct Person&lt;&#39;a&gt; {\n    fname: &amp;&#39;a str,\n    lname: &amp;&#39;a str\n}\n  impl&lt;&#39;a&gt; Person&lt;&#39;a&gt; {\n      fn new(fname: &amp;&#39;a str, lname: &amp;&#39;a str) -&gt; Person&lt;&#39;a&gt; { //no need to specify &lt;&#39;a&gt; after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&amp;self) -&gt; String {\n          format!(&quot;{} {}&quot;, self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);\n    let player_fullname = player.fullname();\n\n    println!(&quot;Player: {}&quot;, player_fullname);\n}\n</code></pre>\n"},{"title":"Crate","_content":"\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","source":"docs/zh-cn/d4.crates.md","raw":"title: Crate\n---\n\n> 💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.\n\n> 💭 A crate can produce an executable/ a binary or a library. `src/main.rs` is the crate root/ entry point for a binary crate and `src/lib.rs` is the entry point for a library crate.\n\n## 01. lib.rs on executable crate\n\n💡 When writing binary crates, we can move the main functionalities to `src/lib.rs` and use it as a library from `src/main.rs` . This pattern is quite common on executable crates.\n\n```rust\n// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n> 💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write `greetings/src/lib.rs` to make the code more testable.\n\n```rust\n// greetings/src/lib.rs\npub fn hello() -> String {\n  //! This returns Hello, world! String\n  (\"Hello, world!\").to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), \"Hello, world!\");\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n  \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> [📖](https://doc.rust-lang.org/book/first-edition/crates-and-modules.html) When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write `extern crate like_this;`\n\n`lib.rs` can link with multiple files.\n\n```rust\n// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n   \n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n```\n\n\n## 02. Dependency crate on Cargo.toml\n\nWhen the code in the `lib.rs` file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.\n\n### a. Using folder path\n\nLet’s see how to create a nested crate and use it as a dependency using folder path,\n\n```rust\n// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = \"phrases\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ngreetings = { path = \"greetings\" }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(\"Hello, world!\");\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n```\n\n\n### b. Using git repository\n\nIf you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.\n\n```rust\n// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\" }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", branch = \"v0.3\" }\n\n// 03. Get a specific tag\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", tag = \"v0.3.2\" }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = \"https://github.com/SergioBenitez/Rocket\", rev = \"8183f636305cef4adaa9525506c33cbea72d1745\" }\n```\n\n\n### c. Using crates.io\n\nThe other way is uploading it to [crates.io](http://crates.io/) and use it as a dependency when needed.\n\n🚧 First, let’s `create` a simple “Hello world” crate `and upload` it to [crates.io](http://crates.io/).\n\n```rust\n// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n   \n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = \"test_crate_hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\ndescription = \"A Simple Hello World Crate\"\nrepository = \"https://github.com/dumindu/test_crate_hello_world\"\nkeywords = [\"hello\", \"world\"]\nlicense = \"Apache-2.0\"\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -> String {\n    (\"Hello, world!\").to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n    \n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), \"Hello, world!\");\n    }\n}\n```\n\n> 💭 **//! doc comments** are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to [crates.io](http://crates.io/), cargo generates the documentation from these doc comments and host it on [docs.rs](https://docs.rs/).\n\n💡 We have to add the **description** and **license** fields to Cargo.toml, otherwise we will get `error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html`\n\nTo upload this to crates.io,\n1. We have to create an account on crates.io to acquire an API token\n2. Then run `cargo login <token>` with that API token and cargo publish\n\n[📖](http://doc.crates.io/crates-io.html) This is [how it describes on Cargo Docs](http://doc.crates.io/crates-io.html) with more details.\n\n> - You’ll need an account on crates.io to acquire an API token. To do so, [visit the home page](https://crates.io/) and log in via a GitHub account (required for now). After this, visit your [Account Settings](https://crates.io/me) page and run the `cargo login` command specified. \n  Ex. `cargo login abcdefghijklmnopqrstuvwxyz012345`\n- The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the `cargo package` sub-command.\n- Now, it can be uploaded to crates.io with the `cargo publish` command.\n- If you’d like to skip the `cargo package` step, the `cargo publish` sub-command will automatically package up the local crate if a copy isn’t found already.\n\nThe name of our crate is `test_crate_hello_world`. So it can be found on,\n📦 [https://**crates.io/crates**/test_crate_hello_world](https://crates.io/crates/test_crate_hello_world)\n📑 [https://**docs.rs**/test_crate_hello_world](https://docs.rs/test_crate_hello_world)\n\n> 💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: `readme=\"README.md\"`\n\n🏗️ Okay then, Let’s see how we can **use this from an another crate**.\n\n```rust\n// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = \"greetings\"\nversion = \"0.1.0\"\nauthors = [\"Dumindu Madunuwan\"]\n\n[dependencies]\ntest_crate_hello_world = \"0.1.0\"\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(\"{}\", test_crate_hello_world::hello());\n}\n```\n\nBy default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to **Cargo.toml** and then run `cargo build` to fetch the dependencies and compile them.","date":"2019-03-19T14:50:31.986Z","updated":"2019-03-19T14:50:31.986Z","path":"docs/zh-cn/d4.crates.html","comments":1,"layout":"page","_id":"cjtfwbj1g001odwgpi89ldrhn","content":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n","site":{"data":{"languages":{"en":"English","zh-cn":"Chinese"},"menu":{"docs":"/docs/a1.why_rust.html"},"sidebar":{"docs":{"docs":{"overview":"index.html"},"basics":{"why_rust":"a1.why_rust.html","installation":"a2.installation.html","hello_world":"a3.hello_world.html","cargo,crates_and_basic_project_structure":"a4.cargo,crates_and_basic_project_structure.html","comments_and_documenting_the_code":"a5.comments_and_documenting_the_code.html","variable_bindings,constants_and_statics":"a6.variable_bindings,constants_and_statics.html","functions":"a7.functions.html","primitive_data_types":"a8.primitive_data_types.html","operators":"a9.operators.html","control_flows":"a10.control_flows.html"},"beyond_the_basics":{"vectors":"b1.vectors.html","structs":"b2.structs.html","enums":"b3.enums.html","generics":"b4.generics.html","impls_and_traits":"b5.impls_and_traits.html"},"the_tough_part":{"ownership":"c1.ownership.html","borrowing":"c2.borrowing.html","lifetimes":"c3.lifetimes.html"},"lets_get_it_started":{"code_organization":"d1.code_organization.html","functions_co":"d2.functions.html","modules":"d3.modules.html","crates":"d4.crates.html","workspaces":"d5.workspaces.html","use":"d6.use.html","std_primitives_and_preludes":"d7.std_primitives_and_preludes.html"},"error_handling":{"smart_compiler":"e1.smart_compiler.html","panicking":"e2.panicking.html","option_and_result":"e3.option_and_result.html","unwrap_and_expect":"e4.unwrap_and_expect.html","error_and_none_propagation":"e5.error_and_none_propagation.html","combinators":"e6.combinators.html","custom_error_types":"e7.custom_error_types.html"}}}}},"excerpt":"","more":"<blockquote>\n<p>💭 Crates are bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>\n</blockquote>\n<blockquote>\n<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>\n</blockquote>\n<h2 id=\"01-lib-rs-on-executable-crate\"><a href=\"#01-lib-rs-on-executable-crate\" class=\"headerlink\" title=\"01. lib.rs on executable crate\"></a>01. lib.rs on executable crate</h2><p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code> . This pattern is quite common on executable crates.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\ntouch greetings/src/lib.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. greetings/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<blockquote>\n<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>\n</blockquote>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// greetings/src/lib.rs\npub fn hello() -&gt; String {\n  //! This returns Hello, world! String\n  (&quot;Hello, world!&quot;).to_string()\n}\n\n// 01. Tests for hello()\n#[test] // indicates that this is a test function\nfn test_hello() {\n  assert_eq!(hello(), &quot;Hello, world!&quot;);\n}\n\n// 02. Tests for hello(), Idiomatic way\n#[cfg(test)] // only compiles when runing tests\nmod tests { // seperates tests from code\n  use super::hello; // import root hello function\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/book/first-edition/crates-and-modules.html\" target=\"_blank\" rel=\"noopener\">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>\n</blockquote>\n<p><code>lib.rs</code> can link with multiple files.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ntouch phrases/src/lib.rs\ntouch phrases/src/greetings.rs\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   ├── greetings.rs\n   ├── lib.rs\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/src/greetings.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 02. phrases/src/main.rs\nextern crate phrases;\n\nfn main() {\n    phrases::greetings::hello();\n}\n\n// 03. phrases/src/lib.rs\npub mod greetings; // ⭐️ import greetings module as a public module\n</code></pre>\n<h2 id=\"02-Dependency-crate-on-Cargo-toml\"><a href=\"#02-Dependency-crate-on-Cargo-toml\" class=\"headerlink\" title=\"02. Dependency crate on Cargo.toml\"></a>02. Dependency crate on Cargo.toml</h2><p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>\n<h3 id=\"a-Using-folder-path\"><a href=\"#a-Using-folder-path\" class=\"headerlink\" title=\"a. Using folder path\"></a>a. Using folder path</h3><p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new phrases\ncargo new phrases/greetings --lib\n\n// # It generates,\n.\n├── Cargo.toml\n├── greetings\n│  ├── Cargo.toml\n│  └── src\n│     └── lib.rs\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. phrases/Cargo.toml\n[package]\nname = &quot;phrases&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ngreetings = { path = &quot;greetings&quot; }\n\n// 02. phrases/greetings/src/lib.rs\npub fn hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n\n// 03. phrases/src/main.rs\nextern crate greetings;\n\nfn main() {\n    greetings::hello();\n}\n</code></pre>\n<h3 id=\"b-Using-git-repository\"><a href=\"#b-Using-git-repository\" class=\"headerlink\" title=\"b. Using git repository\"></a>b. Using git repository</h3><p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// -- Cargo.toml --\n[dependencies]\n\n// 01. Get the latest commit on the master branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }\n\n// 02. Get the latest commit of a specific branch\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }\n\n// 03. Get a specific tag\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }\n\n// 04. Get a specific revision (on master or any branch, according to rev)\nrocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }\n</code></pre>\n<h3 id=\"c-Using-crates-io\"><a href=\"#c-Using-crates-io\" class=\"headerlink\" title=\"c. Using crates.io\"></a>c. Using crates.io</h3><p>The other way is uploading it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a> and use it as a dependency when needed.</p>\n<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new test_crate_hello_world --lib\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── lib.rs\n\n// # Think we modify following files\n\n// 01. test_crate_hello_world/Cargo.toml\n[package]\nname = &quot;test_crate_hello_world&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\ndescription = &quot;A Simple Hello World Crate&quot;\nrepository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;\nkeywords = [&quot;hello&quot;, &quot;world&quot;]\nlicense = &quot;Apache-2.0&quot;\n\n[dependencies]\n\n// 02. test_crate_hello_world/src/lib.rs\n//! A Simple Hello World Crate\n\n/// This function returns the greeting; Hello, world!\npub fn hello() -&gt; String {\n    (&quot;Hello, world!&quot;).to_string()\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::hello;\n\n    #[test]\n    fn test_hello() {\n        assert_eq!(hello(), &quot;Hello, world!&quot;);\n    }\n}\n</code></pre>\n<blockquote>\n<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places we have to use /// outside of the block. And when uploading a crate to <a href=\"http://crates.io/\" target=\"_blank\" rel=\"noopener\">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href=\"https://docs.rs/\" target=\"_blank\" rel=\"noopener\">docs.rs</a>.</p>\n</blockquote>\n<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to Cargo.toml, otherwise we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>\n<p>To upload this to crates.io,</p>\n<ol>\n<li>We have to create an account on crates.io to acquire an API token</li>\n<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>\n</ol>\n<p><a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">📖</a> This is <a href=\"http://doc.crates.io/crates-io.html\" target=\"_blank\" rel=\"noopener\">how it describes on Cargo Docs</a> with more details.</p>\n<blockquote>\n<ul>\n<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href=\"https://crates.io/\" target=\"_blank\" rel=\"noopener\">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href=\"https://crates.io/me\" target=\"_blank\" rel=\"noopener\">Account Settings</a> page and run the <code>cargo login</code> command specified.<br>Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>\n<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>\n<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>\n<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>\n</ul>\n</blockquote>\n<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,<br>📦 <a href=\"https://crates.io/crates/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a><br>📑 <a href=\"https://docs.rs/test_crate_hello_world\" target=\"_blank\" rel=\"noopener\">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>\n<blockquote>\n<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>\n</blockquote>\n<p>🏗️ Okay then, Let’s see how we can <strong>use this from an another crate</strong>.</p>\n<p></p><p class=\"code-caption\" data-lang=\"rust\" data-line_number=\"undefined\" data-trim_indent=\"undefined\" data-label_position=\"outer\" data-labels_left=\"\" data-labels_right=\"\" data-labels_copy=\"\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"rust\">// # Think we run\ncargo new greetings\n\n// # It generates,\n.\n├── Cargo.toml\n└── src\n   └── main.rs\n\n// # Think we modify following files\n\n// 01. greetings/Cargo.toml\n[package]\nname = &quot;greetings&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;Dumindu Madunuwan&quot;]\n\n[dependencies]\ntest_crate_hello_world = &quot;0.1.0&quot;\n\n// 02. greetings/src/main.rs\nextern crate test_crate_hello_world;\n\nfn main() {\n    println!(&quot;{}&quot;, test_crate_hello_world::hello());\n}\n</code></pre>\n<p>By default, Cargo looks dependencies on crates.io . So we have to add only the crate name and a version string to <strong>Cargo.toml</strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}