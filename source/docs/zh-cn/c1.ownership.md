title: 所有权 - Ownership
---

```rust
fn main() {
    let a = [1, 2, 3];
    let b = a;
    println!("{:?} {:?}", a, b); // [1, 2, 3] [1, 2, 3]
}

fn main() {
    let a = vec![1, 2, 3];
    let b = a;
    println!("{:?} {:?}", a, b); // Error; 使用一个已转移的值 `a`
}
```

在以上的例子中，我们都是同样的尝试将 **'a'的值分配给'b'**。两个代码块中的代码高度类似，但使用了**两个不同的数据类型**，因此第二个例子抛出了错误。这一错误的抛出，即是来自于**所有权**检查。


## 何谓所有权？

⭐️ 每个变量绑定都持有其所绑定对象的**所有权**。一个数据，**在一定时间内，只能有一个所有者**。当一个绑定离开了所在域，Rust就会释放其所绑定的资源。这就是Rust得以实现**内存安全**的主要机制。

> [所有(权) - Ownership \(noun\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  
> 拥有某物的行为、状态及权力。
> 
## 拷贝类型和转移类型
⭐️ 当**分配**一个变量绑定给另一个变量绑定时，或**将其传递给一个函数（非引用形式）时**，如果它的数据类型是一个：

1. **拷贝类型**
   * 被绑定的资源会**产生一个拷贝**并进行赋值或作为参数传递；
   * 原始绑定的所有权状态会被标记为 **“已拷贝状态”**；
   * **绝大多数基本类型属于这一情况**
2. **转移类型**
   * 被绑定的资源会**转移**给新的绑定，并且我们**不在能够通过原始绑定对其进行访问**；
   * 原始绑定的所有权状态会被设置为**已转移**；
   * **非基本数据类型主要属于该情况**

> 🔎 某类型结构的具体功能是由其实现的特定特性来决定的。默认情况下，变量绑定拥有“转移语义”，然而，如果某个结构类型实现了[**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html) ，它就拥有了“拷贝语义”。


💡 **所以在上例中，Vec对象的所有权由‘a’转移给了‘b'，此后‘a’不再有接触相应资源的所有权。**
