title: 借用
---

在一个实际的应用中，大多数情况下我们都有需要将一个变量绑定传递给函数或赋值给另一个函数。这种情形下，我们可以**引用**原始绑定，**借用**其绑定的数据。

## 何为“借用”?

> [借用 \(verb\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  
> 取得某事物并约定未来将归还。 

## 共享借用 & 可变借用

⭐️ 借用有两种类型,

1. **共享借用** `(&T)`

   * 一段数据可以**被一个或多个用户借用**，但**数据不可进行修改**。

2. **可变借用** `(&mut T)`

   * 一段数据可以**被一个用户借用并加以修改**，但在借用期间，这段数据不可被任何其他用户所访问。

## 借用规则

借用有一些重要的规则，

1. 一段数据在同一时间内，或是可以被共享借用，或是可以被可变借用，**但不可以同时以两种形式被借用**；

2. 借用**既可对拷贝类型的数据使用，也可以对转移类型的数据使用**；

3. 要注意**存活期** ↴
```rust

fn main() {
    let mut a = [1, 2, 3];
    let b = &mut a; // 此处发生一个可变借用
    println!("b: {:?}, a: {:?}", b, a); // 抛错，同一时间使用可变借用和不可变借用
}
```

```rust 2015
// Rust 2015
fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  可变借用此处开始
                   //  ⁝
  // some code     //  ⁝
  // some code     //  ⁝
}                  //  可变借用此处结束

fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  // 此处发生了一个可变借用
  // some code

  println!("{:?}", a); // 此处想以共享借用的方式访问数据，抛错
}                  //  可变借用此处才结束

fn main() {
  let mut a = vec![1, 2, 3];
  {
    let b = &mut a;  //  此处发生了一个可变借用
    // any other code
  }                  //  使用花括号标记一个代码块的范围，离开代码块后，可变引用结束

  println!("{:?}", a); // 此处允许重新以共享借用的方式访问数据
}
```
```rust 2018
// Rust 2018
fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  此处发生了一个可变借用
  // some code
                       // 在此之后没有对于可变引用的使用，Rust2018会推测可变引用生存期结束
  println!("{:?}", a); // 因为之前的可变借用已结束，此处又重新以共享借用的方式访问了原始数据
}                  // 共享借用此处结束


```

💡 我们来看一些关于共享和可变借用的实际例子

### 共享借用

```rust
fn main() {
    let a = [1, 2, 3];
    let b = &a;
    println!("{:?} {}", a, b[0]); // [1, 2, 3] 1
}


fn main() {
    let a = vec![1, 2, 3];
    let b = get_first_element(&a);

    println!("{:?} {}", a, b); // [1, 2, 3] 1
}

fn get_first_element(a: &Vec<i32>) -> i32 {
    a[0]
}
```

### 可变借用

```rust
fn main() {
    let mut a = [1, 2, 3];
    let b = &mut a;
    b[0] = 4;
    println!("{:?}", b); // [4, 2, 3]
}

// Rust 2015
fn main() {
    let mut a = [1, 2, 3];
    {
        let b = &mut a;
        b[0] = 4;
    }

    println!("{:?}", a); // [4, 2, 3]
}
// Rust 2018
fn main() {
    let mut a = [1, 2, 3];
    let b = &mut a;
    b[0] = 4;

    println!("{:?}", a); // [4, 2, 3]
}


fn main() {
    let mut a = vec![1, 2, 3];
    let b = change_and_get_first_element(&mut a);

    println!("{:?} {}", a, b); // [4, 2, 3] 4
}

fn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {
    a[0] = 4;
    a[0]
}
```
