title: 生命周期 - Lifetimes
---

当我们在处理引用相关的情况时，我们需要确保所引用的数据在我们引用的过程中一直存在。

想象一下，

* 我们有一个变量绑定，“**a**”；
* 我们使用另一个变量绑定“x”引用了“a”中的数据。我们必须保证在使用“x”的整个过程中，“a”的数据必须**生存**着。

> 🔎 **内存管理**是一种对于电脑内存资源进行管理的机制。直到1990年代中期，大多数的编程语言使用的是**手动内存管理**，这就要求**程序员手动**指定并回收不再需要使用的对象/垃圾。大约在1959年，John McCarthy发明了**垃圾回收（GC）**机制，一种**自动化的内存管理（AMM）**机制。它会自动识别并释放无用的内存空间而无需再依赖程序员的手工操作。此外，**Objective-C and Swift**等语言也通过**自动引用计数 - Automatic Reference Counting**\(ARC\)机制来实现类似的功能。

## 何为生命周期?

在Rust中，

* 一个资源同一时间只能有**一个所有者**。当它**离开当前域**，Rust就会在内存中将其删除。
* 当我们想要重用同一资源时，我们会使用**引用**它或**借用**它的内容。
* 当我们处理**引用**时，我们需要指定**生命周期声明**，以提示**编译器**这些被引用的资源**应当存活多久**。
* ⭐ ️但是过多的生命周期声明会让**代码变得冗长**，为了使**通常情况下的编程**更加人性化，Rust允许在定义`fn`时对生命周期声明进行省略。这种情况下，编译器会**推断**相应的生命周期声明。

生命周期声明会在**编译时进行价差**。编译器会在第一次和最后一次使用数据时进行检查。根据这一结果，Rust在**运行时**会对内存进行管理。这也是导致Rust编译时间略长的主要原因。

> * 不同于C或C++，Rust**通常**不需要明确的主动丢弃数据；
> * 不同于垃圾回收，Rust并不会在一个数据没有引用的情况下收回所分配的内存;
> * Rust会在数据离开域的时候回收所属内存并强制保证后续不再有对于这一段数据的引用。

## 使用生命周期

生命周期声明由一个单引号所标记。通常的习惯是使用一个小写字母作为命名，一般从`'a`开始，并在**需要多个生命周期声明时按字母表向后排列**。

何时使用引用：

### 01. 声明函数时

* 入参或出参中使用引用，应当在`&`符号后附加生命周期声明，如：`..(x: &'a str)` , `..(x: &'a mut str)`
* 在函数名后，我们应给出一个声明周期命名作为泛型声明，如：`fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`

```rust
// 没有输入，但返回一个引用
fn function<'a>() -> &'a str {}

// 单一入参
fn function<'a>(x: &'a str) {}

// 单一入参，单一结果，二者生命周期相同，且结果的生命周期至少与入参相同
fn function<'a>(x: &'a str) -> &'a str {}

// 多个入参，仅有一个入参和返回结果使用同一生命周期，即返回值至少与参数y的生命周期相同
fn function<'a>(x: i32, y: &'a str) -> &'a str {}

// 多个入参，所有入参和结果的声明周期均相同，即返回值至少与x和y存活的一样久
fn function<'a>(x: &'a str, y: &'a str) -> &'a str {}

// 多个入参，入参的生命周期不同，返回值的生命周期至少大于等于参数x🔎
fn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}
```

### 02. 结构体和枚举声明时

* 引用类型的元素应该在`&`符号后附加生命周期声明；
* 在结构体或枚举的名称后，应以泛型的形式增加生命周期类型。

```rust
// 单一元素，数据x应该至少在结构体存在的时候都存活
struct Struct<'a> {
    x: &'a str
}

// 多个元素，x和y在结构体存在时都应存活
struct Struct<'a> {
    x: &'a str,
    y: &'a str
}


// 单一元素变体
// 变体存在的时间应该至少与枚举一样长
enum Enum<'a> {
    Variant(&'a Type)
}
```

### 03. 增加实现和特性时

```rust
struct Struct<'a> {
    x: &'a str
}
    impl<'a> Struct<'a> {
        fn function<'a>(&self) -> &'a str {
            self.x
        }
    }


struct Struct<'a> {
    x: &'a str,
    y: &'a str
}
    impl<'a> Struct<'a> {
        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // 在new函数后并不需要再次指定<'a>，因为在impl后已经有所指明
          Struct {
              x : x,
              y : y
          }
        }
    }


// 🔎
impl<'a> Trait<'a> for Type
impl<'a> Trait for Type<'a>
```

### 04. 同泛型一起使用

```rust
// 🔎
fn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)
struct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }
enum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }
impl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }
```

## 声明周期省略

如前所述，为了令**通常情况**下的开发更加人性化，Rust允许在开发时进行生命周期声明的省略，这一过程即是**生命周期省略**。

💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But in the future it will support for `impl` headers as well.

Lifetime annotations of `fn` definitions can be elided  
if its **parameter list** has either,

* **only one input parameter passes by reference**.
* a parameter with **either** `&self` **or** **&mut self** reference.

```rust
fn triple(x: &u64) -> u64 { //only one input parameter passes by reference
    x * 3
}


fn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference
    if x > 5 { y } else { "invalid inputs" }
}


struct Player<'a> {
    id: u8,
    name: &'a str
}
    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.
        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference
            Player {
                id : id,
                name : name
            }
        }

        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference
            format!("{}: {}", self.id, self.name)
        }
    }

fn main() {
    let player1 = Player::new(1, "Serena Williams");
    let player1_heading_text = player1.heading_text()
    println!("{}", player1_heading_text);
}
```

> 💡 In the Lifetime Elision process of fn definitions,
>
> * Each parameter passes by reference is got a distinct lifetime annotation.
>     ex. `..(x: &str, y: &str)` → `..<'a, 'b>(x: &'a str, y: &'b str)`
> * If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.
>     ex. `..(x: i32, y: &str) -> &str` → `..<'a>(x: i32, y: &'a str) -> &'a str`
> * Even it has multiple parameters pass by reference, if one of them has &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.
>     ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` →
>     `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`
> * For all other cases, we have to write lifetime annotations manually.

## `'static` Annotations

`'static` lifetime annotation is a **reserved** lifetime annotation. These **references are valid for the entire program**. They are saved in the data segment of the binary and the data referred to will never go out of scope.

```rust
static N: i32 = 5; //A constant with 'static lifetime

let a = "Hello, world."; //a: &'static str


fn index() -> &'static str { //No need to mention <'static> ; fn index ̶<̶'̶s̶t̶a̶t̶i̶c̶>̶ 
	"Hello, world!"
}
```

## Few more examples about usage of Rust lifetimes.

```rust
fn greeting<'a>() -> &'a str {
  "Hi!"
}


fn fullname<'a>(fname: &'a str, lname: &'a str) -> String {
  format!("{} {}", fname, lname)
}


struct Person<'a> {
    fname: &'a str,
    lname: &'a str
}
  impl<'a> Person<'a> {
      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it
          Person {
              fname : fname,
              lname : lname
          }
      }

      fn fullname(&self) -> String {
          format!("{} {}", self.fname , self.lname)
      }
  }

fn main() {
    let player = Person::new("Serena", "Williams");
    let player_fullname = player.fullname();

    println!("Player: {}", player_fullname);
}
```
