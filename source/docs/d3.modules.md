title: 模块 - Modules
---

## 01. 文件内模块

相关联的代码与数据与代码组织为一个模块并与其他代码存放在同一文件内。

```rust
fn main() {
   greetings::hello();
}

mod greetings {
  // ⭐️ 默认情况下，模块内部的所有成员都是私有的
  pub fn hello() { // ⭐️ 所以需要在函数前增加pub关键字使其变为public成员并能被外部访问
    println!("Hello, world!");
  }
}
```

模块可以多层嵌套。

```rust
fn main() { 
  phrases::greetings::hello();
}

mod phrases { 
  pub mod greetings { 
    pub fn hello() { 
      println!("Hello, world!");
    }
  }
}
```

私有方法也可以被同级模块或子级模块的其他成员访问到。

```rust
// 01. 同一模块内调用私有函数
fn main() {
  phrases::greet();
}

mod phrases {
  pub fn greet() {
    hello(); // 或使用 `self::hello();`
  }
  
  fn hello() {
    println!("Hello, world!");
  }
}

// 02. 调用父级模块中的私有函数
fn main() {
  phrases::greetings::hello();
}

mod phrases {
  fn private_fn() {
    println!("Hello, world!");
  }
  
  pub mod greetings {
    pub fn hello() {
      super::private_fn();
    }
  }
}
```

> 💡 `self`关键字用来引用同一模块，相应的，`super`关键字用来引用父级模块。此外，一个模块中也可以使用`super`来访问根函数中的内容。

```rust
fn main() {
  greetings::hello();
}

fn hello() {
  println!("Hello, world!");
}

mod greetings {
  pub fn hello() {
    super::hello();
  }
}
```

> 🔎 在编写测试用例时，一个很好的实践是将其包裹在test模块中，这样仅在测试时会对该模块进行编译。

```rust
fn greet() -> String {
    "Hello, world!".to_string()
}

#[cfg(test)] // 仅在进行测试时进行编译
mod tests {
    use super::greet; // 引入根部的greet函数

    #[test]
    fn test_greet() {
        assert_eq!("Hello, world!", greet());
    }
}
```

## 02. 同一文件夹的不同文件

```rust
// ↳ main.rs
mod greetings; // 引入greetings模块

fn main() {
  greetings::hello();
}

// ↳ greetings.rs
// ⭐️ 并不需要将模块包裹在一个mod声明中。一个文件本身就扮演者一个模块的角色。
pub fn hello() { // 函数需要作为公有成员才能被外部访问到。
  println!("Hello, world!");
}
```

如果一个文件里包含一个`mod`声明，所声明的模块将被认为是嵌套模块。

```rust
// ↳ main.rs
mod phrases;

fn main() {
  phrases::greetings::hello();
}

// ↳ phrases.rs
pub mod greetings { // ⭐️该模块需要作为public模块才可以被外部访问到
  pub fn hello() {
    println!("Hello, world!");
  }
}
```

## 03. 不同文件夹下的不同文件

`mod.rs` in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.

```rust
// ↳ main.rs
mod greetings;

fn main() {
  greetings::hello();
}

// ↳ greetings/mod.rs
pub fn hello() { // ⭐️ The function has to be public to access from outside
  println!("Hello, world!");
}
```

Again, If we wrap file content with a `mod` declaration, it will act as a nested module.

```rust
// ↳ main.rs
mod phrases;

fn main() {
  phrases::greetings::hello();
}

// ↳ phrases/mod.rs
pub mod greetings { // ⭐️ The module has to be public to access from outside
  pub fn hello() {
    println!("Hello, world!");
  }
}
```

Other files in the directory module act as sub-modules for `mod.rs`.

```rust
// ↳ main.rs
mod phrases;

fn main() {
  phrases::hello()
}

// ↳ phrases/mod.rs
mod greetings;

pub fn hello() {
  greetings::hello()
}

// ↳ phrases/greetings.rs
pub fn hello() {
  println!("Hello, world!");
}
```

⭐️ If you need to access an element of `phrases/greetings.rs` from outside the module, you have to import the `greetings` module as a public module.

```rust
// ↳ main.rs
mod phrases;

fn main() {
    phrases::greetings::hello();
}

// ↳ phrases/mod.rs
pub mod greetings;  // ⭐️ `pub mod` instead `mod`

// ↳ phrases/greetings.rs
pub fn hello() {
  println!("Hello, world!");
}
```

> 🔎 It’s unable to import child file modules of directory modules to `main.rs`, so you can’t use `mod phrases::greetings;` from `main.rs`. But there is a way to import `phrases::greetings::hello()` to `phrases` module by re-exporting `hello` to `phrases` module. So you can call it directly as `phrases::hello()`.

```rust
// ↳ phrases/greetings.rs
pub fn hello() {
  println!("Hello, world!");
}

// ↳ phrases/mod.rs
pub mod greetings;

pub use self::greetings::hello; // Re-export `greetings::hello` to phrases

// ↳ main.rs
mod phrases;

fn main() {
    phrases::hello(); // You can call `hello()` directly from phrases
}
```

This allows you to present an external interface that **may not directly map** to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of `use` on an upcoming section in this post.